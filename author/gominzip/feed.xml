<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://blog.liboo.kr/author/gominzip/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://blog.liboo.kr/" rel="alternate" type="text/html" />
  <updated>2024-12-31T08:09:10+00:00</updated>
  <id>https://blog.liboo.kr/author/gominzip/feed.xml</id>

  
  
  

  
    <title type="html">Liboo.blog | </title>
  

  
    <subtitle>The professional publishing platform</subtitle>
  

  

  
    
      
    
      
    
      
    
      
    
      
    
  

  
  

  
    <entry>
      <title type="html">다중 탭에서 하나의 소켓을 공유할 수 있을까</title>
      <link href="https://blog.liboo.kr/%EB%8B%A4%EC%A4%91_%ED%83%AD%EC%97%90%EC%84%9C_%ED%95%98%EB%82%98%EC%9D%98_%EC%86%8C%EC%BC%93%EC%9D%84_%EA%B3%B5%EC%9C%A0%ED%95%A0_%EC%88%98_%EC%9E%88%EC%9D%84%EA%B9%8C" rel="alternate" type="text/html" title="다중 탭에서 하나의 소켓을 공유할 수 있을까" />
      <published>2024-11-23T04:32:00+00:00</published>
      <updated>2024-11-23T04:32:00+00:00</updated>
      <id>https://blog.liboo.kr/%EB%8B%A4%EC%A4%91_%ED%83%AD%EC%97%90%EC%84%9C_%ED%95%98%EB%82%98%EC%9D%98_%EC%86%8C%EC%BC%93%EC%9D%84_%EA%B3%B5%EC%9C%A0%ED%95%A0_%EC%88%98_%EC%9E%88%EC%9D%84%EA%B9%8C</id>
      <content type="html" xml:base="https://blog.liboo.kr/%EB%8B%A4%EC%A4%91_%ED%83%AD%EC%97%90%EC%84%9C_%ED%95%98%EB%82%98%EC%9D%98_%EC%86%8C%EC%BC%93%EC%9D%84_%EA%B3%B5%EC%9C%A0%ED%95%A0_%EC%88%98_%EC%9E%88%EC%9D%84%EA%B9%8C">&lt;h1 id=&quot;why&quot;&gt;Why?&lt;/h1&gt;

&lt;p&gt;현재 채팅 기능의 로직은 이러하다&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;채팅 컴포넌트 마운트&lt;/li&gt;
  &lt;li&gt;서버 소켓과 connection을 위한 새로운 소켓 생성&lt;/li&gt;
  &lt;li&gt;userId, sessionId를 알고 있는 상태에서 join_room 시도&lt;/li&gt;
  &lt;li&gt;서버에서 userId를 토대로 검증 후 채팅 가능 여부 전송&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;처음 채팅 기능을 설계할 때도 고민했던 지점은 매번 마운트&amp;amp;언마운트 시에 소켓을 생성해 connect하고 disconnect를 반복하는 부분이었다.&lt;/p&gt;

&lt;p&gt;userId는 고유하지만 사용자가 여러탭으로 입장하게 된다면 하나의 userId에 대한 여러 socket이 연결된다는 문제가 있었고, 이로인해 불필요한 소켓 연결이 늘어나 서버의 리소스 낭비를 불러일으킬 수 있다는 결론이 나왔다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=SVt1-Opp3Wo&quot;&gt;https://www.youtube.com/watch?v=SVt1-Opp3Wo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;그러던 중 토스에서도 같은 고민을 했었으며 해당 영상의 인사이트를 통해 하나의 userId에 대한 하나의 소켓으로 개선해보기로 결정하였다.&lt;/p&gt;

&lt;h1 id=&quot;how&quot;&gt;How?&lt;/h1&gt;

&lt;p&gt;브라우저 탭들이 하나의 상태를 공유할 수 있도록하는 외부의 무언가가 필요했다&lt;/p&gt;

&lt;p&gt;그리고 Web Worker API는 그 역할을 해 줄 수 있었다!&lt;/p&gt;

&lt;h2 id=&quot;shared-worker-thread&quot;&gt;Shared Worker Thread&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-23-다중_탭에서_하나의_소켓을_공유할_수_있을까.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;sharedworkerthread에-소켓-넣고-공유해보기&quot;&gt;SharedWorkerThread에 소켓 넣고 공유해보기&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://velog.io/@typo/sharing-websocket-connections-betwwen-tabs-and-windows&quot;&gt;https://velog.io/@typo/sharing-websocket-connections-betwwen-tabs-and-windows&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;기존 레퍼런스들은 리액트 + 웹팩과 WS 모듈을 사용한다는 점에서 우리 프로젝트와 다른 부분들이 있었다.&lt;/p&gt;

&lt;p&gt;클라이언트와 sharedWorker를 연결하는 과정은 쉽게 될 것이라 생각했지만.. 생각보다 많은 문제가 발생했다.&lt;/p&gt;

&lt;h2 id=&quot;workerts-스크립트&quot;&gt;worker.ts 스크립트&lt;/h2&gt;

&lt;p&gt;워커의 내부 동작을 작성한 스크립트이다. ts의 경우 &lt;reference lib=&quot;webworker&quot;&gt;&lt;/reference&gt;를 작성해주어야 워커관련 타입과 메서드를 인식해준다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
/// &amp;lt;reference lib=&quot;webworker&quot; /&amp;gt;

import { io } from &quot;socket.io-client&quot;;

// 소켓 연결
const socket = io(&quot;http://localhost:8080&quot;); // 서버 URL
const ports: MessagePort[] = [];

self.onconnect = (e: MessageEvent) =&amp;gt; {
  const port = e.ports[0];
  ports.push(port);

  // 클라이언트에서 오는 메시지를 소켓 서버로 전달
  port.onmessage = (messageEvent) =&amp;gt; {
    const { message } = messageEvent.data;
    console.log(&quot;Received message in SharedWorker:&quot;, message);

    // 서버로 메시지 전송
    socket.emit(&quot;send_normal_chat&quot;, { msg: message });
  };

  // 소켓에서 오는 메시지를 모든 탭에 전달
  socket.on(&quot;message&quot;, (msg: string) =&amp;gt; {
    ports.forEach((p) =&amp;gt; p.postMessage({ message: msg }));
  });
};

export const test = 0;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;shared-worker-생성&quot;&gt;Shared Worker 생성&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://ko.vite.dev/guide/features#web-workers&quot;&gt;https://ko.vite.dev/guide/features#web-workers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1차 시도: 여러 레퍼런스에서 진행하는 생성자를 통한 워커 생성을 진행하였다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
import { useEffect, useState } from &quot;react&quot;;

const App = () =&amp;gt; {
  const [worker, setWorker] = useState&amp;lt;SharedWorker | null&amp;gt;(null);
  const [message, setMessage] = useState&amp;lt;string&amp;gt;(&quot;&quot;);

  // App.tsx에서 worker.ts를 동적으로 import
  useEffect(() =&amp;gt; {
    const worker = new SharedWorker(new URL(&quot;./worker.ts&quot;, import.meta.url));

    // worker가 준비되면 메시지 전송
    worker.port.onmessage = (event) =&amp;gt; {
      console.log(&quot;Received message from worker:&quot;, event.data.message);
      setMessage(event.data.message);
    };

    worker.port.start();

    // 초기 메시지 전송
    worker.port.postMessage({ message: &quot;Hello from React!&quot; });

    setWorker(worker);

    return () =&amp;gt; {
      worker.port.close();
    };
  }, []);


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 계속해서 socket 생성도 되지 않고 port와 연결이 되지 않는 모습이 보였고, 브라우저의 소스코드 파일을 확인해본 결과 worker 스크립트가 올라가지 않는 문제를 발견&lt;/p&gt;

&lt;p&gt;&lt;del&gt;이는 vite의 트리쉐이킹 문제로 import로 가져오지 않은 스크립트 파일이었으므로 빌드 과정에서 올라가지 못했고 스크립트가 없는 SharedWorker가 생성되게 된것이다.&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;⇒ 멘토님: 잘못됐다. 브라우저에 어떻게 올라가느냐를 알아보자&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;️해당-문제의-원인과-해결&quot;&gt;❗️해당 문제의 원인과 해결&lt;/h2&gt;

&lt;p&gt;처음에는 단순히 트리쉐이킹으로 import 문이 없어서 소스에 파일이 들어오지 못했나? 라는 뇌피셜을 마구마구 적어두었다… 하지만 이는 전혀 무관하다!&lt;/p&gt;

&lt;p&gt;트리 셰이킹은 번들링 단계에서 불필요한 코드(사용되지 않는 모듈)를 제거하는 최적화 과정으로, 워커 파일의 실행 방식이나 브라우저에서의 동작과는 직접적인 관계가 없다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
const worker = new SharedWorker(new URL(&apos;/src/utils/chatWorker.ts&apos;, import.meta.url), { type: &apos;module&apos; });

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1-sharedworker의-작동-방식&quot;&gt;1. &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SharedWorker&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;의 작동 방식&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;SharedWorker&lt;/strong&gt;는 JavaScript 파일을 워커 스레드로 실행합니다. 브라우저는 워커를 실행할 때 해당 파일을 가져와 실행하지만, 워커가 모듈로 작성되었는지 여부를 알아야 적절히 처리할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type: &apos;module&apos;&lt;/code&gt;을 지정하면 브라우저는 해당 워커 파일을 &lt;strong&gt;ES 모듈&lt;/strong&gt;로 처리합니다.&lt;/li&gt;
  &lt;li&gt;ES 모듈로 처리하면 다음이 가능합니다:
    &lt;ol&gt;
      &lt;li&gt;파일 내부에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import/export&lt;/code&gt;를 사용할 수 있음.&lt;/li&gt;
      &lt;li&gt;파일 스코프가 독립적임.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;2-왜-type-module을-붙여야-하나&quot;&gt;2. &lt;strong&gt;왜&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type: &apos;module&apos;&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;을 붙여야 하나?&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Vite는 기본적으로 ES 모듈을 기반으로 동작하며, 브라우저에서 모듈 방식으로 스크립트를 처리하도록 번들링합니다.&lt;/p&gt;

&lt;h3 id=&quot;브라우저가-파일을-로드하는-과정&quot;&gt;브라우저가 파일을 로드하는 과정:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;브라우저는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SharedWorker&lt;/code&gt;의 첫 번째 인자로 받은 파일 경로를 &lt;strong&gt;네트워크 요청&lt;/strong&gt;으로 받아옵니다.&lt;/li&gt;
  &lt;li&gt;요청한 파일이 &lt;strong&gt;일반 스크립트&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type: &quot;classic&quot;&lt;/code&gt;)로 처리되면, 파일 내용이 전역 스코프에서 실행됩니다.&lt;/li&gt;
  &lt;li&gt;요청한 파일이 &lt;strong&gt;모듈 스크립트&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type: &quot;module&quot;&lt;/code&gt;)로 처리되면, 브라우저는 이를 &lt;strong&gt;ESM&lt;/strong&gt;으로 실행하며, 모듈 사양에 맞는 환경에서 처리합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;따라서, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SharedWorker&lt;/code&gt; 파일이 모듈로 작성되었다면 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type: &apos;module&apos;&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;을 지정해야 브라우저가 이를 올바르게 처리&lt;/strong&gt;할 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;3-vite의-번들링-과정과-type-module의-관계&quot;&gt;3. &lt;strong&gt;Vite의 번들링 과정과&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type: &apos;module&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;의 관계&lt;/strong&gt;&lt;/h2&gt;

&lt;h3 id=&quot;vite의-동작-방식&quot;&gt;Vite의 동작 방식:&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;파일 변환&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;Vite는 TypeScript 파일(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.ts&lt;/code&gt;)을 JavaScript 파일(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.js&lt;/code&gt;)로 변환합니다.&lt;/li&gt;
      &lt;li&gt;ES6 이상의 모듈 사양에 따라 번들링합니다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import.meta.url&lt;/code&gt;은 Vite가 처리하여 브라우저에서 파일 경로를 알 수 있도록 합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;파일 제공&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;개발 서버 모드에서 Vite는 파일을 번들링하지 않고 &lt;strong&gt;온디맨드로 제공&lt;/strong&gt;합니다.&lt;/li&gt;
      &lt;li&gt;브라우저가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new URL(&apos;/src/utils/chatWorker.ts&apos;, import.meta.url)&lt;/code&gt;을 요청하면 Vite는 해당 파일을 동적으로 처리하고 반환합니다.&lt;/li&gt;
      &lt;li&gt;프로덕션 빌드에서는 Vite가 워커 파일을 &lt;strong&gt;별도 번들&lt;/strong&gt;로 분리하여 제공하며, 브라우저가 이 파일을 적절히 로드하도록 경로를 설정합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;모듈 지원&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;Vite는 워커 파일을 기본적으로 ES 모듈로 처리합니다.&lt;/li&gt;
      &lt;li&gt;워커를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type: &apos;module&apos;&lt;/code&gt;로 지정하지 않으면 브라우저는 이를 일반 스크립트로 처리하려고 하며, 이 경우 오류가 발생할 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;4-type-module이-없을-때-발생하는-문제&quot;&gt;4. &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type: &apos;module&apos;&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;이 없을 때 발생하는 문제&lt;/strong&gt;&lt;/h2&gt;

&lt;h3 id=&quot;문제&quot;&gt;문제:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;브라우저가 워커 파일을 일반 스크립트로 실행하려고 시도.&lt;/li&gt;
  &lt;li&gt;Vite가 번들링한 결과 파일은 &lt;strong&gt;ESM 사양&lt;/strong&gt;에 따라 작성되므로 일반 스크립트로 실행할 수 없음.&lt;/li&gt;
  &lt;li&gt;예를 들어, Vite는 워커 파일에서 다음과 같은 코드를 생성할 수 있습니다:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
	javascript
	코드 복사
	import { someFunction } from &apos;./someModule.js&apos;;
	someFunction();
	
	
	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;브라우저는 일반 스크립트에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import&lt;/code&gt;를 지원하지 않으므로 에러 발생:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
	javascript
	코드 복사
	SyntaxError: Unexpected token &apos;import&apos;
	
	
	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;해결&quot;&gt;해결:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type: &apos;module&apos;&lt;/code&gt;을 명시하면 브라우저는 해당 파일을 모듈로 처리하고, Vite가 제공하는 파일을 정상적으로 실행.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;5-vite가-제공하는-url-동작-방식&quot;&gt;5. &lt;strong&gt;Vite가 제공하는 URL 동작 방식&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new URL(&apos;/src/utils/chatWorker.ts&apos;, import.meta.url)&lt;/code&gt;은 다음 단계를 거칩니다:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Vite는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import.meta.url&lt;/code&gt;을 통해 현재 모듈의 URL을 계산.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/src/utils/chatWorker.ts&lt;/code&gt; 경로를 현재 모듈의 URL을 기준으로 해석.&lt;/li&gt;
  &lt;li&gt;워커 파일을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://localhost:3000/src/utils/chatWorker.ts&lt;/code&gt;처럼 브라우저에서 접근 가능한 URL로 변환.&lt;/li&gt;
  &lt;li&gt;브라우저가 해당 URL로 요청을 보냄.&lt;/li&gt;
  &lt;li&gt;Vite 개발 서버가 해당 파일을 동적으로 처리하여 반환.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;6-결론&quot;&gt;6. &lt;strong&gt;결론&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type: &apos;module&apos;&lt;/code&gt;은 브라우저에게 워커 파일이 &lt;strong&gt;ES 모듈&lt;/strong&gt;임을 알려주는 역할.&lt;/li&gt;
  &lt;li&gt;Vite는 파일을 번들링하거나 제공할 때 &lt;strong&gt;ES 모듈 형식&lt;/strong&gt;으로 처리하므로, 이를 명시적으로 지정해야 브라우저가 올바르게 로드.&lt;/li&gt;
  &lt;li&gt;Vite와 브라우저의 모듈 동작을 결합한 결과, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type: &apos;module&apos;&lt;/code&gt;을 지정하지 않으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import/export&lt;/code&gt; 관련 에러가 발생.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2차 시도&lt;/p&gt;

&lt;p&gt;마지막으로 vite 공식문서에 적혀있던 두번째 import 방식을 사용해보았다.&lt;/p&gt;

&lt;p&gt;쿼리 접미사 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?worker&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?sharedworker&lt;/code&gt;를 이용해 스크립트 파일을 가져올 수 있다&lt;/p&gt;

&lt;p&gt;해당 방식을 통해 스크립트 파일은 트리쉐이킹이 되지 않고 성공적으로 워커를 생성할 수 있었다 ㅜㅜ&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
import { useEffect, useState } from &quot;react&quot;;
import MyWorker from &quot;./worker?sharedworker&quot;;

const App = () =&amp;gt; {
  const [worker, setWorker] = useState&amp;lt;SharedWorker | null&amp;gt;(null);
  const [message, setMessage] = useState&amp;lt;string&amp;gt;(&quot;&quot;);

  useEffect(() =&amp;gt; {
    const worker = new MyWorker();

    console.log(worker);
    // worker가 준비되면 메시지 전송
    worker.port.onmessage = (event) =&amp;gt; {
      console.log(&quot;Received message from worker:&quot;, event.data.message);
      setMessage(event.data.message);
    };

    worker.port.start();

    // 초기 메시지 전송
    worker.port.postMessage({ message: &quot;Hello from React!&quot; });

    setWorker(worker);

    return () =&amp;gt; {
      worker.port.close();
    };
  }, []);

  const handleClick = () =&amp;gt; {
    if (worker) {
      // 버튼 클릭 시 메시지 전송
      worker.port.postMessage({ message: &quot;Hello from React on button click!&quot; });
    }
  };

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;h1&amp;gt;React with Shared Worker and Socket.io&amp;lt;/h1&amp;gt;
      &amp;lt;p&amp;gt;Received from worker: {message}&amp;lt;/p&amp;gt;
      &amp;lt;button onClick={handleClick}&amp;gt;Send Message to Worker&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
  );
};

export default App;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-23-다중_탭에서_하나의_소켓을_공유할_수_있을까.md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위는 클라이언트 탭을 2개 띄웠을때의 서버 로그이다.&lt;/p&gt;

&lt;p&gt;처음 탭이 열렸을 때 shared worker는 공유될 소켓 하나를 생성한다 (id: un19~)&lt;/p&gt;

&lt;p&gt;그리고 탭일 열렸을 때 클라이언트에서 “Hello from React”를 shared worker에게 postMessage를 하고 worker는 받은 메세지를 자신의 socket을 통해 서버로 전송한다.&lt;/p&gt;

&lt;p&gt;다른 탭을 열렸을 때는 이미 소켓이 있기 때문에 새로 생성이 이뤄지지 않고 이미 존재하는 소켓으로 또다시 서버에 메세지를 보낸 걸 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;해당 과정을 좀더 확실하게 보고자 port가 연결될 때마다 카운팅을 하고 로그를 찍어보았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-23-다중_탭에서_하나의_소켓을_공유할_수_있을까.md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;새로운 탭을 열거나 새로고침을 할 때마다 새로운 소켓이 생성되는 것이 아닌 하나의 소켓을 여러 포트(탭)에서 공유하고 있는 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;만약 포트(탭)을 사용하지 않게된다면 포트에 대한 공간을 제거하는 방식은 가비지 콜렉터를 이용한다고 한다. 후에 알아보자..&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;gominzip&quot;]</name>
        
        
      </author>

      

      

      
        <summary type="html">Why?</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">채팅창 렌더링 최적화</title>
      <link href="https://blog.liboo.kr/%EC%B1%84%ED%8C%85%EC%B0%BD_%EB%A0%8C%EB%8D%94%EB%A7%81_%EC%B5%9C%EC%A0%81%ED%99%94" rel="alternate" type="text/html" title="채팅창 렌더링 최적화" />
      <published>2024-11-22T11:07:00+00:00</published>
      <updated>2024-11-22T11:07:00+00:00</updated>
      <id>https://blog.liboo.kr/%EC%B1%84%ED%8C%85%EC%B0%BD_%EB%A0%8C%EB%8D%94%EB%A7%81_%EC%B5%9C%EC%A0%81%ED%99%94</id>
      <content type="html" xml:base="https://blog.liboo.kr/%EC%B1%84%ED%8C%85%EC%B0%BD_%EB%A0%8C%EB%8D%94%EB%A7%81_%EC%B5%9C%EC%A0%81%ED%99%94">&lt;h2 id=&quot;문제-상황&quot;&gt;🚨 문제 상황&lt;/h2&gt;

&lt;p&gt;마클에서 준일님이 시연하시던 중에 채팅창 외부를 눌렀음에도 채팅창이 계속 리렌더링되는 이슈&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-22-채팅창_렌더링_최적화.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;개선…해야겠지?&lt;/p&gt;

&lt;h2 id=&quot;해결-과정&quot;&gt;🏃 해결 과정&lt;/h2&gt;

&lt;p&gt;리액트 개발자 도구는 알고만 있었지 써보지는 않았는데 왜 이제 써봤을까 싶음&lt;/p&gt;

&lt;p&gt;렌더링에 걸린 속도와 해당 컴포넌트를 바로 확인해볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-22-채팅창_렌더링_최적화.md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;채팅창에서 헤더의 설정 버튼을 누른 상태에서 헤더를 제외한 외부를 누르면 팝업이 닫아지도록 이벤트 설정을 해둠&lt;/p&gt;

&lt;p&gt;→ 이로인해 채팅창 클릭시 매번 불필요한 리렌더링이 발생하고 있었음&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
  const handleClickOutside = useCallback(
    (event: MouseEvent) =&amp;gt; {
      if (headerRef.current &amp;amp;&amp;amp; !headerRef.current.contains(event.target as Node)) {
        dispatch({ type: &apos;CLOSE_SETTINGS&apos; });
      }
    },
    [dispatch]
  );

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handleClickOutside&lt;/code&gt; 함수의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispatch&lt;/code&gt; 호출로 인해 이미 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state.isSettingsOpen&lt;/code&gt;이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt;인 상태에서도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CLOSE_SETTINGS&lt;/code&gt; 액션이 계속 발생하면서 불필요한 리렌더링이 발생했음&lt;/p&gt;

&lt;p&gt;따라서 현재 상태를 확인한 후 필요할 때만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispatch&lt;/code&gt;를 호출하도록 조건을 추가함&lt;/p&gt;

&lt;h2 id=&quot;문제-해결&quot;&gt;✅ 문제 해결&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
  const handleClickOutside = useCallback(
    (event: MouseEvent) =&amp;gt; {
      if (headerRef.current &amp;amp;&amp;amp; !headerRef.current.contains(event.target as Node) &amp;amp;&amp;amp; state.isSettingsOpen) {
        dispatch({ type: &apos;CLOSE_SETTINGS&apos; });
      }
    },
    [dispatch, state.isSettingsOpen]
  );

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state.isSettingsOpen&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;확인 추가&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state.isSettingsOpen&lt;/code&gt;이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt;인 경우에만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispatch&lt;/code&gt;를 호출하도록 조건을 추가&lt;/p&gt;

    &lt;p&gt;→ 닫혀있는 상태에서는 불필요한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispatch&lt;/code&gt; 호출 방지&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state.isSettingsOpen&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;을&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useCallback&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;의 의존성에 추가&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state.isSettingsOpen&lt;/code&gt; 값을 기반으로 조건을 추가했으므로, 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useCallback&lt;/code&gt;의 의존성 배열에 포함해 최신 상태 값을 항상 반영하도록 보장&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;gominzip&quot;]</name>
        
        
      </author>

      

      

      
        <summary type="html">🚨 문제 상황</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">[Socket.io] 클라이언트의 실시간 채팅 구현기</title>
      <link href="https://blog.liboo.kr/Socket.io-_%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%9D%98_%EC%8B%A4%EC%8B%9C%EA%B0%84_%EC%B1%84%ED%8C%85_%EA%B5%AC%ED%98%84%EA%B8%B0" rel="alternate" type="text/html" title="[Socket.io] 클라이언트의 실시간 채팅 구현기" />
      <published>2024-11-14T06:22:00+00:00</published>
      <updated>2024-11-14T06:22:00+00:00</updated>
      <id>https://blog.liboo.kr/%5BSocket.io%5D_%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%9D%98_%EC%8B%A4%EC%8B%9C%EA%B0%84_%EC%B1%84%ED%8C%85_%EA%B5%AC%ED%98%84%EA%B8%B0</id>
      <content type="html" xml:base="https://blog.liboo.kr/Socket.io-_%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%9D%98_%EC%8B%A4%EC%8B%9C%EA%B0%84_%EC%B1%84%ED%8C%85_%EA%B5%AC%ED%98%84%EA%B8%B0">&lt;p&gt;&lt;a href=&quot;https://socket.io/docs/v4/tutorial/introduction&quot;&gt;https://socket.io/docs/v4/tutorial/introduction&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;왜-socketio인가&quot;&gt;왜 Socket.io인가&lt;/h2&gt;

&lt;p&gt;기본적으로 WS 모듈과 비교를 해보았을때, room이라는 기능으로 채팅방을 분리하거나, broadcast로 연결된 전체 클라이언트에게 데이터를 보내는 기능들을 더 제공해준다.&lt;/p&gt;

&lt;p&gt;또한 WS의 경우 오랜된 브라우저의 경우 지원하지 않는 경우가 있다고 한다. Socket.io는 WS를 기반으로 만들어졌지만 지원이 되지 않는 경우 폴백 처리가 이뤄져 호환성이 더 좋다.&lt;/p&gt;

&lt;p&gt;Socket.io는 채팅방에 특화된 라이브러리라는 점에서 각 스트리밍 채널의 다양한 타입의 채팅을 처리해주기에 적절하다고 생각되었다.&lt;/p&gt;

&lt;p&gt;소켓 통신과 관련된 node:net과 WS는 이전에 사용해보기도 했기에 Socket.io를 잘 활용해보는 것이 생산성이나 학습 측면에서 좋은 경험이 될 것이라 기대된다.&lt;/p&gt;

&lt;h1 id=&quot;클라이언트---백-연결과정&quot;&gt;클라이언트 - 백 연결과정&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://socket.io/how-to/use-with-react&quot;&gt;https://socket.io/how-to/use-with-react&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
yarn add socket.io-client

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;각 채팅방 별로 메세지를 분리해서 받는 기능 구현&lt;/p&gt;

&lt;h2 id=&quot;서버&quot;&gt;서버&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
const express = require(&quot;express&quot;);
const http = require(&quot;http&quot;);
const { Server } = require(&quot;socket.io&quot;);

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  cors: {
    origin: &quot;http://localhost:5173&quot;,
    methods: [&quot;GET&quot;, &quot;POST&quot;],
  },
});

io.on(&quot;connection&quot;, (socket) =&amp;gt; {
  console.log(&quot;A user connected:&quot;, socket.id);

  socket.on(&quot;joinRoom&quot;, (room) =&amp;gt; {
    socket.join(room);
    console.log(`User ${socket.id} joined room ${room}`);
    socket
      .to(room)
      .emit(&quot;receiveMessage&quot;, `User ${socket.id} has joined room ${room}`);
  });

  // 클라이언트가 방을 떠날 때
  socket.on(&quot;leaveRoom&quot;, (room) =&amp;gt; {
    socket.leave(room);
    console.log(`User ${socket.id} left room ${room}`);
  });

  socket.on(&quot;sendMessage&quot;, ({ room, message }) =&amp;gt; {
    console.log(`Message received in room ${room}: ${message}`);
    io.to(room).emit(&quot;receiveMessage&quot;, message);
  });

  socket.on(&quot;disconnect&quot;, () =&amp;gt; {
    console.log(&quot;User disconnected:&quot;, socket.id);
  });
});

server.listen(8080, () =&amp;gt; {
  console.log(&quot;Server is running on http://localhost:8080&quot;);
});


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;클라이언트-리액트&quot;&gt;클라이언트 (리액트)&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
import { useEffect, useState } from &quot;react&quot;;
import &quot;./App.css&quot;;
import io from &quot;socket.io-client&quot;;

const socket = io(&quot;http://localhost:8080&quot;);

function App() {
  const [message, setMessage] = useState(&quot;&quot;);
  const [messages, setMessages] = useState&amp;lt;string[]&amp;gt;([]);
  const [room, setRoom] = useState(&quot;&quot;);
  const [currentRoom, setCurrentRoom] = useState(&quot;&quot;); // 현재 참여 중인 방을 추적

  useEffect(() =&amp;gt; {
    socket.on(&quot;receiveMessage&quot;, (newMessage) =&amp;gt; {
      setMessages((prevMessages) =&amp;gt; [...prevMessages, newMessage]);
    });

    return () =&amp;gt; {
      socket.off(&quot;receiveMessage&quot;);
    };
  }, []);

  const joinRoom = () =&amp;gt; {
    if (room.trim()) {
      // 기존 방이 있으면 나가기
      if (currentRoom) {
        socket.emit(&quot;leaveRoom&quot;, currentRoom);
      }

      // 새로운 방에 참여
      socket.emit(&quot;joinRoom&quot;, room);
      setCurrentRoom(room); // 현재 참여 중인 방 업데이트
      setMessages([]); // 방이 바뀔 때 메시지 초기화
    }
  };

  const sendMessage = () =&amp;gt; {
    if (message.trim() &amp;amp;&amp;amp; room) {
      socket.emit(&quot;sendMessage&quot;, { room, message });
      setMessage(&quot;&quot;);
    }
  };

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;h1&amp;gt;Chat Room&amp;lt;/h1&amp;gt;
      &amp;lt;div&amp;gt;
        &amp;lt;label&amp;gt;Select a room: &amp;lt;/label&amp;gt;
        &amp;lt;select onChange={(e) =&amp;gt; setRoom(e.target.value)}&amp;gt;
          &amp;lt;option value=&quot;&quot;&amp;gt;Choose...&amp;lt;/option&amp;gt;
          &amp;lt;option value=&quot;1&quot;&amp;gt;Room 1&amp;lt;/option&amp;gt;
          &amp;lt;option value=&quot;2&quot;&amp;gt;Room 2&amp;lt;/option&amp;gt;
          &amp;lt;option value=&quot;3&quot;&amp;gt;Room 3&amp;lt;/option&amp;gt;
        &amp;lt;/select&amp;gt;
        &amp;lt;button onClick={joinRoom}&amp;gt;Join Room&amp;lt;/button&amp;gt;
      &amp;lt;/div&amp;gt;

      &amp;lt;div&amp;gt;
        {messages.map((msg, index) =&amp;gt; (
          &amp;lt;p key={index}&amp;gt;{msg}&amp;lt;/p&amp;gt;
        ))}
      &amp;lt;/div&amp;gt;

      &amp;lt;input
        type=&quot;text&quot;
        value={message}
        onChange={(e) =&amp;gt; setMessage(e.target.value)}
        placeholder=&quot;Type a message...&quot;
      /&amp;gt;
      &amp;lt;button onClick={sendMessage}&amp;gt;Send&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
  );
}

export default App;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;치지직의-채팅-데이터&quot;&gt;치지직의 채팅 데이터&lt;/h2&gt;

&lt;h3 id=&quot;채팅-보내기&quot;&gt;채팅 보내기&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;json
{
    &quot;ver&quot;: &quot;3&quot;, // 프로토콜 버전 (버전 정보)
    &quot;cmd&quot;: 3101, // 명령 코드 (이벤트의 종류를 나타냄)
    &quot;svcid&quot;: &quot;game&quot;, // 서비스 ID (어떤 서비스에서 발생한 이벤트인지 식별)
    &quot;cid&quot;: &quot;N1UlG6&quot;, // 클라이언트 ID (이벤트가 발생한 클라이언트의 식별자)
    &quot;sid&quot;: &quot;VSZR_D50TQJXWM6J1XzLCGHsQikfVFjakLc6LxC5huenPdGXja4pb9Y0CxvLZwZ17wJkDGqcLsWxoGudv0L0Mg--&quot;, // 세션 ID (사용자 세션을 고유하게 식별하는 ID)
    &quot;retry&quot;: false, // 재시도 여부 (해당 이벤트가 재시도된 것인지 여부)
    &quot;bdy&quot;: { // 본문 데이터 (이벤트의 주요 내용)
        &quot;msg&quot;: &quot;ㅋㅋㅋㅋ&quot;, // 메시지 내용 (사용자가 보낸 텍스트)
        &quot;msgTypeCode&quot;: 1, // 메시지 타입 코드 (메시지 유형을 나타내는 코드)
        &quot;extras&quot;: &quot;{\&quot;chatType\&quot;:\&quot;STREAMING\&quot;,\&quot;osType\&quot;:\&quot;PC\&quot;,\&quot;extraToken\&quot;:\&quot;Cc+YfCOlE4/0odC1UwFeEAfs++s/GzveFyfayz8pWzlbf1d1TKyF9t7bdHSrBwPjnRXlXfCxHlXsjD1TWN3jbQ==\&quot;,\&quot;streamingChannelId\&quot;:\&quot;19e3b97ca1bca954d1ac84cf6862e0dc\&quot;,\&quot;emojis\&quot;:{}}&quot;, // 추가 정보 (JSON 형식으로 포함된 추가 데이터)
        &quot;msgTime&quot;: 1731568963648 // 메시지 타임스탬프 (메시지가 발생한 시간, 밀리초 단위)
    },
    &quot;tid&quot;: 3 // 트랜잭션 ID (이벤트를 구별하기 위한 고유 식별자)
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;채팅-받기&quot;&gt;채팅 받기&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;json
{
  &quot;svcid&quot;: &quot;game&quot;,  // 서비스 ID (예: game, 채팅 서비스 등)
  &quot;ver&quot;: &quot;1&quot;,  // 버전 (서비스의 버전 정보)
  &quot;bdy&quot;: [  // 메시지 본문(body) 배열
    {
      &quot;svcid&quot;: &quot;game&quot;,  // 서비스 ID (예: game)
      &quot;cid&quot;: &quot;N1V4Pr&quot;,  // 채팅 세션 ID 또는 메시지의 고유 ID
      &quot;mbrCnt&quot;: 2109,  // 현재 채팅방에 참여한 사용자 수
      &quot;uid&quot;: &quot;07c7a5dbffe7fb901cceb68a9a731cd1&quot;,  // 사용자 고유 ID
      &quot;profile&quot;: &quot;{  // 사용자 프로필 정보 (JSON 문자열로 저장됨)
        \&quot;userIdHash\&quot;: \&quot;07c7a5dbffe7fb901cceb68a9a731cd1\&quot;,  // 사용자 ID 해시 값
        \&quot;nickname\&quot;: \&quot;USTARD\&quot;,  // 사용자 닉네임
        \&quot;profileImageUrl\&quot;: \&quot;\&quot;,  // 사용자 프로필 이미지 URL (없을 경우 빈 문자열)
        \&quot;userRoleCode\&quot;: \&quot;common_user\&quot;,  // 사용자 역할 코드 (예: common_user, 관리자 등)
        \&quot;badge\&quot;: null,  // 사용자 배지 정보 (없을 경우 null)
        \&quot;title\&quot;: null,  // 사용자 제목 (없을 경우 null)
        \&quot;verifiedMark\&quot;: false,  // 사용자 인증 여부 (false: 인증되지 않음)
        \&quot;activityBadges\&quot;: [],  // 활동 배지 정보 (없을 경우 빈 배열)
        \&quot;streamingProperty\&quot;: {  // 스트리밍 관련 사용자 정보
          \&quot;nicknameColor\&quot;: {  // 닉네임 색상 정보
            \&quot;colorCode\&quot;: \&quot;CC000\&quot;  // 색상 코드
          },
          \&quot;activatedAchievementBadgeIds\&quot;: []  // 활성화된 업적 배지 ID들
        }
      }&quot;,
      &quot;msg&quot;: &quot;잘생겼네&quot;,  // 채팅 메시지 내용
      &quot;msgTypeCode&quot;: 1,  // 메시지 유형 코드 (예: 1은 일반 텍스트 메시지, 다른 값은 다른 유형)
      &quot;msgStatusType&quot;: &quot;NORMAL&quot;,  // 메시지 상태 (예: NORMAL은 일반 메시지, 삭제된 메시지 등)
      &quot;extras&quot;: &quot;{  // 메시지 관련 추가 정보 (JSON 문자열로 저장됨)
        \&quot;chatType\&quot;: \&quot;STREAMING\&quot;,  // 채팅 유형 (예: 스트리밍 채팅)
        \&quot;osType\&quot;: \&quot;PC\&quot;,  // 운영체제 유형 (예: PC, 모바일 등)
        \&quot;extraToken\&quot;: \&quot;HK+d/vpahmIA2m5YJnqtMS/kqPaXti0yEE17mLZGXxyaIy6MzZbzzaf5GJUaavoqq2RSjwfP0d5dp4WgLeAjxg==\&quot;,  // 추가 인증 토큰 또는 데이터
        \&quot;streamingChannelId\&quot;: \&quot;8a59b34b46271960c1bf172bb0fac758\&quot;,  // 스트리밍 채널 ID
        \&quot;emojis\&quot;: {}  // 이모지 정보 (없을 경우 빈 객체)
      }&quot;,
      &quot;ctime&quot;: 1731568455198,  // 메시지 생성 시간 (타임스탬프, 밀리초 단위)
      &quot;utime&quot;: 1731568455198,  // 메시지 마지막 수정 시간 (타임스탬프, 밀리초 단위)
      &quot;msgTid&quot;: null,  // 메시지의 고유 트랜잭션 ID (없을 경우 null)
      &quot;msgTime&quot;: 1731568455198  // 메시지 전송 시간 (타임스탬프, 밀리초 단위)
    }
  ],
  &quot;cmd&quot;: 93101,  // 명령 코드 (예: 메시지 전송 명령)
  &quot;tid&quot;: &quot;38&quot;,  // 트랜잭션 ID (이 메시지가 속한 트랜잭션의 고유 ID)
  &quot;cid&quot;: &quot;N1V4Pr&quot;  // 채팅 세션 ID 또는 메시지의 고유 ID
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;클라이언트가-필요한-데이터&quot;&gt;클라이언트가 필요한 데이터&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;cid : 채팅 세션 ID&lt;/li&gt;
  &lt;li&gt;streamingChannelId: 스트리밍 채널 ID&lt;/li&gt;
  &lt;li&gt;bdy : 메세지 본문
    &lt;ul&gt;
      &lt;li&gt;profile
        &lt;ul&gt;
          &lt;li&gt;uid(userIdHash): 사용자 고유 ID&lt;/li&gt;
          &lt;li&gt;userRoleCode : 어떻게 호스트랑 클라이언트의 채팅을 분별할지 논의 필요&lt;/li&gt;
          &lt;li&gt;nickname : 사용자 닉네임&lt;/li&gt;
          &lt;li&gt;nicknameColor : 사용자 닉네임 색상&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;msgTypeCode: 메세지 타입 (우리의 경우에는 일반, 질문, 공지로?)&lt;/li&gt;
      &lt;li&gt;msgStatusType: 메세지 상태 (질문 채팅의 경우에는 미답변, 답변완료 이렇게?)&lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;ctime&lt;/td&gt;
              &lt;td&gt; &lt;/td&gt;
              &lt;td&gt;msgTime: 메세지 생성 시간 (만약 다시보기에서 채팅 보여주려면 필요)&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;cmd: 명령코드
    &lt;ul&gt;
      &lt;li&gt;지피티 왈. &lt;strong&gt;채팅 시스템에서 흔히 사용되는 다른 cmd 값들&lt;/strong&gt;:
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1001&lt;/code&gt;: 채팅방 입장&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1002&lt;/code&gt;: 채팅방 퇴장&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2001&lt;/code&gt;: 메시지 전송&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2002&lt;/code&gt;: 메시지 삭제&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;클라이언트-설계&quot;&gt;클라이언트 설계&lt;/h2&gt;

&lt;p&gt;채팅 컴포넌트(ChatRoom)에서 소켓 연결을 설정하는 것이 적절하다고 판단.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/boostcampwm2023/web05-AlgoITNi/blob/dev/frontEnd/src/components/room/ChattingSection.tsx#L9&quot;&gt;link_preview&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;활용방식 참고&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;연결될 소켓 url을 구하고 (엔드포인트 + 채널 번호)&lt;/li&gt;
  &lt;li&gt;createSocket으로 클라이언트 소켓 생성&lt;/li&gt;
  &lt;li&gt;Socket.connect&lt;/li&gt;
  &lt;li&gt;emit으로 지정된 cmd 전송 (처음 진입시 JOIN_ROOM과 같은 명령어)&lt;/li&gt;
  &lt;li&gt;컴포넌트 state로 socket set&lt;/li&gt;
  &lt;li&gt;input 컴포넌트에는 socket 객체도 전달&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;전역상태로 socket을 가지게 하면 안되나?&lt;/p&gt;

&lt;p&gt;없거나 에러가 날때만 socket 재생성 및 conect 되도록..&lt;/p&gt;

&lt;p&gt;고려해야할 부분&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;채팅창 닫을시에 chatroom 언마운트가 되면 안됨. 연결은 유지되어야한다.&lt;/li&gt;
  &lt;li&gt;공지가 오면 바로 보여줘야함&lt;/li&gt;
  &lt;li&gt;질문 탭은 어떻게 분리? 걍 클라이언트에서만??
    &lt;ol&gt;
      &lt;li&gt;가져온 메세지 리스트에서 질문 채팅만 필터링하고 거기서 답변미완료 질문을 또 필터링? 과정이 너무 길다&lt;/li&gt;
      &lt;li&gt;차라리 이벤트 분리를 해서 채팅과 질문탭이 따로 관리되도록하면 더 좋을 것 같기도…………..&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;결론 : 이벤트 설계만 잘해두면 생각보다는 덜 어려운듯&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;메인 페이지 스트리밍 띄워주기는 SSE가 가장 낫지않을까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-14-[Socket.io]_클라이언트의_실시간_채팅_구현기.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;암튼 데모는 완료~&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;gominzip&quot;]</name>
        
        
      </author>

      

      

      
        <summary type="html">https://socket.io/docs/v4/tutorial/introduction</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">CI 설정 중 Peer Dependencies 이슈 발생</title>
      <link href="https://blog.liboo.kr/CI_%EC%84%A4%EC%A0%95_%EC%A4%91_Peer_Dependencies_%EC%9D%B4%EC%8A%88_%EB%B0%9C%EC%83%9D" rel="alternate" type="text/html" title="CI 설정 중 Peer Dependencies 이슈 발생" />
      <published>2024-11-12T09:46:00+00:00</published>
      <updated>2024-11-12T09:46:00+00:00</updated>
      <id>https://blog.liboo.kr/CI_%EC%84%A4%EC%A0%95_%EC%A4%91_Peer_Dependencies_%EC%9D%B4%EC%8A%88_%EB%B0%9C%EC%83%9D</id>
      <content type="html" xml:base="https://blog.liboo.kr/CI_%EC%84%A4%EC%A0%95_%EC%A4%91_Peer_Dependencies_%EC%9D%B4%EC%8A%88_%EB%B0%9C%EC%83%9D">&lt;h2 id=&quot;문제-상황&quot;&gt;문제 상황&lt;/h2&gt;

&lt;p&gt;ci를 위한 스크립트 작성중 lint에 대한 의존성 충돌 이슈가 발생 했다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
Oops! Something went wrong! :(

ESLint: 9.14.0

Error: @typescript-eslint/utils tried to access eslint (a peer dependency) but it isn&apos;t provided by its ancestors; this makes the require call ambiguous and unsound.

Required package: eslint (via &quot;eslint/use-at-your-own-risk&quot;)
Required by: @typescript-...

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;원인&quot;&gt;원인&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://velog.io/@hoon0123/peerdependency-%EB%B0%95%EC%82%B4%EB%82%9C%EA%B1%B0-%ED%95%B4%EA%B2%B0%ED%95%B4%EC%95%BC%ED%95%B4&quot;&gt;https://velog.io/@hoon0123/peerdependency-%EB%B0%95%EC%82%B4%EB%82%9C%EA%B1%B0-%ED%95%B4%EA%B2%B0%ED%95%B4%EC%95%BC%ED%95%B4&lt;/a&gt; ← 참고 블로그&lt;/p&gt;

&lt;p&gt;해당 오류는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@typescript-eslint/utils&lt;/code&gt; 패키지가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eslint&lt;/code&gt;를 &lt;strong&gt;peer dependency&lt;/strong&gt;로 요구하지만, 해당 의존성이 yarn의 의존성 트리에서 제대로 제공되지 않는 경우에 발생한다.&lt;/p&gt;

&lt;h3 id=&quot;peer-dependency란&quot;&gt;Peer dependency란?&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://mitchell-up.github.io/mitchell-dictionary/docs/terms/peer-dependency/&quot;&gt;https://mitchell-up.github.io/mitchell-dictionary/docs/terms/peer-dependency/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;일반적인 dependency는 패키지 자체에 필요한 모듈을 의미하며, 해당 패키지를 설치할 때 함께 설치된다.&lt;/p&gt;

&lt;p&gt;peer dependency란 라이브러리나 플러그인에서 사용하는 패키지 중에서 라이브러리를 사용하는 &lt;strong&gt;사용자가 직접 설치해야 하는 패키지&lt;/strong&gt;를 의미한다.&lt;/p&gt;

&lt;p&gt;예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eslint-plugin-react&lt;/code&gt;는 React와 관련된 ESLint 규칙을 제공합니다. 이 플러그인은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eslint&lt;/code&gt;와 함께 사용해야 하므로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eslint&lt;/code&gt;를 peer dependency로 지정해주어야 한다.&lt;/p&gt;

&lt;h2 id=&quot;문제-해결-과정&quot;&gt;문제 해결 과정&lt;/h2&gt;

&lt;p&gt;문제 목록을 확인하기 위해선 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yarn explain peer-requirements&lt;/code&gt; 명령어로 확인해 볼 수 있다.&lt;/p&gt;

&lt;p&gt;문제가 발생한 라이브러리와 제공되지 않은 라이브러리를 확인해볼 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
→ ✘ @typescript-eslint/utils@npm:8.14.0 [60205] doesn&apos;t provide typescript to @typescript-eslint/typescript-estree@npm:8.14.0 [55f0c] and 1 other dependency

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;⇒ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@typescript-eslint/utils@npm:8.14.0&lt;/code&gt; 패키지가 하위 의존성들에게 typescript를 요구받고 있으나 제공을 못하고 있음&lt;/p&gt;

&lt;p&gt;.yarnrc.yml 파일의 packageExtensions에 문제가 발생하는 패키지별 peerDependencies를 추가해주면 된다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yaml
yarnPath: .yarn/releases/yarn-4.5.1.cjs
nodeLinker: pnp

packageExtensions:
  &apos;@typescript-eslint/utils@*&apos;:
    peerDependencies:
      eslint: &apos;*&apos;
      typescript: &apos;*&apos;
  &apos;@typescript-eslint/type-utils@*&apos;:
    peerDependencies:
      eslint: &apos;*&apos;
      typescript: &apos;*&apos;
  &apos;typescript-eslint@*&apos;:
    peerDependencies:
      eslint: &apos;*&apos;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;왜-의존성에-있음에도-설정을-해줘야했을까&quot;&gt;왜 의존성에 있음에도 설정을 해줘야했을까?&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;packageExtensions&lt;/strong&gt;는 Yarn에서 PnP 방식으로 의존성을 관리할 때, &lt;strong&gt;특정 패키지에 누락된 의존성을 추가하거나 의존성 해결 방식을 조정&lt;/strong&gt;하는 기능을 제공한다.&lt;/p&gt;

&lt;p&gt;이 설정은 주로 peerDependency로 명시된 의존성이 &lt;strong&gt;실제로 존재하지 않거나 잘못 설정된 경우&lt;/strong&gt;, 해당 의존성을 수동으로 추가해야 할 때 사용한다.&lt;/p&gt;

&lt;p&gt;즉, &lt;strong&gt;Yarn PnP&lt;/strong&gt;에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eslint&lt;/code&gt;가 의존성에 포함되어 있어도, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eslint&lt;/code&gt;를 &lt;strong&gt;명시적으로&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;peerDependency&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;로 추가&lt;/strong&gt;해야 &lt;strong&gt;해당 패키지가 제대로 작동&lt;/strong&gt;할 수 있다. 이는 Yarn PnP의 의존성 해결 방식이 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node_modules&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;방식과 다르기 때문에 발생하는 현상이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;따라서, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eslint&lt;/code&gt;가 의존성에 존재하더라도 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;peerDependency&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;로 명시해주지 않으면&lt;/strong&gt;, Yarn PnP 시스템에서 해당 의존성을 제대로 해결하지 못할 수 있다..&lt;/p&gt;

&lt;p&gt;의존성 문제가 복잡하여 특히 현재와 같은 모노레포에서 어떤 방식으로 패키지를 관리하는 것이 좋을지 고민이 깊어지는 것 같다&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;gominzip&quot;]</name>
        
        
      </author>

      

      

      
        <summary type="html">문제 상황</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">웹 소켓의 실시간 양방향 통신 (feat. WS vs Socket.io)</title>
      <link href="https://blog.liboo.kr/%EC%9B%B9_%EC%86%8C%EC%BC%93%EC%9D%98_%EC%8B%A4%EC%8B%9C%EA%B0%84_%EC%96%91%EB%B0%A9%ED%96%A5_%ED%86%B5%EC%8B%A0_(feat._WS_vs_Socket.io)" rel="alternate" type="text/html" title="웹 소켓의 실시간 양방향 통신 (feat. WS vs Socket.io)" />
      <published>2024-11-11T01:25:00+00:00</published>
      <updated>2024-11-11T01:25:00+00:00</updated>
      <id>https://blog.liboo.kr/%EC%9B%B9_%EC%86%8C%EC%BC%93%EC%9D%98_%EC%8B%A4%EC%8B%9C%EA%B0%84_%EC%96%91%EB%B0%A9%ED%96%A5_%ED%86%B5%EC%8B%A0_(feat._WS_vs_Socket.io)</id>
      <content type="html" xml:base="https://blog.liboo.kr/%EC%9B%B9_%EC%86%8C%EC%BC%93%EC%9D%98_%EC%8B%A4%EC%8B%9C%EA%B0%84_%EC%96%91%EB%B0%A9%ED%96%A5_%ED%86%B5%EC%8B%A0_(feat._WS_vs_Socket.io)">&lt;blockquote&gt;
  &lt;p&gt;목차&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;📌 과거 발표자료를 토대로 정리했습니다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;학습-이유&quot;&gt;🤔 학습 이유&lt;/h2&gt;

&lt;p&gt;과거 웹소켓 관련 컨퍼런스 발표까지 해보았지만 실제 프로젝트에서 써보지 않아 휘발되었다…ㅜㅜ&lt;/p&gt;

&lt;p&gt;이번 기회에 실시간 &amp;amp; 양방향 통신을 위한 기술들을 조사해보고 어떤 방식으로 우리 서비스의 실시간 채팅 기능을 구현해 볼 지 고민해보고자 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;HTTP 통신은 클라이언트의 요청이 있을 때 서버가 응답하는 &lt;strong&gt;단방향 통신&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-11-웹_소켓의_실시간_양방향_통신_(feat._WS_vs_Socket.io).md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;HTTP 통신&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;그럼 실시간 채팅처럼 양방향이면서 실시간 통신이 필요한 기능 구현은 어떻게 할까? 우선 실시간 통신을 위한 몇가지 통신 방식을 알아보자&lt;/p&gt;

&lt;h1 id=&quot;실시간-통신을-위한-노력&quot;&gt;🚀 실시간 통신을 위한 노력&lt;/h1&gt;

&lt;h2 id=&quot;ajax-polling&quot;&gt;AJAX Polling&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-11-웹_소켓의_실시간_양방향_통신_(feat._WS_vs_Socket.io).md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;클라이언트가 일정한 주기로 서버에 새로운 업데이트가 없는지 확인하는 HTTP 요청을 보내는 방법&lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;구현이 간단하며 대부분의 브라우저에서 지원&lt;/li&gt;
      &lt;li&gt;기존 HTTP 인프라를 그대로 사용 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;불필요한 요청과 커넥션을 생성하여 서버의 부담이 커짐&lt;/li&gt;
      &lt;li&gt;Real-time 통신이라고 부르기 애매할 정도의 실시간성&lt;/li&gt;
      &lt;li&gt;데이터 업데이트 지연 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용 사례
    &lt;ul&gt;
      &lt;li&gt;응답을 실시간으로 받지 않아도 되는 경우&lt;/li&gt;
      &lt;li&gt;다수의 사용자가 동시에 사용하는 경우에 적합&lt;/li&gt;
      &lt;li&gt;ex. 뉴스 피드, 공지사항 업데이트&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
setInterval(() =&amp;gt; {
  fetch(&apos;/api/data&apos;)
    .then(response =&amp;gt; response.json())
    .then(data =&amp;gt; {
      console.log(&apos;받은 데이터:&apos;, data);
    })
    .catch(error =&amp;gt; console.error(&apos;오류:&apos;, error));
}, 5000); 

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;long-polling&quot;&gt;Long Polling&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-11-웹_소켓의_실시간_양방향_통신_(feat._WS_vs_Socket.io).md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;클라이언트가 서버에 요청을 보내고 서버에서 변경이 일어날 때까지 응답을 지연시키는 방식
⇒ 데이터가 준비되면 서버가 응답을 보내고, 클라이언트는 즉시 새로운 요청을 보내는 방식으로 지속적인 데이터 수신 구현&lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;불필요한 요청 감소, 지속적으로 요청을 보내는 폴링보다 부담이 덜 한 방식&lt;/li&gt;
      &lt;li&gt;실시간성 향상, 클라이언트가 새로운 데이터 즉시 받음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;커넥션의 유지시간을 짧게 갖는다면 폴링과 차이점 x&lt;/li&gt;
      &lt;li&gt;지속적으로 연결되어 있기 때문에 다수의 클라이언트에게 동시에
  이벤트가 발생하면 순간적 부담이 급증&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용 사례
    &lt;ul&gt;
      &lt;li&gt;실시간 전달이 중요한데 상태가 빈번하게 갱신되진 않을 때 적합&lt;/li&gt;
      &lt;li&gt;채팅, 실시간 알림시스템, 실시간 업데이트가 필요한 협업 도구&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
// 클라이언트 측 Long Polling 예시
function longPoll() {
  fetch(&apos;/api/long-poll&apos;)
    .then(response =&amp;gt; response.json())
    .then(data =&amp;gt; {
      console.log(&apos;받은 데이터:&apos;, data);
      // 데이터 처리 로직
      longPoll(); // 재귀 호출로 지속적인 폴링
    })
    .catch(error =&amp;gt; {
      console.error(&apos;오류:&apos;, error);
      setTimeout(longPoll, 5000); // 오류 발생 시 재시도
    });
}

longPoll(); // 초기 호출

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
//클라이언트 요청 저장
let clients = [];
let messages = [];

app.get(&apos;/api/long-poll&apos;, (req, res) =&amp;gt; {
  // 클라이언트가 요청을 보낼 때 콜백을 저장
  clients.push(res);

  // 클라이언트 연결이 끊어지면 콜백 제거
  req.on(&apos;close&apos;, () =&amp;gt; {
    clients = clients.filter(client =&amp;gt; client !== res);
  });
});

// 새로운 메시지가 도착했을 때 모든 클라이언트에게 전송
function broadcastMessage(message) {
  messages.push(message); // 메시지를 저장할 수도 있음.
  clients.forEach(client =&amp;gt; client.json(message));
  clients = []; // 모든 클라이언트 응답을 보낸 후 클라이언트 리스트 초기화
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;http-streaming&quot;&gt;HTTP Streaming&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-11-웹_소켓의_실시간_양방향_통신_(feat._WS_vs_Socket.io).md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-11-11&lt;/em&gt;%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.37.58.png_&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이벤트가 발생했을 때 응답을 내려주되, 응답을 완료시키지 않고 계속 연결을 유지하는 방식&lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;롱폴링에 비해 응답마다 다시 요청을 하지 않아도 되므로 효율적&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;연결시간이 길어질수록 연결 유효성 관리 부담 증가&lt;/li&gt;
      &lt;li&gt;클라이언트에서 서버로의 데이터 송신이 어려움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;server-sent-events-sse&quot;&gt;Server-Sent Events (SSE)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-11-웹_소켓의_실시간_양방향_통신_(feat._WS_vs_Socket.io).md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;서버와 클라이언트가 첫 연결에 성공하면, 서버는 이벤트 발생 주기별로 클라이언트에게 필요한 데이터를 자동전송&lt;/li&gt;
  &lt;li&gt;클라이언트에서 서버로 데이터를 보내는 것은 불가능 (단방향)&lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;구현이 비교적 간단하고 효율적임&lt;/li&gt;
      &lt;li&gt;자동 재연결 기능 제공&lt;/li&gt;
      &lt;li&gt;텍스트 기반 데이터 전송에 최적화됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;단방향 통신만 가능함&lt;/li&gt;
      &lt;li&gt;과거 브라우저에서 지원되지 않을 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용 사례
    &lt;ul&gt;
      &lt;li&gt;클라이언트 요청 필요 없이 서버가 독자적으로 응답을 날리는 연결 형태&lt;/li&gt;
      &lt;li&gt;실시간 뉴스 피드, 실시간 주식 시세 업데이트, 실시간 스포츠 경기 점수 업데이트&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sse-처리-흐름-루카스-참고&quot;&gt;SSE 처리 흐름 (루카스 참고)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;클라이언트에서 서버로 연결 요청&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;클라이언트는&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventSource&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;객체를 생성해&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/sse&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;경로로&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GET&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;요청을 보냄.&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;이 요청을 통해 데이터를 지속적으로 수신할 준비를 함.&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클라이언트는 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventSource&lt;/code&gt;&lt;/strong&gt; 객체를 생성해 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/sse&lt;/code&gt;&lt;/strong&gt; 경로로 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GET&lt;/code&gt;&lt;/strong&gt; 요청을 보냄.&lt;/li&gt;
  &lt;li&gt;이 요청을 통해 데이터를 지속적으로 수신할 준비를 함.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;서버에서 연결을 유지하고 스트리밍 응답 시작&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;서버는 클라이언트의 요청에 대해&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Type: text/event-stream&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;헤더를 설정하고 응답을 유지함.&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;이 상태에서 서버는 데이터를 계속해서 클라이언트로 푸시할 수 있음.&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서버는 클라이언트의 요청에 대해 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Type: text/event-stream&lt;/code&gt;&lt;/strong&gt; 헤더를 설정하고 응답을 유지함.&lt;/li&gt;
  &lt;li&gt;이 상태에서 서버는 데이터를 계속해서 클라이언트로 푸시할 수 있음.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;서버가 주기적으로 데이터를 전송&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;서버는 특정 이벤트나 일정 시간 간격에 따라 데이터를&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;res.write()&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;메서드를 사용해 클라이언트로 전송함.&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;각 메시지는&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data:&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;로 시작하고 두 개의 개행 문자(&lt;/strong&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\n\n&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;)로 끝내야 하며, 이를 통해 클라이언트는 메시지의 끝을 구분할 수 있음.&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서버는 특정 이벤트나 일정 시간 간격에 따라 데이터를 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;res.write()&lt;/code&gt;&lt;/strong&gt; 메서드를 사용해 클라이언트로 전송함.&lt;/li&gt;
  &lt;li&gt;각 메시지는 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data:&lt;/code&gt;&lt;/strong&gt;로 시작하고 두 개의 개행 문자(&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\n\n&lt;/code&gt;&lt;/strong&gt;)로 끝내야 하며, 이를 통해 클라이언트는 메시지의 끝을 구분할 수 있음.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;클라이언트에서 실시간으로 데이터 수신&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;클라이언트는&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onmessage&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;이벤트 핸들러를 통해 서버에서 전송된 데이터를 실시간으로 수신하고 처리할 수 있음.&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클라이언트는 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onmessage&lt;/code&gt;&lt;/strong&gt; 이벤트 핸들러를 통해 서버에서 전송된 데이터를 실시간으로 수신하고 처리할 수 있음.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
// 클라이언트 측 SSE 연결 시작
const eventSource = new EventSource(&apos;/sse&apos;);

eventSource.onmessage = (event) =&amp;gt; {
  console.log(&apos;받은 데이터:&apos;, event.data); //서버에서 전송된 데이터 수신 및 처리
};

eventSource.onerror = (error) =&amp;gt; {
  console.error(&apos;SSE 오류:&apos;, error); // 오류 발생 시 처리
};

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
const express = require(&apos;express&apos;);
const app = express();

app.get(&apos;/sse&apos;, (req, res) =&amp;gt; {
  // SSE 응답 헤더 설정
  res.setHeader(&apos;Content-Type&apos;, &apos;text/event-stream&apos;);
  res.setHeader(&apos;Cache-Control&apos;, &apos;no-cache&apos;);
  res.setHeader(&apos;Connection&apos;, &apos;keep-alive&apos;);

  // 클라에게 응답
  const sendMessage = () =&amp;gt; {
    const data = `서버 시간: ${new Date().toLocaleTimeString()}`;
    res.write(`data: ${data}\n\n`); // 클라이언트로 데이터 전송
  };

  // 5초마다 메시지 전송
  const intervalId = setInterval(sendMessage, 5000);

  // 클라이언트가 연결을 닫으면 interval 중단
  req.on(&apos;close&apos;, () =&amp;gt; {
    clearInterval(intervalId);
  });
});


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;⇒ 결과적으로 위 모든 방법이 HTTP를 통해 통신하기 때문에 Request, Response 둘 다 Header가 불필요하게 큼&lt;/p&gt;

&lt;h1 id=&quot;websocket-웹-소켓&quot;&gt;🌐 WebSocket 웹 소켓&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;W3C와 IETF에 의해 자리잡은 표준 프로토콜 중 하나&lt;/li&gt;
  &lt;li&gt;HTML5 표준 기술로, 사용자의 브라우저와 서버 사이의 동적인 양방향 연결 채널을 구성&lt;/li&gt;
  &lt;li&gt;Websocket API를 통해 서버로 메세지를 보내고, 요청 없이 응답을 받아오는 것이 가능!
    &lt;ul&gt;
      &lt;li&gt;TCP프로토콜을 기반으로 작동하며, 데이터가 순서대로 전송되도록 하고 오류가 발생할 경우 자동으로 복구.&lt;/li&gt;
      &lt;li&gt;HTTP 핸드셰이크로 연결을 시작한 후 TCP 소켓을 통해 양방향 데이터 전송을 지속함.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;양방향 통신 &amp;amp; 실시간 네트워킹&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;웹-소켓의-동작-과정&quot;&gt;웹 소켓의 동작 과정&lt;/h2&gt;

&lt;p&gt;Request와 Response의 구체적인 내용에 대해서는 첨부하지 않았다..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=MPQHvwPxDUw&quot;&gt;https://www.youtube.com/watch?v=MPQHvwPxDUw&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;위 영상을 토대로 공부했다!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-11-웹_소켓의_실시간_양방향_통신_(feat._WS_vs_Socket.io).md/5.png&quot; alt=&quot;5&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-11-웹_소켓의_실시간_양방향_통신_(feat._WS_vs_Socket.io).md/6.png&quot; alt=&quot;6&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-11-웹_소켓의_실시간_양방향_통신_(feat._WS_vs_Socket.io).md/7.png&quot; alt=&quot;7&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
// 클라이언트 측 WebSocket 예시
const socket = new WebSocket(&apos;ws://localhost:8080&apos;);

socket.onopen = () =&amp;gt; {
  console.log(&apos;WebSocket 연결 성공&apos;);
  socket.send(&apos;서버야 이거 받아볼래?&apos;);
};

socket.onmessage = (event) =&amp;gt; {
  console.log(&apos;서버로부터 메시지:&apos;, event.data);
  // 메시지 처리 로직
};

socket.onerror = (error) =&amp;gt; {
  console.error(&apos;WebSocket 오류:&apos;, error);
};

socket.onclose = () =&amp;gt; {
  console.log(&apos;WebSocket 연결 종료&apos;);
};

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;ws-모듈-vs-socketio&quot;&gt;👀 WS 모듈 vs Socket.io&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.peterkimzz.com/websocket-vs-socket-io&quot;&gt;https://www.peterkimzz.com/websocket-vs-socket-io&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ws&lt;/code&gt; 모듈과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Socket.io&lt;/code&gt;는 둘 다 실시간 양방향 통신을 가능하게 하는 Node.js 기반의 라이브러리이지만, 기능과 사용 편의성 측면에서 차이가 있음&lt;/p&gt;

&lt;h2 id=&quot;ws-모듈&quot;&gt;WS 모듈&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;웹소켓 표준 구현&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ws&lt;/code&gt;는 기본적인 웹소켓 프로토콜에 대한 가벼운 구현입니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;최소한의 종속성&lt;/strong&gt;: 다른 라이브러리에 비해 종속성이 적고, 성능에 초점을 맞춘 경량 라이브러리입니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;자유도&lt;/strong&gt;: 개발자가 더 세부적인 부분을 제어할 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;성능&lt;/strong&gt;: 단순하고 가벼운 구조로 인해 성능이 좋습니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;유연성&lt;/strong&gt;: 개발자가 직접 다양한 기능을 구현할 수 있어 커스터마이징에 유리합니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;표준 준수&lt;/strong&gt;: 웹소켓 표준 프로토콜을 직접 구현하므로, 다른 웹소켓 클라이언트와 호환이 잘 됩니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;저수준 인터페이스&lt;/strong&gt;: 사용이 비교적 복잡하며, 연결 관리, 재시도, 브로드캐스팅 같은 기능을 직접 구현해야 합니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;부가 기능 부족&lt;/strong&gt;: 자동 재연결, 룸 기능, 이벤트 기반 구조 같은 고급 기능이 없습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;socketio&quot;&gt;Socket.io&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;웹소켓 + 폴백&lt;/strong&gt;: 기본적으로 웹소켓을 사용하지만, 웹소켓을 지원하지 않는 환경에서는 폴링(polling)으로 폴백(fallback)합니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;추가 기능 제공&lt;/strong&gt;: 이벤트 기반 통신, 자동 재연결, 브로드캐스트, 네임스페이스 및 룸 기능을 제공합니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;클라이언트 라이브러리 필요&lt;/strong&gt;: 클라이언트에서도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Socket.io&lt;/code&gt; 라이브러리가 필요합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;편리성&lt;/strong&gt;: 복잡한 설정 없이 간단하게 사용할 수 있습니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;풍부한 기능&lt;/strong&gt;: 자동 재연결, 브로드캐스트, 룸 기능 등 실시간 애플리케이션 구축에 필요한 다양한 기능을 내장하고 있습니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;다양한 폴백 지원&lt;/strong&gt;: 웹소켓을 사용할 수 없는 환경에서도 폴백을 통해 통신이 가능합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;추가적인 오버헤드&lt;/strong&gt;: 여러 기능이 내장되어 있어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ws&lt;/code&gt; 모듈보다 무겁습니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;표준과 다름&lt;/strong&gt;: 표준 웹소켓과 100% 호환되지 않을 수 있어 특정 상황에서는 제한이 있을 수 있습니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;클라이언트 라이브러리 의존성&lt;/strong&gt;: 서버와 클라이언트가 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Socket.io&lt;/code&gt;를 사용해야 하므로, 웹소켓 클라이언트와의 호환성 문제가 생길 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;주요-차이점-정리&quot;&gt;&lt;strong&gt;주요 차이점 정리&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;단순함 vs. 편리함&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ws&lt;/code&gt;는 경량으로 단순한 웹소켓 구현에 유리하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Socket.io&lt;/code&gt;는 다양한 기능과 편리성을 제공합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;표준 준수 vs. 기능 확장성&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ws&lt;/code&gt;는 웹소켓 표준을 따르고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Socket.io&lt;/code&gt;는 추가 기능을 위해 표준을 약간 벗어날 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;커스터마이징&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ws&lt;/code&gt;는 모든 것을 개발자가 직접 구성할 수 있으며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Socket.io&lt;/code&gt;는 다양한 기능이 이미 구현되어 있어 개발 시간을 단축할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;추천-시나리오&quot;&gt;&lt;strong&gt;추천 시나리오&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ws&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;사용&lt;/strong&gt;: 최대 성능이 필요하거나, 단순한 실시간 통신 기능만 필요한 경우.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Socket.io&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;사용&lt;/strong&gt;: 빠르게 개발해야 하거나, 자동 재연결 및 룸 기능 같은 고급 기능이 필요한 경우.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 차이를 이해하면 프로젝트 요구 사항에 맞는 적절한 라이브러리를 선택할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;⇒ 생산성을 고려해서 브로드캐스트, 네임스페이스, 자동 재연결이 구현되어있는 socket.io가 우리 서비스에 더 적절할 것이라고 생각됨&lt;/strong&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;gominzip&quot;]</name>
        
        
      </author>

      

      

      
        <summary type="html">목차</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">[docker] 인프라 감자의 Docker 튜토리얼</title>
      <link href="https://blog.liboo.kr/docker-_%EC%9D%B8%ED%94%84%EB%9D%BC_%EA%B0%90%EC%9E%90%EC%9D%98_Docker_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC" rel="alternate" type="text/html" title="[docker] 인프라 감자의 Docker 튜토리얼" />
      <published>2024-11-09T06:37:00+00:00</published>
      <updated>2024-11-09T06:37:00+00:00</updated>
      <id>https://blog.liboo.kr/%5Bdocker%5D_%EC%9D%B8%ED%94%84%EB%9D%BC_%EA%B0%90%EC%9E%90%EC%9D%98_Docker_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC</id>
      <content type="html" xml:base="https://blog.liboo.kr/docker-_%EC%9D%B8%ED%94%84%EB%9D%BC_%EA%B0%90%EC%9E%90%EC%9D%98_Docker_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC">&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;목차&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;학습-이유&quot;&gt;🤔 학습 이유&lt;/h2&gt;

&lt;p&gt;모노레포로 프로젝트를 진행하면서 프론트/백의 통합 CICD 파이프라인을 구축하기 위한 도커 도입이 논의되었으나… 감자인 이슈로 해당 과정을 제대로 이해하지 못했음&lt;/p&gt;

&lt;h2 id=&quot;️들어가기-전-간단-개념-정리&quot;&gt;✔️ 들어가기 전 간단 개념 정리&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=eRfHp16qJq8&amp;amp;t=344s&quot;&gt;https://www.youtube.com/watch?v=eRfHp16qJq8&amp;amp;t=344s&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;컨테이너 = 서버&lt;/p&gt;

&lt;p&gt;하나의 서버에서는 하나의 소프트웨어만 실행하는 것이 안정적 → but 리소스 낭비 따라서 &lt;u&gt;가상화 기술을 사용해&lt;/u&gt; 하나의 컴퓨터에서 여러개의 소프트웨어를 실행시킴&lt;/p&gt;

&lt;p&gt;ex) 하나의 서버에서 소프트웨어를 실행시키는 것은 건물 한층을 한명에게만 임대해주는것.
따라서 임시로 가벽을 세우고 여러명이 쓸 수 있도록. = 서버를 가상화기술로 분리하고 여러 소프트웨어가 실행되도록&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;가상화 방식
    &lt;ul&gt;
      &lt;li&gt;전통적으로 &lt;strong&gt;가상머신 Virtual Machine&lt;/strong&gt;을 사용
  → 프로그램을 실행하고 업그레이드하는데 시간이 오래 걸림&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;컨테이너 Container&lt;/strong&gt; : 한대의 서버에서 여러개의 프로그램을 안정적으로 사용가능. 이전의 가상화 기술보다 가볍고 빠르다.&lt;/p&gt;

        &lt;p&gt;⇒ Why? 가벽을 설치하고 임대인이 바뀔 때마다 공사를 다시하는 것이 아닌 임대인이 살 수 있는 컨테이너를 만들어놓고 입주 시에 컨테이너를 그대로 집어넣는 방식&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컨테이너를 직접 만드는 것은 비효율적. 도커는 컨테이너를 관리하는 프로그램. 도커에게 컨테이너를 만들라고 하면 됨.&lt;/li&gt;
  &lt;li&gt;3개의 건물이 생김. 도커도 3개 → 연락이 너무 많이 옴 ⇒ 매니저로 &lt;strong&gt;쿠버네티스&lt;/strong&gt; 고용. 컨테이너 오케스트레이션 도구. 오케스트라 지휘자처럼 도커에게 지휘.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 &lt;strong&gt;요약&lt;/strong&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;strong&gt;컨테이너&lt;/strong&gt;를 사용하면 한 대의 서버에서 여러 개의 소프트웨어를 안전하고 효율적으로 운영할 수 있다.&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;strong&gt;도커&lt;/strong&gt;는 컨테이너를 관리하기 위한 도구로 일종의 프로그램이다&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;strong&gt;쿠버네티스&lt;/strong&gt;는 서버가 여러 대 있는 환경에서 각각의 서버의 도커에게 대신 지시해주는 오케스트레이션 도구이다.&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- **컨테이너**를 사용하면 한 대의 서버에서 여러 개의 소프트웨어를 안전하고 효율적으로 운영할 수 있다.
- **도커**는 컨테이너를 관리하기 위한 도구로 일종의 프로그램이다
- **쿠버네티스**는 서버가 여러 대 있는 환경에서 각각의 서버의 도커에게 대신 지시해주는 오케스트레이션 도구이다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;가상화-기술-vm-vs-docker&quot;&gt;💻 가상화 기술 VM vs Docker&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=LXJhA3VWXFA&quot;&gt;https://www.youtube.com/watch?v=LXJhA3VWXFA&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;1-vm가상-머신의-구조&quot;&gt;1. &lt;strong&gt;VM(가상 머신)의 구조&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;독립된 OS 포함&lt;/strong&gt;: 각 VM은 자체적인 &lt;strong&gt;게스트 OS&lt;/strong&gt;를 가지고 실행됩니다. VM은 하이퍼바이저(예: VMware, Hyper-V) 위에서 구동되며, 하이퍼바이저는 물리적 하드웨어를 가상화하여 각 VM에 할당합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;하드웨어 가상화&lt;/strong&gt;: VM은 CPU, 메모리, 스토리지 등을 포함하여 하드웨어 리소스를 완전히 가상화합니다. 이를 통해 &lt;strong&gt;각 VM이 마치 독립적인 컴퓨터처럼 동작&lt;/strong&gt;하게 됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;왜 무거운가?&lt;/strong&gt;: 각 VM은 자체 OS를 포함하고 부팅해야 하며, 하드웨어 수준에서의 격리로 인해 많은 리소스를 소모합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-컨테이너의-구조&quot;&gt;2. &lt;strong&gt;컨테이너의 구조&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;커널 공유&lt;/strong&gt;: 컨테이너는 호스트 OS의 &lt;strong&gt;커널&lt;/strong&gt;을 공유합니다. 즉, 컨테이너는 별도의 커널을 포함하지 않고, 실행에 필요한 사용자 공간만을 포함합니다. 예를 들어, 필요한 라이브러리나 애플리케이션 코드만 포함됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;컨테이너 엔진&lt;/strong&gt;: Docker와 같은 컨테이너 엔진은 컨테이너를 실행하고 관리하며, 각 컨테이너는 호스트 OS의 커널을 사용하는 가벼운 프로세스 집합으로 작동합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;왜 가벼운가?&lt;/strong&gt;: 커널 수준에서의 격리만으로 애플리케이션의 독립성을 보장하기 때문에 추가 OS 부팅이 필요하지 않아 리소스 소모가 훨씬 적습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-커널의-역할&quot;&gt;3. &lt;strong&gt;커널의 역할&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;커널&lt;/strong&gt;은 OS의 핵심 컴포넌트로, 하드웨어와 소프트웨어 간의 중재 역할을 합니다. VM은 각각 독립된 커널을 가상화된 OS에 포함하고 있어야 하지만, 컨테이너는 호스트 OS의 커널을 공유하여 사용합니다. 이는 커널이 하드웨어 리소스를 다루는 중요한 역할을 하기 때문입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;⇒ 즉 컨테이너의 경량성과 성능 효율은 바로 이 &lt;strong&gt;커널 공유&lt;/strong&gt; 메커니즘 덕분&lt;/p&gt;

&lt;h2 id=&quot;어떻게-호스트-os-커널-공유가-가능할까-안전할까&quot;&gt;어떻게 호스트 OS 커널 공유가 가능할까? 안전할까?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.inflearn.com/community/questions/1196236/%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%9D%98-%EC%BB%A4%EB%84%90-%EA%B3%B5%EC%9C%A0%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%98%EB%AC%B8%EC%A0%90?srsltid=AfmBOopmw2RLuT4EqO4XtKl0SuDGqEuKPRJFCZfkicqq4vdpkiUpKcDE&quot;&gt;https://www.inflearn.com/community/questions/1196236/%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%9D%98-%EC%BB%A4%EB%84%90-%EA%B3%B5%EC%9C%A0%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%98%EB%AC%B8%EC%A0%90?srsltid=AfmBOopmw2RLuT4EqO4XtKl0SuDGqEuKPRJFCZfkicqq4vdpkiUpKcDE&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;리눅스 커널의 특성 덕분입니다. 리눅스 커널은 프로세스 간의 격리를 위해 &lt;strong&gt;네임스페이스(namespaces)&lt;/strong&gt;와 &lt;strong&gt;컨트롤 그룹(cgroups)&lt;/strong&gt; 같은 기술을 제공합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;네임스페이스&lt;/strong&gt;: 각 컨테이너는 네임스페이스를 통해 다른 컨테이너 및 호스트 시스템과 격리됩니다. 네임스페이스는 프로세스 ID, 네트워크, 마운트 포인트, 사용자 ID 등 시스템 리소스의 독립적인 뷰를 제공합니다. 예를 들어, 네트워크 네임스페이스는 컨테이너 간의 네트워크 트래픽을 분리해 줍니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;컨트롤 그룹(cgroups)&lt;/strong&gt;: cgroups는 컨테이너가 사용하는 CPU, 메모리, 디스크 I/O와 같은 리소스를 제한하고 관리합니다. 이를 통해 하나의 컨테이너가 리소스를 과도하게 사용해 호스트나 다른 컨테이너에 영향을 미치지 않도록 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;→ 커널 레벨에서 발생할 수 있는 문제가 다른 컨테이너에 영향을 줄 수 있는 단점도 있지만 컨테이너 자체의 보안 기능(seccomp, AppArmor 등)과 쿠버네티스와 같은 오케스트레이션 툴을 통해 멀티 텐트 환경에서도 충분한 격리와 관리가 가능하도록 설계 가능&lt;/p&gt;

&lt;p&gt;아직 운영체제를 안 들어서 딥다이브하지 못해 아쉽..&lt;/p&gt;

&lt;h1 id=&quot;docker&quot;&gt;🐳 Docker&lt;/h1&gt;

&lt;p&gt;Go언어로 작성된 리눅스 컨테이너 기반으로 하는 어플리케이션을 &lt;strong&gt;패키징&lt;/strong&gt; 할 수 있는 툴. 오픈소스 가상화 플랫폼&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;컨테이너라는 작은 소프트웨어 유닛 안에 어플리케이션, 시스템 툴, 디펜던시를 하나로 묶어서 다른 서버 등 쉽게 배포하고 구동 할 수 있게 함.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;building-containers&quot;&gt;Building Containers&lt;/h2&gt;

&lt;h3 id=&quot;dockerfile&quot;&gt;Dockerfile&lt;/h3&gt;

&lt;p&gt;컨테이너를 어떻게 만들어야 한다는 레시피&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Copy file&lt;/li&gt;
  &lt;li&gt;Install dependencies&lt;/li&gt;
  &lt;li&gt;Set environment variables&lt;/li&gt;
  &lt;li&gt;Run setup scripts&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;image&quot;&gt;Image&lt;/h3&gt;

&lt;p&gt;Dockerfile을 기반으로 생성.&lt;/p&gt;

&lt;p&gt;어플리케이션 실행에 필요한 코드, 런타임 환경, 시스템 툴, 시스템 라이브러리 등의 세팅을 포함시킴 ⇒ 현재 어플리케이션의 상태를 스냅샷으로 저장한 형태.&lt;/p&gt;

&lt;p&gt;만들어진 이미지는 &lt;strong&gt;불변함.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;container&quot;&gt;Container&lt;/h3&gt;

&lt;p&gt;샌드박스처럼 우리가 캡처해둔 어플리케이션의 이미지를 고립된 환경에서 개별적인 파일 시스템 안에서 실행할 수 있는 것.&lt;/p&gt;

&lt;p&gt;이미지를 이용해서 어플리케이션을 구동!&lt;/p&gt;

&lt;p&gt;Image라는 클래스로 각 인스턴스(스냅샷)을 찍어내고 그 인스턴스를 가지는 각각의 컨테이너를 만들어낸다. → 컨테이너에서 각각 동작하는 어플리케이션은 개별적으로 수정이 가능함. 수정된 파일은 이미지에 영향을 끼치지 않음&lt;/p&gt;

&lt;h2 id=&quot;shipping-containers&quot;&gt;Shipping Containers&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;container-registry&quot;&gt;Container Registry&lt;/h3&gt;

&lt;p&gt;public과 private으로 나뉨. 회사에서는 대부분 private 이용&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;public
    &lt;ul&gt;
      &lt;li&gt;Docker Hub, Red Hat quay.io, Github Packages&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;private
    &lt;ul&gt;
      &lt;li&gt;AWS, Google Cloud, MS Azure&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;실습-1&quot;&gt;실습 (1)&lt;/h2&gt;

&lt;h3 id=&quot;dockerfile-1&quot;&gt;Dockerfile&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/build/building/best-practices/&quot;&gt;https://docs.docker.com/build/building/best-practices/&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;css
FROM node:16-alpine

WORKDIR /app

COPY package.json package-lock.json ./

RUN npm ci

COPY index.js .

ENTRYPOINT [ &quot;node&quot;, &quot;index.js&quot; ]

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;FROM: 베이스 이미지를 지정. alpine은 최소단위의 리눅스 버전.
[https://hub.docker.com/&lt;em&gt;/node/](https://hub.docker.com/&lt;/em&gt;/node/)&lt;/li&gt;
  &lt;li&gt;WORKDIR: 컨테이너 안에서 어떤 경로에 실행할건지를 명시
ex. /app ⇒ 루트 경로의 app이라는 디렉토리안에 프로젝트 관련 파일을 모두 copy하겠다&lt;/li&gt;
  &lt;li&gt;COPY: 도커 파일에서 카피하고 명령어를 실행하는 것은 &lt;u&gt;**레이어 시스템**&lt;/u&gt;으로 구성. 따라서 빈번히 변경되는 파일일수록 제일 마지막에 작성하는 것이 좋음 
ex. 소스코드를 담은 index.js가 package.json보다는 빈번히 변경될 가능성이 높음 → 따라서 package.json을 가장 먼저 복사해오도록 작성&lt;/li&gt;
  &lt;li&gt;RUN: npm install보다 npm ci를 쓰는게 좋음. 
why? install은 프로젝트에서 사용된 것보다 높은 버전이 나오면 그 버전으로 설치가 되는 이슈 있음. ci를 쓰면 lock.json에 쓰인 버전으로 설치가 가능.
+) yarn install은 yarn.lock 파일이 존재하면 npm ci와 비슷한 방식으로 정확한 버전을 설치해서 일관성 유지 → 그런데 우리 플젝 yarn.lock 날렸는데… 괜찮은건가요?&lt;/li&gt;
  &lt;li&gt;COPY: 소스코드 카피&lt;/li&gt;
  &lt;li&gt;ENTRYPOINT: 배열에 담긴 커맨드를 합쳐서 실행&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;dockerfile의-레이어-시스템&quot;&gt;Dockerfile의 레이어 시스템&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;빈번하게 변경되는 것을 하위 레이어에 두어서 이미지 생성 시간을 감축시킨다.&lt;/p&gt;

&lt;h3 id=&quot;이미지-만들기&quot;&gt;이미지 만들기&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
docker build -f Dockerfile -t fun-docket . 

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.&lt;/code&gt; : build context, 도커파일이 있는 경로를 지정&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-f Dockerfile&lt;/code&gt; : 어떤 도커파일을 쓸건지 지정&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-t fun-docket&lt;/code&gt; : 이미지에 이름 부여. 태그&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
docker images

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/5.png&quot; alt=&quot;5&quot; /&gt;&lt;em&gt;오타 이슈..&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;로컬에서 만들어진 이미지 확인&lt;/li&gt;
  &lt;li&gt;container registry에 올릴때 repository 이름이 사용됨&lt;/li&gt;
  &lt;li&gt;tag는 이미지 버전을 뜻함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;이미지-실행&quot;&gt;이미지 실행&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
docker run -d -p 8080:8080 fun-docker

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-d&lt;/code&gt; : detached. 백그라운드에서 계속 동작하도록 함&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-p&lt;/code&gt; : 포트 지정. 호스트머신의 포트와 컨테이너의 포트를 연결&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/6.png&quot; alt=&quot;6&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
docker ps

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/7.png&quot; alt=&quot;7&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;현재 실행 중인 컨테이너의 리스트&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
docker logs {컨테이너 id}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/8.png&quot; alt=&quot;8&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;컨테이너 터미널에서 발생하는 로그 확인&lt;/li&gt;
  &lt;li&gt;도커 데스크톱에서도 확인 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/9.png&quot; alt=&quot;9&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;+) 로그인이 계속 Denied 되는 이슈가 있었는데 도커 브라우저의 캐시를 지우고 다시 시도하니 잘 됐음&lt;/p&gt;

&lt;h3 id=&quot;이미지-배포-with-dockerhub&quot;&gt;이미지 배포 with DockerHub&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/10.png&quot; alt=&quot;10&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;docker push gominzip/docker-example:tagname로 만들었으면 로컬 이미지 이름도 레포지토리와 동일하게 docker-example로 일치시켜줘야함&lt;/li&gt;
  &lt;li&gt;변경 방법&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
	docker tag fun-docket:latest gominzip/docker-example:latest
	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/11.png&quot; alt=&quot;11&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;로그인하기&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
	docker login
	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이미지 push&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
	docker push gominzip/docker-example:latest
	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/12.png&quot; alt=&quot;12&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/13.png&quot; alt=&quot;13&quot; /&gt;&lt;em&gt;업로드 된 모습&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;docker-compose&quot;&gt;🙌 Docker Compose&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=3FY-DzXYu7E&quot;&gt;https://www.youtube.com/watch?v=3FY-DzXYu7E&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;compose 파일은 도커 어플리케이션의 서비스, 네트워크, 볼륨 등의 설정을 yaml 형식으로 작성하는 파일&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/compose/intro/compose-application-model/&quot;&gt;https://docs.docker.com/compose/intro/compose-application-model/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/14.png&quot; alt=&quot;14&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;공식문서-코드로-이해하기&quot;&gt;공식문서 코드로 이해하기&lt;/h2&gt;

&lt;p&gt;프론트엔드와 백엔드로 나누어진 프로젝트의 예시&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yaml
services:
  frontend:
    image: example/webapp  # 프런트엔드 서비스는 &apos;example/webapp&apos; 이미지를 사용
    ports:
      - &quot;443:8043&quot;  # 호스트의 443 포트를 컨테이너의 8043 포트에 매핑 (외부 HTTPS 접근 가능)
    networks:
      - front-tier  # 외부와의 통신을 위한 네트워크
      - back-tier   # 백엔드와의 내부 통신을 위한 네트워크
    configs:
      - httpd-config  # 외부에서 제공되는 HTTP 설정 파일을 주입
    secrets:
      - server-certificate  # 외부에서 제공되는 HTTPS 인증서를 주입

  backend:
    image: example/database  # 백엔드 서비스는 &apos;example/database&apos; 이미지를 사용
    volumes:
      - db-data:/etc/data  # &apos;db-data&apos;라는 볼륨을 컨테이너의 /etc/data 경로에 마운트 (데이터 저장)
    networks:
      - back-tier  # 프런트엔드와의 내부 통신을 위한 네트워크

volumes:
  db-data:
    driver: flocker  # &apos;flocker&apos; 드라이버를 사용하여 볼륨을 관리
    driver_opts:
      size: &quot;10GiB&quot;  # 볼륨 크기를 10GiB로 설정

configs:
  httpd-config:
    external: true  # 이 설정 파일은 외부에서 제공됨 (Compose가 생성하지 않음)

secrets:
  server-certificate:
    external: true  # 이 비밀은 외부에서 제공됨 (Compose가 생성하지 않음)

networks:
  # 다음 네트워크는 객체만 정의하면 충분 (세부 설정은 생략)
  front-tier: {}  # 프런트엔드가 사용하는 네트워크
  back-tier: {}   # 프런트엔드와 백엔드 간의 내부 통신 네트워크

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;주 구성 요소
    &lt;ul&gt;
      &lt;li&gt;services&lt;/li&gt;
      &lt;li&gt;volumes&lt;/li&gt;
      &lt;li&gt;configs&lt;/li&gt;
      &lt;li&gt;secrets&lt;/li&gt;
      &lt;li&gt;networks&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;⇒ service를 제외하고는 실무에서 잘 사용하지 않는 듯&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;services&quot;&gt;Services&lt;/h2&gt;

&lt;p&gt;services는 여러 컨테이너를 정의하는데 사용됨&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yaml
services:
  frontend:
    image: example/webapp

  backend:
    image: example/database 

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;→ frontend와 backend는 각 컨테이너를 정의하게 되며 컨테이너의 이름이 됨&lt;/p&gt;

&lt;h3 id=&quot;설정-키워드&quot;&gt;설정 키워드&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/15.png&quot; alt=&quot;15&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;실행-명령어-및-상태-확인&quot;&gt;&lt;strong&gt;실행 명령어 및 상태 확인&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker compose up&lt;/code&gt;&lt;/strong&gt;: 프런트엔드와 백엔드 서비스를 시작하고, 필요한 네트워크와 볼륨을 생성하며, 설정 파일과 비밀을 프런트엔드 서비스에 주입.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker compose ps&lt;/code&gt;&lt;/strong&gt;: 현재 실행 중인 컨테이너의 상태를 보여주어 어떤 컨테이너가 실행 중인지, 상태는 어떤지, 그리고 사용 중인 포트를 확인 가능.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker-compose -f docker-compose-custom.yml up&lt;/code&gt;&lt;/strong&gt;: docker-compose는 기본적으로 ‘docker-compose.yml’ 또는 ‘docker-compose.yaml’의 이름을 사용. 만약 다른 이름으로 관리시 -f 옵션 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker-compose -d&lt;/code&gt;&lt;/strong&gt; : 백그라운드에서 docker-compose를 실행하기 위해 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;실습-2&quot;&gt;실습 (2)&lt;/h2&gt;

&lt;p&gt;Dockerfile&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yaml
FROM node:18-alpine

WORKDIR /app

COPY package.json package-lock.json ./

RUN npm ci

COPY . .

EXPOSE 3000

CMD [&quot;npm&quot;, &quot;start&quot;]

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;docker-compose.yml&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yaml
version: &quot;3&quot;
services:
  web:
    build: .
    ports:
      - &quot;3000:8080&quot;  # 3000은 호스트 포트, 8080은 컨테이너 포트
    depends_on:
      - database
  database:
    image: mongo:6
    ports:
      - &quot;27017:27017&quot;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/16.png&quot; alt=&quot;16&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/17.png&quot; alt=&quot;17&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/18.png&quot; alt=&quot;18&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;각 서비스 컨테이너가 실행&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/19.png&quot; alt=&quot;19&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;호스트의 3000번 포트로 잘 열림&lt;/p&gt;

&lt;p&gt;근데 DB는 이렇게 하는거 아닌거 같음 ㅇㅅㅇ..&lt;/p&gt;

&lt;p&gt;아무튼 작동 방식 이해 완.&lt;/p&gt;

&lt;h1 id=&quot;학습-후기&quot;&gt;💬 학습 후기&lt;/h1&gt;

&lt;p&gt;늘 인프라에 대한 진입장벽이 있었는데 실습하면서 테스트해보니 그렇게 복잡한 느낌은 아니었다. 실제 프로젝트에 도입하는걸 보면서 쓰이는 이유를 직접 체감해보고 싶다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;gominzip&quot;]</name>
        
        
      </author>

      

      

      
        <summary type="html">목차</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">tsconfig.json의 상호 참조 문제</title>
      <link href="https://blog.liboo.kr/tsconfig.json%EC%9D%98_%EC%83%81%ED%98%B8_%EC%B0%B8%EC%A1%B0_%EB%AC%B8%EC%A0%9C" rel="alternate" type="text/html" title="tsconfig.json의 상호 참조 문제" />
      <published>2024-11-08T02:50:00+00:00</published>
      <updated>2024-11-08T02:50:00+00:00</updated>
      <id>https://blog.liboo.kr/tsconfig.json%EC%9D%98_%EC%83%81%ED%98%B8_%EC%B0%B8%EC%A1%B0_%EB%AC%B8%EC%A0%9C</id>
      <content type="html" xml:base="https://blog.liboo.kr/tsconfig.json%EC%9D%98_%EC%83%81%ED%98%B8_%EC%B0%B8%EC%A1%B0_%EB%AC%B8%EC%A0%9C">&lt;h2 id=&quot;문제상황&quot;&gt;문제상황&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-08-tsconfig.json의_상호_참조_문제.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;코드 구현을 시작하려고 보니 타입체킹이 진행이 안되고 있었다.&lt;/p&gt;

&lt;p&gt;tsconfig에는 strict모드가 true인데 어째서 안되는지 확인해보니, 루트와 프론트엔드의 두 tsconfig가 references 속성으로 서로를 참조하고 있었기 때문이었다.&lt;/p&gt;

&lt;h2 id=&quot;해결-방식&quot;&gt;해결 방식&lt;/h2&gt;

&lt;p&gt;references는 상위 파일만 하위 파일을 지정해서 놓아주면 된다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://velog.io/@dev_jazziron/typeScript-tsconfig#composite&quot;&gt;https://velog.io/@dev_jazziron/typeScript-tsconfig#composite&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;gominzip&quot;]</name>
        
        
      </author>

      

      

      
        <summary type="html">문제상황</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">동영상 스트리밍 처리 프로토콜을 알아보자</title>
      <link href="https://blog.liboo.kr/%EB%8F%99%EC%98%81%EC%83%81_%EC%8A%A4%ED%8A%B8%EB%A6%AC%EB%B0%8D_%EC%B2%98%EB%A6%AC_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%84_%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90" rel="alternate" type="text/html" title="동영상 스트리밍 처리 프로토콜을 알아보자" />
      <published>2024-10-28T02:40:00+00:00</published>
      <updated>2024-10-28T02:40:00+00:00</updated>
      <id>https://blog.liboo.kr/%EB%8F%99%EC%98%81%EC%83%81_%EC%8A%A4%ED%8A%B8%EB%A6%AC%EB%B0%8D_%EC%B2%98%EB%A6%AC_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%84_%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90</id>
      <content type="html" xml:base="https://blog.liboo.kr/%EB%8F%99%EC%98%81%EC%83%81_%EC%8A%A4%ED%8A%B8%EB%A6%AC%EB%B0%8D_%EC%B2%98%EB%A6%AC_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%84_%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90">&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;목차&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;학습-이유&quot;&gt;🤔 학습 이유&lt;/h1&gt;

&lt;p&gt;서비스의 레퍼런스로 Zoom과 치지직 등 여러 스트리밍 서비스의 동작원리를 조사하던 중, 각 서비스별로 서로 다른 프로토콜을 사용하는 것을 발견할 수 있었다.&lt;/p&gt;

&lt;p&gt;영상 송출에 사용되는 프로토콜을 조사하고 우리 서비스에 적합한 프로토콜을 선정하고자 한다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동영상 스트리밍 처리 프로토콜
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;HLS&lt;/strong&gt; &lt;strong&gt;- 지연시간이 높지만 호환성이 좋음 (치지직) - 민지, 영길&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;왜 다른 프로토콜에 비해 지연시간이 길까?&lt;/li&gt;
          &lt;li&gt;어떻게 지연시간을 낮출 수 있을까?&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;WebRTC - 지연시간이 낮지만 P2P에 적합 (구글미트) - 창현&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;RTMP - 지연시간 낮음 (트위치) - 준서, 지수&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;Dynamic Adapltive Streaming over HTTP&lt;/li&gt;
      &lt;li&gt;SRT&lt;/li&gt;
      &lt;li&gt;RTSP&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;1️⃣rtsp-real-time-streaming-protocol&quot;&gt;1️⃣ RTSP &lt;strong&gt;(Real Time Streaming Protocol)&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;스트리밍의 시작이라고 말할 수 있다. 1996년 등장하였으며 RTSP가 등장 전 영상, 음악 등 멀티미디어 정보를 완전히 다운로드한 후 시청할 수 있었음.&lt;/p&gt;

&lt;p&gt;다만 오래된 기술이라 화질 저하, 미디어 서버 운영에 대한 높은 난이도 등으로 도태되고 있는 실정.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;애플은 HLS가 개발되기 이전에 &lt;strong&gt;RTSP&lt;/strong&gt; 기반의 QTSS로 비디오와 오디오를 처리했었음
    &lt;ul&gt;
      &lt;li&gt;하지만 QTSS가 애플 생태계에서만 최적화가 되어있었기 때문에 호환성 이유가 있었음&lt;/li&gt;
      &lt;li&gt;RTSP는 HTTP 기반이 아닌 TCP, UDP 사용 
  → 네트워크 상태나 방화벽 문제로 인해 HTTP보다 호환성 낮음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CCTV에서 사용하고 있는 프로토콜&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;스트리머 → rtmp → 서버 → hls → 클라이언트&lt;/p&gt;

&lt;h1 id=&quot;2️⃣hls-hypertext-live-streaming&quot;&gt;2️⃣ HLS (Hypertext Live Streaming)&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;참고자료&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[https://medium.com/@cwh./%EB%8F%99%EC%98%81%EC%83%81-%EC%95%88%EB%81%8A%EA%B8%B0%EA%B3%A0-%EB%B3%B4%EB%8A%94%EB%B2%95-feat-ll-hls-a6a0c453b21f](https://medium.com/@cwh./%EB%8F%99%EC%98%81%EC%83%81-%EC%95%88%EB%81%8A%EA%B8%B0%EA%B3%A0-%EB%B3%B4%EB%8A%94%EB%B2%95-feat-ll-hls-a6a0c453b21f)


[https://medium.com/@delivalue100/hls-http-live-streaming-4fb1d2992d57](https://medium.com/@delivalue100/hls-http-live-streaming-4fb1d2992d57)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;왜-만들어졌을까-feat-rtsp&quot;&gt;왜 만들어졌을까? feat. RTSP&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;RTSP는 고정된 비트레이트로 콘텐츠 스트리밍에 최적화
    &lt;ul&gt;
      &lt;li&gt;고정 비트레이트의 경우 한가지 속도로만 데이터를 전송하다 보니 네트워크 상태가 변할 때에도 동일한 비트레이트로 스트리밍을 유지해야한다는 문제가 있음&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;⇒ 따라서 호환성이 높은 HTTP를 기반으로, &lt;strong&gt;네트워크 상태에 따라 비디오 품질을 실시간으로 조정&lt;/strong&gt; 가능한 &lt;strong&gt;가변 비트레이트&lt;/strong&gt; 기능까지 도입된 것이 &lt;strong&gt;HLS&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;동작-원리-이해하기&quot;&gt;동작 원리 이해하기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP기반의 단방향 미디어 스트리밍 프로토콜&lt;/li&gt;
  &lt;li&gt;일반 웹서버 + CDN을 활용해 콘텐츠 배포&lt;/li&gt;
  &lt;li&gt;[비디오 → HTTP 파일 조각으로 나눔 → 전송 →] 재생&lt;/li&gt;
  &lt;li&gt;HTTP 파일로 나누기 때문에 별도의 전용 서버가 필요하지 않다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;m3u8 : 메타데이터
    &lt;ul&gt;
      &lt;li&gt;시작 태그&lt;/li&gt;
      &lt;li&gt;hls 프로토콜 버전&lt;/li&gt;
      &lt;li&gt;세그먼트의 최대 길이&lt;/li&gt;
      &lt;li&gt;첫 번째 세그먼트의 시퀀스 번호&lt;/li&gt;
      &lt;li&gt;실제 세그먼트의 길이, 다음 세그먼트 인덱스&lt;/li&gt;
      &lt;li&gt;종료 태그&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ts : 실제 비디오의 조각들을 담고 있는 컨테이너&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;왜-다른-프로토콜에-비해-지연시간이-길까&quot;&gt;왜 다른 프로토콜에 비해 지연시간이 길까?&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;지연시간이 긴 것에는 다양한 원인이 있었음&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;UDP 를 사용하는 다른 프로토콜들과 달리 HLS 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TCP&lt;/code&gt; 를 사용한다.&lt;/li&gt;
  &lt;li&gt;HLS 는 오히려 실시간에 집중하기 보다는 데이터의 신뢰성과 효율성에 집중한 프로토콜이다.&lt;/li&gt;
  &lt;li&gt;동작 방식으로 인한 지연
    &lt;ol&gt;
      &lt;li&gt;서버에서 스트리밍할 비디오 파일을 짧은 세그먼트(2~10초)로 분할 
 → 재생을 시작하기 위해선 &lt;strong&gt;적어도 몇 개의 세그먼트가 필요해 초기 버퍼링 시간이 길어짐&lt;/strong&gt; (세그먼트 길이가 길수록 지연이 커질 수 있음)
 ⇒ CDN으로 세그먼트 캐싱해서 데이터 전송 시간을 개선하려함&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP 기반 요청-응답 지연
    &lt;ol&gt;
      &lt;li&gt;HTTP 기반이므로 &lt;strong&gt;각 세그먼트 마다 서버에 요청을 보내고 응답을 기다리는 시간&lt;/strong&gt;이 필요. 네트워크의 상태나 응답 속도에 종속&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;가변 비트레이트 지연
    &lt;ol&gt;
      &lt;li&gt;네트워크 상태에 따라 &lt;strong&gt;최적의 비트레이트를 선택하기 위한 모니터링&lt;/strong&gt; 진행 
 → 이 과정에서 비트레이트를 전환하며 지연이 발생함 
 ⇒ 지연이 시청 환경을 개선하지만 실시간성에서는 불리함!&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;CDN 캐싱과 서버 최적화 이슈
    &lt;ol&gt;
      &lt;li&gt;세그먼트 파일이 여러 서버에 캐시되어도 여전히 HTTP 기반으로 동작해 추가적인 통신과정 필요&lt;/li&gt;
      &lt;li&gt;특히 사용자 많은 라이브방송에서는 CDN이 적절히 분배되지 않으면 지연 발생&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;⇒ 따라서 HLS는 라이브 스트리밍보다는 정적 비디오 플레이어에 더 적합&lt;/p&gt;

&lt;h3 id=&quot;치지직에서의-hls-사용법&quot;&gt;치지직에서의 HLS 사용법&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;⇒ 결국 클라이언트가 플레이리스트의 미디어 세그먼트들을 순차적으로 GET하고 마지막쯤에 새로운 세그먼트를 요청하는 흐름이기 때문에 &lt;strong&gt;단방향 통신으로 동작한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;+) 뒤로 돌려보기 안되는 이유..? 돌려보기 자체에 리소스 소모가 큰듯. 그냥 방송 종료 후 다시보기 기능을 넣는게 이득&lt;/p&gt;

&lt;h3 id=&quot;지연시간-어떻게-개선할-수-있을까&quot;&gt;지연시간 어떻게 개선할 수 있을까?&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cdnetworks.com/ko/blog/media-delivery/http-live-streaming/&quot;&gt;https://www.cdnetworks.com/ko/blog/media-delivery/http-live-streaming/&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;세그먼트 길이 단축
    &lt;ol&gt;
      &lt;li&gt;6초 이상의 기본적인 세그먼트 길이를 2~1초로 줄이기
        &lt;ol&gt;
          &lt;li&gt;짧아질수록 서버와 클라이언트 사이에 요청이 많아 부하가 생길 수 있으니 균형점을 찾아야함&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;LL-HLS 도입
    &lt;ol&gt;
      &lt;li&gt;애플이 개발한 HLS의 초저지연 버전&lt;/li&gt;
      &lt;li&gt;세그먼트 내에서 더 작은 단위인 파트로 나눠 전송하며, 세그먼트가 완전히 준비되지 않아도 일부를 먼저 전송함&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;세그먼트 프리페칭
    &lt;ol&gt;
      &lt;li&gt;클라이언트가 다음 세그먼트를 미리 예측하고 사전 다운로드&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;송출 환경 최적화
    &lt;ol&gt;
      &lt;li&gt;치지직 공지사항을 보니 송출 프로그램을 최적화하는 방법도..&lt;/li&gt;
      &lt;li&gt;스트리머가 키프레임 간격을 너무 짧게 설정 →세그먼트가 너무 짧아짐, 서버 부하 ⇒ 버퍼링 많아짐 이슈인듯
        &lt;ol&gt;
          &lt;li&gt;&lt;a href=&quot;https://help.naver.com/notice/noticeView.help?noticeNo=17188&amp;amp;serviceNo=23946&amp;amp;lang=ko&quot;&gt;https://help.naver.com/notice/noticeView.help?noticeNo=17188&amp;amp;serviceNo=23946&amp;amp;lang=ko&lt;/a&gt;&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;비트레이트와-세그먼트&quot;&gt;비트레이트와 세그먼트&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;비트레이트&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m3u8&lt;/code&gt; 플레이리스트 파일 수정
        &lt;ol&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EXT-X-STREAM-INF&lt;/code&gt; 태그를 사용하여 비트레이트를 설정&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
			#EXTM3U
			#EXT-X-VERSION:3
			
			#EXT-X-STREAM-INF:BANDWIDTH=1500000
			# 이 스트림에 대한 메타데이터를 정의
			# BANDWIDTH=1500000은 이 스트림의 대역폭 요구 사항이 1,500,000 비트(1.5 Mbps)임을 나타냄
			
			stream_1500.m3u8
			
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	2. 추가적인 태그 설명
		- **#EXT-X-DISCONTINUITY**: 이전 세그먼트와의 **연속성이 끊어짐**을 표시합니다. 이는 광고와 같은 **다른 유형의 미디어를 삽입**할 때 사용됩니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
				m3u8
				#EXT-X-DISCONTINUITY
				
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;			- **예시**: 이 태그 뒤에 오는 세그먼트는 이전 미디어와는 다르게 인코딩되었거나 다른 타입의 미디어임을 의미합니다.
		- **#EXT-X-STREAM-INF**: **다중 비트레이트 스트림** 또는 **적응형 스트리밍**을 위해 사용됩니다. 여러 비트레이트를 가진 대체 스트림이 있을 때, 클라이언트가 네트워크 상태에 따라 적절한 스트림을 선택할 수 있도록 합니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
				m3u8
				#EXT-X-STREAM-INF:BANDWIDTH=800000,RESOLUTION=640x360
				low.m3u8
				#EXT-X-STREAM-INF:BANDWIDTH=1500000,RESOLUTION=1280x720
				medium.m3u8
				
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;			- **예시**: 800kbps, 1500kbps로 각각 다른 해상도의 스트림을 제공합니다. 클라이언트는 네트워크 상황에 따라 적절한 `m3u8` 파일을 선택하게 됩니다.
		- **#EXT-X-KEY**: 세그먼트의 **암호화 키 정보**를 제공합니다. HLS에서는 콘텐츠 보호를 위해 **AES-128 암호화**를 사용하여 세그먼트를 암호화할 수 있습니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
				m3u8
				#EXT-X-KEY:METHOD=AES-128,URI=&quot;https://example.com/key&quot;
				
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;			- **예시**: 세그먼트를 AES-128로 암호화하며, 암호화 키를 가져올 위치는 `https://example.com/key`입니다. 2. **세그먼트**
1. FFmpeg로 비디오를 여러 해상도로 인코딩할 때 `-hls_time`을 사용하여 세그먼트의 길이를 설정 (기본 10초)
2. [https://frontdev.tistory.com/entry/ffmpeg%EB%A1%9C-hls-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EC%98%B5%EC%85%98%EC%A0%95%EB%A6%AC](https://frontdev.tistory.com/entry/ffmpeg%EB%A1%9C-hls-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EC%98%B5%EC%85%98%EC%A0%95%EB%A6%AC)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
		- ffmpeg -i hasashin.mp4 -b:v 1M -g 60 -hls_time 2 -hls_list_size 0 -hls_segment_size 500000 output.m3u8
		출처: https://frontdev.tistory.com/entry/ffmpeg로-hls-만들기-옵션정리 [Front End Develop:티스토리]
		
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;결론
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;높은 비트레이트와 긴 세그먼트&lt;/strong&gt;: 높은 비트레이트를 사용하면서 긴 세그먼트를 전송할 경우, 네트워크 대역폭을 효율적으로 사용할 수 있지만, 지연 시간이 증가. 특히 불안정한 네트워크에서는 재생 품질이 저하됨.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;낮은 비트레이트와 짧은 세그먼트&lt;/strong&gt;: 낮은 비트레이트와 짧은 세그먼트를 조합하면, 재생 안정성이 높아지고 지연 시간 감소, 비디오 품질은 저하. ⇒ 이게 우리서비스에 적합하지 않을까?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;ll-hls의-지연시간-개선-방법&quot;&gt;LL-HLS의 지연시간 개선 방법&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;하나당 10초 정도인 ts 가 아닌 1초 이하 정도의 CMAF 컨테이너에 담아서 생성 즉시 전송한다.&lt;/li&gt;
  &lt;li&gt;또한 m3u8 파일에 추가적인 메타데이터가 들어간다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ll-hls-관련-메타데이터&quot;&gt;LL-HLS 관련 메타데이터&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;#EXT-X-PART-INF&lt;/strong&gt;: &lt;strong&gt;저지연 HLS&lt;/strong&gt;에서 사용되는 태그로, 세그먼트가 &lt;strong&gt;파편(chunk)&lt;/strong&gt;으로 나뉘어 전송되는 경우 각 파편의 정보를 포함합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
	m3u8
	#EXT-X-PART-INF:PART-TARGET=1.0
	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- **예시**: 각 파편의 타겟 길이가 **1초**임을 의미합니다. - **#EXT-X-PRELOAD-HINT**: LL-HLS에서 아직 완료되지 않은 세그먼트나 파편에 대해 **미리 가져올 힌트**를 제공합니다. 이를 통해 클라이언트가 지연 시간을 줄이기 위해 미리 준비할 수 있습니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
	m3u8
	#EXT-X-PRELOAD-HINT:TYPE=PART,URI=&quot;segment3_part1.ts&quot;
	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- **예시**: `segment3_part1.ts` 파편을 미리 로드할 힌트입니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;응답-지연&quot;&gt;응답 지연&lt;/h2&gt;

&lt;p&gt;저번 금요일에 회고 시간에,  Short Polling, Long Polling 이 나왔던 적이 있었는데 이와 비슷한 방식으로 지연 시간을 줄였다고 보면 쉬울 것 같다.&lt;/p&gt;

&lt;p&gt;Short Polling 은 주기적으로 서버에 요청을 보내서 업데이트 된 사항이 있는지를 체크한다. 만약 업데이트된 사항이 없다면 서버는 304(Not Modified), 200 를 반환한다.&lt;/p&gt;

&lt;p&gt;이때 클라이언트는 업데이트된 사항이 있을 때 까지 또 요청을 보낸다.&lt;/p&gt;

&lt;p&gt;Long Polling (200) 은 클라이언트가 서버에 요청을 보냈을 때, 업데이트가 되기 전까지는 서버가 응답을 되돌려주지 않고 연결을 유지(지연)하다가, 업데이트가 된 순간 응답을 보낸다.&lt;/p&gt;

&lt;p&gt;기존 HLS는 메타데이터(플레이리스트) 인 .m3u8 파일을 지속적으로 서버에 요청해서 .m3u8 을 토대로 세그먼트를 재생하는 방식인데, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지속적으로 서버에 요청&lt;/code&gt; 이 과정이 지연시간의 주범이다. 이 시간 동안 클라이언트는 세그먼트를 받는게 아니라 대기를 해버리기 때문에, 실제 동영상 파일인 세그먼트를 업데이트가 되고 나서야 받을 수 있다.&lt;/p&gt;

&lt;p&gt;기존 HLS 는 HTTP 요청을 주기적으로 보내서 .m3u8 이 업데이트가 되었는지 확인을 한다. 만약 업데이트가 되지 않았다면 또 서버에 요청을 보내고, 업데이트가 되었다는 응답을 받고 나서야 실제 스트리밍 데이터인 세그먼트를 받아온다.&lt;/p&gt;

&lt;p&gt;LL-HLS 는&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;클라이언트의 플레이리스트 요청&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;클라이언트가 서버에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.m3u8&lt;/code&gt; &lt;strong&gt;플레이리스트&lt;/strong&gt;를 요청합니다. 이때 클라이언트는 &lt;strong&gt;최신 세그먼트&lt;/strong&gt;를 가져오기를 원합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;서버의 요청 지연(Blocking)&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;만약 서버에 &lt;strong&gt;새로운 세그먼트&lt;/strong&gt;가 아직 생성되지 않은 경우, 서버는 즉시 응답을 하지 않고 요청을 &lt;strong&gt;일정 시간 동안 대기(Blocking)&lt;/strong&gt; 시킵니다. 이 대기 시간 동안 서버는 새로운 세그먼트가 생성되기를 기다립니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;새로운 세그먼트 생성 시 응답&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;새로운 세그먼트가 생성되면 서버는 대기 중인 클라이언트의 요청에 응답하여 &lt;strong&gt;최신 플레이리스트&lt;/strong&gt;를 반환합니다. 클라이언트는 이를 통해 바로 다음 세그먼트를 가져가 재생을 시작할 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;업데이트 주기 단축&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;이러한 방식은 기존의 주기적인 폴링 방식보다 &lt;strong&gt;지연 시간&lt;/strong&gt;을 훨씬 줄일 수 있습니다. 즉, 클라이언트가 계속해서 플레이리스트를 요청하여 최신 정보를 받기 위해 대기하지 않도록 하여 지연 시간을 줄입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;서버의-부하&quot;&gt;서버의 부하&lt;/h2&gt;

&lt;p&gt;LL-HLS 는 세그먼트를 더 짧게 생성하기 때문에 당연히 세그먼트를 더 자주 생성하게 되고, m3u8 의 업데이트도 더 많이 일어난다. 따라서 서버의 부담이 증가하게 된다.&lt;/p&gt;

&lt;p&gt;서버의 부담을 줄이는 방법은 있을까?&lt;/p&gt;

&lt;h3 id=&quot;서버-부하를-줄이기-위한-방안&quot;&gt;서버 부하를 줄이기 위한 방안&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;CDN(Content Delivery Network) 사용&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;LL-HLS&lt;/strong&gt;에서 서버 부하를 줄이기 위해 가장 많이 사용되는 방법 중 하나는 &lt;strong&gt;CDN&lt;/strong&gt;을 사용하는 것입니다. CDN은 스트리밍 콘텐츠를 여러 지점에 &lt;strong&gt;캐시&lt;/strong&gt;하고, 지리적으로 가까운 사용자에게 콘텐츠를 제공함으로써 &lt;strong&gt;서버의 부하를 분산&lt;/strong&gt;시킵니다.&lt;/li&gt;
      &lt;li&gt;CDN을 사용하면 클라이언트가 직접 서버에 연결하는 대신 CDN에서 콘텐츠를 받아가므로, &lt;strong&gt;서버의 직접적인 요청 수&lt;/strong&gt;를 줄일 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;효율적인 세그먼트 생성 및 캐싱&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;서버는 세그먼트를 효율적으로 생성하고, &lt;strong&gt;재사용 가능한 세그먼트를 캐싱&lt;/strong&gt;함으로써 부하를 줄일 수 있습니다. 특히, 플레이리스트와 세그먼트가 자주 변경되기 때문에, 이를 적절히 캐싱하여 동일한 콘텐츠를 여러 클라이언트가 요청하는 경우 서버에서 재생성할 필요가 없도록 해야 합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;최적의 플레이리스트 및 세그먼트 길이 조정&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;LL-HLS에서는 지연 시간을 줄이기 위해 세그먼트를 작은 크기로 나누지만, &lt;strong&gt;너무 작은 단위의 세그먼트&lt;/strong&gt;는 서버 부하를 크게 증가시킬 수 있습니다. 따라서 &lt;strong&gt;적절한 세그먼트 길이&lt;/strong&gt;와 &lt;strong&gt;플레이리스트 갱신 주기&lt;/strong&gt;를 설정하여 서버 부하와 지연 시간을 균형 있게 맞추는 것이 중요합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;대신 safari 를 제외한 브라우저에서는 &lt;video&gt; 태그만으로는 재생이 불가능하다. HLS 스트림 변환이 필요하다.&lt;/video&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;hls.js → hls 스트림을 브라우저가 이해할 수 있는 포맷으로 변환하여 &lt;video&gt; 요소에 전달하는 라이브러리&lt;/video&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;3️⃣webrtc-web-real-time-communication&quot;&gt;3️⃣ WebRTC (Web Real-Time Communication)&lt;/h1&gt;

&lt;p&gt;웹 브라우저 간에 플러그인의 도움 없이 서로 통신할 수 있도록 설계된 &lt;strong&gt;Javascript API&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;→ 별다른 소프트웨어 없이 카메라, 마이크 등을 사용하여 실시간 커뮤니케이션을 제공&lt;/p&gt;

&lt;p&gt;음성 통화, 영상 통화, P2P 파일 공유 등으로 활용됨&lt;/p&gt;

&lt;h2 id=&quot;webrtc의-장점&quot;&gt;WebRTC의 장점&lt;/h2&gt;

&lt;h3 id=&quot;webrtc는-낮은-latency를-갖는다&quot;&gt;WebRTC는 낮은 Latency를 갖는다&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;WebRTC는 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P2P(peer-to-peer)방식&lt;/code&gt;&lt;/strong&gt;으로 데이터를 전송
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;P2P&lt;/strong&gt;는 &lt;strong&gt;중간 서버&lt;/strong&gt;를 거치지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;WebRTC는 &lt;strong&gt;UDP 기반&lt;/strong&gt;으로 작동하여 신속하게 패킷을 전송
    &lt;ul&gt;
      &lt;li&gt;HLS와 RTMP는 &lt;strong&gt;TCP 기반&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;webrtc는-호환성이-높다&quot;&gt;WebRTC는 호환성이 높다&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/5.png&quot; alt=&quot;5&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;webrtc의-단점&quot;&gt;WebRTC의 단점&lt;/h2&gt;

&lt;h3 id=&quot;많은-사용자가-사용할-수-없다-스케일링-문제&quot;&gt;많은 사용자가 사용할 수 없다 (스케일링 문제)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;WebRTC는 P2P(peer-to-peer) 구조로 작동하기 때문에 각 사용자 간의 직접적인 연결을 설정&lt;/li&gt;
  &lt;li&gt;사용자가 많아질수록 필요한 연결 수가 &lt;strong&gt;기하급수적으로 증가&lt;/strong&gt;함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/6.png&quot; alt=&quot;6&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;N명의 사용자가 있을 때 사용자 한명이 추가되면 N개의 연결이 필요
    &lt;ul&gt;
      &lt;li&gt;서버와 클라이언트 모두에 큰 부담&lt;/li&gt;
      &lt;li&gt;네트워크 대역폭과 성능 저하 초래&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;화질-문제-성능문제&quot;&gt;화질 문제 (성능문제)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;실시간 비디오와 오디오 스트리밍을 위해 상당한 대역폭을 소모&lt;/li&gt;
  &lt;li&gt;특히 고화질 비디오 스트림은 많은 대역폭을 요구&lt;/li&gt;
  &lt;li&gt;대역폭이 제한된 환경에서는 &lt;strong&gt;패킷 손실&lt;/strong&gt;이 발생할 수 있으며, 이는 전체 스트림의 품질 저하로 이어짐
    &lt;ul&gt;
      &lt;li&gt;WebRTC는 &lt;strong&gt;UDP 기반&lt;/strong&gt;이므로 패킷 손실이 일어날 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다수의 사용자가 동시에 스트리밍을 시도하면 &lt;strong&gt;대역폭이 고갈&lt;/strong&gt;될 위험&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;대규모-라이브-방송에-불완전함&quot;&gt;대규모 라이브 방송에 불완전함&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;예측 불가능한 대역폭 소모&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;HLS나 RTMP&lt;/strong&gt;의 예측 가능한 방식
        &lt;ul&gt;
          &lt;li&gt;HLS나 RTMP는 중앙 서버에서 스트리밍을 관리하고 일반적으로 미리 인코딩된 비디오 조각을 전송&lt;/li&gt;
          &lt;li&gt;스케일링 가능 : 수많은 사용자에게 콘텐츠를 효율적으로 배포할 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;WebRTC&lt;/strong&gt;는 미리 인코딩된 스트림을 사용하지 않기 때문에 대역폭이 비디오 품질과 사용자 수에 따라 즉각적으로 변동함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;webrtc보다-빠른-기술이-있을까&quot;&gt;WebRTC보다 빠른 기술이 있을까?&lt;/h2&gt;

&lt;h3 id=&quot;webtransport&quot;&gt;&lt;strong&gt;WebTransport&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;WebTransport는 UDP 기반으로 통신&lt;/li&gt;
  &lt;li&gt;WebRTC의 signaling 없이도 서버와의 실시간 데이터 교환 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러나 WebTransport는 아직 개발 단계이며, 안정적인 표준화가 이루어지지 않아 모든 브라우저에서의 지원이 불확실&lt;/p&gt;

&lt;p&gt;WebRTC처럼 실시간 오디오와 비디오 전송을 위한 최적화가 충분하지 않음&lt;/p&gt;

&lt;h3 id=&quot;hls-vs-webrtc-비교&quot;&gt;HLS vs WebRTC 비교&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;**HLS**(HTTP Live Streaming)와 **WebRTC**는 모두 실시간 스트리밍을 위한 기술이지만, **사용 목적**, **지연 시간**, **보안** 및 **호환성** 측면에서 큰 차이가 있습니다. 사용하려는 애플리케이션의 유형에 따라 각 기술의 장단점을 비교해보고 어떤 것이 더 적합한지 선택해야 합니다. 아래는 HLS와 WebRTC를 실시간 스트리밍 웹 서비스의 관점에서 비교한 것입니다.


### 1. 지연 시간

- **HLS**:
	- **지연 시간**: HLS는 HTTP 기반 프로토콜로 설계되어 있으며, **10~30초**의 지연 시간이 발생하는 것이 일반적입니다. 심지어 **저지연 HLS(LL-HLS)**를 사용하더라도 2~5초 정도의 지연 시간이 존재할 수 있습니다.
	- **용도**: 따라서 HLS는 실시간성이 요구되지 않는 스트리밍에 적합합니다. 예를 들어, 뉴스 방송, 스포츠 경기, 강의 등의 상황에서 몇 초 정도의 지연이 큰 문제가 되지 않는다면 HLS가 적합합니다.
- **WebRTC**:
	- **지연 시간**: WebRTC는 **1초 미만의 매우 낮은 지연 시간**을 목표로 설계되어, 실시간 인터랙티브한 통신에 적합합니다.
	- **용도**: 화상 회의, 게임 스트리밍, 실시간 원격 조작 등 **매우 빠른 반응**이 필요한 애플리케이션에 적합합니다. WebRTC의 P2P 연결 방식 덕분에 지연 시간을 최소화할 수 있습니다.

### 2. 사용 사례

- **HLS**:
	- **주로 대규모 시청자 대상의 스트리밍**: HLS는 대규모 스트리밍 서비스(예: YouTube, Twitch 등)에서 매우 효과적입니다. HTTP 기반이라 기존 **CDN(Content Delivery Network)** 인프라를 활용해 손쉽게 콘텐츠를 전송할 수 있으며, 수천에서 수백만 명의 시청자가 동시에 스트리밍을 보는 데 적합합니다.
	- **적응형 스트리밍**: 네트워크 상태에 따라 비디오 품질을 조정하는 **적응형 스트리밍**을 기본적으로 제공하므로, 시청자의 네트워크 환경에 맞춰 끊김 없이 서비스를 제공합니다.
- **WebRTC**:
	- **1:1 혹은 소규모 그룹 통신**: WebRTC는 **화상 통화**, **화상 회의**, **온라인 협업 툴** 등 소규모 실시간 커뮤니케이션에 최적화되어 있습니다. 또한, 게임 스트리밍과 같은 실시간 반응이 중요한 상황에도 적합합니다.
	- **P2P 연결**: WebRTC는 주로 **P2P 연결**을 통해 데이터를 직접 전송하므로 서버의 부하를 줄일 수 있지만, 대규모 시청자를 대상으로 하기에 효율적이지 않을 수 있습니다.

### 3. 확장성

- **HLS**:
	- **대규모 스트리밍에 최적**: HLS는 HTTP 기반이기 때문에 **CDN**을 사용하여 확장성을 쉽게 확보할 수 있습니다. 수천 명 이상의 사용자가 동시에 스트리밍을 소비할 수 있으며, 서버 부담을 덜 수 있습니다.
- **WebRTC**:
	- **제한된 확장성**: WebRTC는 브라우저 간 **P2P 연결**을 사용하므로, 직접 연결의 수가 증가할수록 확장성이 제한됩니다. 예를 들어, 많은 참가자 간의 연결이 필요하면 각 클라이언트의 네트워크 및 CPU 자원이 급격히 소모됩니다.
	- **SFU 사용**: 확장성을 늘리기 위해 **SFU(Selective Forwarding Unit)**를 도입하여 각 클라이언트가 모든 참가자와 직접 연결하지 않고 중앙 서버를 통해 연결을 관리할 수 있도록 할 수 있습니다. 이를 통해 약 100명 이상의 사용자까지 확장 가능합니다.

### 4. 네트워크 호환성 및 안정성

- **HLS**:
	- **HTTP 기반 전송**: HLS는 HTTP 기반이기 때문에, 대부분의 방화벽을 통과하고 네트워크 호환성이 매우 뛰어납니다.
	- **안정적**: HTTP와 TCP를 사용하여 데이터 전송이 신뢰적이며, 중간에 발생하는 패킷 손실을 재전송하는 메커니즘이 있어 안정적인 스트리밍을 제공합니다.
- **WebRTC**:
	- **NAT Traversal**: WebRTC는 P2P 연결을 위해 **STUN** 및 **TURN** 서버를 사용하여 NAT 뒤에 있는 클라이언트를 연결합니다. 하지만 네트워크 환경에 따라 연결 설정이 복잡해지거나 문제가 발생할 수 있습니다.
	- **UDP 기반 전송**: 주로 **UDP**를 사용하여 낮은 지연 시간을 제공하지만, 패킷 손실 시 재전송을 보장하지 않아 네트워크 상태가 좋지 않을 때 품질 저하가 발생할 수 있습니다.

### 5. 보안

- **HLS**:
	- **HTTPS와 함께 사용**: HLS는 HTTP 기반으로, **HTTPS**를 사용해 데이터를 암호화할 수 있습니다. 또한, **DRM(디지털 권리 관리)**과 함께 사용해 콘텐츠 보호를 구현할 수 있습니다.
- **WebRTC**:
	- **기본적으로 암호화된 통신**: WebRTC는 모든 오디오, 비디오, 데이터 스트림을 **DTLS**(Datagram Transport Layer Security)와 **SRTP**(Secure Real-Time Transport Protocol)를 사용해 암호화합니다. 기본적으로 강력한 보안이 내장되어 있습니다.

### 6. 브라우저 지원

- **HLS**:
	- **Safari와 iOS 네이티브 지원**: Apple 기기와 Safari 브라우저에서 기본적으로 지원하지만, Chrome, Firefox 등 다른 브라우저에서는 JavaScript 라이브러리(**hls.js**)가 필요합니다.
- **WebRTC**:
	- **모든 최신 브라우저 지원**: WebRTC는 **Chrome**, **Firefox**, **Safari**, **Edge** 등 대부분의 최신 브라우저에서 네이티브로 지원됩니다. 추가적인 플러그인이 필요 없이 실시간 통신 기능을 사용할 수 있습니다.

### 결론

- **HLS**는 **대규모 스트리밍**에 적합하며, 상대적으로 긴 지연 시간을 허용할 수 있는 **방송, 교육, 엔터테인먼트**와 같은 서비스에서 주로 사용됩니다. **HTTP 기반**이므로 네트워크 호환성이 높고, 기존 CDN 인프라를 활용할 수 있는 장점이 있습니다.
- **WebRTC**는 **즉각적인 반응이 필요한 실시간 인터랙티브 애플리케이션**에 적합합니다. **낮은 지연 시간**과 **보안성**을 갖추고 있어 **화상 회의, 실시간 통신, 온라인 협업 도구** 등에 적합하며, 브라우저에서 네이티브로 지원되는 장점이 있습니다. 다만, **확장성** 측면에서는 SFU와 같은 구조적 보완이 필요합니다.

따라서, **대규모 시청자와의 방송**에는 HLS가 적합하고, **소규모 실시간 상호작용**이나 **낮은 지연 시간이 필요한 서비스**에는 WebRTC가 더 나은 선택이 될 것입니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;3️⃣rtmp-real-time-messaging-protocol&quot;&gt;3️⃣ RTMP (Real-Time Messaging Protocol)&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;참고자료&lt;br /&gt;
&lt;a href=&quot;https://www.cdnetworks.com/ko/blog/media-delivery/what-is-rtmp-ingest/&quot;&gt;https://www.cdnetworks.com/ko/blog/media-delivery/what-is-rtmp-ingest/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://ossrs.net/lts/en-us/docs/v6/doc/flv&quot;&gt;https://ossrs.net/lts/en-us/docs/v6/doc/flv&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://growthvalue.tistory.com/178&quot;&gt;https://growthvalue.tistory.com/178&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://ossrs.net/lts/en-us/docs/v4/doc/delivery-http-flv&quot;&gt;https://ossrs.net/lts/en-us/docs/v4/doc/delivery-http-flv&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://medium.com/@delivalue100/rtmp-realtime-messaging-protocol-c4474e464ffd&quot;&gt;https://medium.com/@delivalue100/rtmp-realtime-messaging-protocol-c4474e464ffd&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://obsproject.com/forum/whats-new/posts/2763754/&quot;&gt;https://obsproject.com/forum/whats-new/posts/2763754/&lt;/a&gt; - OBS 포럼 &lt;br /&gt;
&lt;a href=&quot;https://devocean.sk.com/blog/techBoardDetail.do?ID=164296&quot;&gt;https://devocean.sk.com/blog/techBoardDetail.do?ID=164296&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.naver.com/mingyo01/222050438291&quot;&gt;https://blog.naver.com/mingyo01/222050438291&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://velog.io/@chosj1526/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8A%B8%EC%9C%84%EC%B9%98-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%94%94%EC%9E%90%EC%9D%B8&quot;&gt;https://velog.io/@chosj1526/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8A%B8%EC%9C%84%EC%B9%98-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%94%94%EC%9E%90%EC%9D%B8&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;개요&quot;&gt;&lt;strong&gt;개요&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/7.png&quot; alt=&quot;7&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/8.png&quot; alt=&quot;8&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;개발자:&lt;/strong&gt; Adobe Systems (원래 Macromedia가 개발)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;출시 시기:&lt;/strong&gt; 2003년&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;주요 용도:&lt;/strong&gt; 실시간 비디오 및 오디오 스트리밍, 특히 라이브 방송&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;특징:&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;어도브에서 규정한 만큼 기존에는 Flash Player을 지원하기 위해 작성된 기술이었다.&lt;/p&gt;

    &lt;p&gt;그러나 최근 어도브에서 Flash Player의 지원을 중단한 만큼 점차 사용률이 저조해지고 있다.&lt;/p&gt;

    &lt;p&gt;하지만 이는 클라이언트 단에서의 문제점이고, 영상 데이터를 서버로 옮기고 저장하는 데에 있어서는 높은 지연 시간과 효율을 가지고 있기에, HLS, MPEG-DASH, HTTP-FLV와 같은 기술과 함께 사용된다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;저지연 스트리밍:&lt;/strong&gt; 실시간 스트리밍에 적합한 낮은 지연 시간&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;양방향 통신:&lt;/strong&gt; 클라이언트와 서버 간의 실시간 데이터 전송 가능&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;유연성:&lt;/strong&gt; 비디오, 오디오, 데이터 스트림을 동시에 전송&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;지연시간이-빠른-이유&quot;&gt;지연시간이 빠른 이유&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;지속적인 연결 유지&lt;/strong&gt;: RTMP는 클라이언트와 서버 간에 &lt;strong&gt;지속적인 TCP 연결&lt;/strong&gt;을 유지합니다. 이는 데이터 전송 시마다 새로운 연결을 설정할 필요가 없기 때문에 &lt;strong&gt;연결 설정에 따른 오버헤드&lt;/strong&gt;를 줄여줍니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;작은 청크(chunk) 단위 전송&lt;/strong&gt;: 데이터를 &lt;strong&gt;작은 청크로 분할하여 전송&lt;/strong&gt;함으로써, 데이터가 준비되는 즉시 전송할 수 있습니다. 이는 &lt;strong&gt;버퍼링 시간을 최소화&lt;/strong&gt;하고, 실시간 성능을 향상시킵니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;트위치의 경우 스트리머 → Ingest → Transcode → Replication → Edge → 시청자를 거치며 스트리밍 데이터를 전송&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/9.png&quot; alt=&quot;9&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Ingest - 스트리머의 비디오 영상이 트위치 데이터 센터로 가는 것&lt;/li&gt;
  &lt;li&gt;Transcode - 비디오 형식을 바꾸는 것&lt;/li&gt;
  &lt;li&gt;Replication - 복사. 안정성을 위해&lt;/li&gt;
  &lt;li&gt;Edge - CDN이라고도 부름&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/10.png&quot; alt=&quot;10&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/11.png&quot; alt=&quot;11&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;한계점&quot;&gt;&lt;strong&gt;한계점&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;보안:&lt;/strong&gt; 기본적으로 보안 기능이 내장되어 있지 않아 데이터 암호화가 필요할 경우 추가 설정이 필요함&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;방화벽 문제:&lt;/strong&gt; 전용 포트(기본적으로 1935)를 사용하므로 일부 네트워크 환경에서는 차단될 수 있음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;모바일 지원 부족:&lt;/strong&gt; HTTP 기반 스트리밍 프로토콜(HLS, MPEG-DASH)에 비해 모바일 기기에서의 지원이 제한적&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;확장성:&lt;/strong&gt; 대규모&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;4️⃣srt-secure-reliable-transport&quot;&gt;&lt;strong&gt;4️⃣ SRT (Secure Reliable Transport)&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;OBS 사용&lt;/p&gt;

&lt;h2 id=&quot;개요-1&quot;&gt;&lt;strong&gt;개요&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;개발자:&lt;/strong&gt; Haivision&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;출시 시기:&lt;/strong&gt; 2017년&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;주요 용도:&lt;/strong&gt; 불안정한 네트워크 환경에서도 안정적이고 보안이 강화된 비디오 스트리밍&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;특징:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;보안 강화:&lt;/strong&gt; AES 암호화를 통해 데이터 전송 시 보안을 보장&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;신뢰성:&lt;/strong&gt; 패킷 손실, 지연, 네트워크 변동성에 강한 내성을 가짐&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;적응성:&lt;/strong&gt; 다양한 네트워크 조건에 맞춰 동적으로 조정&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;오픈 소스:&lt;/strong&gt; SRT는 오픈 소스 프로젝트로, 다양한 플랫폼과 쉽게 통합 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;srt의-주요-기능&quot;&gt;&lt;strong&gt;SRT의 주요 기능&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;암호화:&lt;/strong&gt; 전송 중인 데이터를 암호화하여 도청 및 데이터 변조를 방지&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;재전송 메커니즘:&lt;/strong&gt; 패킷 손실 시 재전송을 통해 데이터의 완전성을 유지&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;동적 비트레이트 조정:&lt;/strong&gt; 네트워크 상태에 따라 비트레이트를 자동으로 조정하여 스트리밍 품질을 최적화&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;방화벽 우회:&lt;/strong&gt; UDP 기반이지만, NAT 및 방화벽 환경에서도 안정적으로 동작&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;장점&quot;&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;보안:&lt;/strong&gt; RTMP와 달리 기본적으로 데이터 암호화를 지원하여 보안성이 뛰어남&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;신뢰성:&lt;/strong&gt; 불안정한 네트워크 환경에서도 안정적인 데이터 전송을 보장&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유연성:&lt;/strong&gt; 다양한 네트워크 조건에 적응하여 최적의 스트리밍 품질 제공&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;확장성:&lt;/strong&gt; 대규모 스트리밍 환경에서도 효율적으로 확장 가능&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;오픈 소스:&lt;/strong&gt; 무료로 사용 가능하며, 커뮤니티 지원을 통해 지속적으로 개선됨&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;단점&quot;&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;채택률:&lt;/strong&gt; RTMP에 비해 상대적으로 최근에 등장한 프로토콜로, 기존 인프라와의 호환성 문제 발생 가능&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;설정 복잡성:&lt;/strong&gt; 초기 설정과 최적화를 위해 기술적인 지식이 필요할 수 있음&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;rtmp와-srt의-비교&quot;&gt;&lt;strong&gt;RTMP와 SRT의 비교&lt;/strong&gt;&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;RTMP&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;SRT&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;보안&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;기본적으로 보안 기능 없음 (RTMPS로 보안 강화 가능)&lt;/td&gt;
      &lt;td&gt;AES 암호화 내장, 기본적으로 보안 강화&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;전송 프로토콜&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;TCP 기반&lt;/td&gt;
      &lt;td&gt;UDP 기반&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;신뢰성&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;TCP의 신뢰성 제공, 그러나 네트워크 변동성에 취약&lt;/td&gt;
      &lt;td&gt;패킷 손실 복구, 네트워크 변동성에 강한 내성&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;지연 시간&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;낮음&lt;/td&gt;
      &lt;td&gt;낮음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;방화벽 우회&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;전용 포트 사용, 방화벽 문제 발생 가능&lt;/td&gt;
      &lt;td&gt;NAT 및 방화벽 환경에서도 안정적 동작&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;확장성&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;대규모 분산 환경에서 추가 설정 필요&lt;/td&gt;
      &lt;td&gt;대규모 스트리밍 환경에서 효율적으로 확장 가능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;오픈 소스&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;아니오&lt;/td&gt;
      &lt;td&gt;예 (오픈 소스 프로젝트)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;5️⃣mpeg-dash-dynamic-adaptive-streaming-over-http&quot;&gt;&lt;strong&gt;5️⃣ MPEG-DASH (Dynamic Adaptive Streaming over HTTP)&lt;/strong&gt;&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;설명:&lt;/strong&gt; ISO 표준의 HTTP 기반 스트리밍 프로토콜로, 적응형 비트레이트를 지원하며 다양한 미디어 형식을 지원합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;특징:&lt;/strong&gt; 개방형 표준, 다양한 플랫폼과 호환.&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;summary&gt;정리글 원본&lt;/summary&gt;

## 고민지

	- **HLS** **- 지연시간이 높지만 호환성이 좋음 (치지직)**
		- 왜 다른 프로토콜에 비해 지연시간이 길까?
		- 어떻게 지연시간을 낮출 수 있을까?

	### 왜 만들어졌을까? feat. RTSP

	- RTSP는 고정된 비트레이트로 콘텐츠 스트리밍에 최적화
		- 고정 비트레이트의 경우 한가지 속도로만 데이터를 전송하다 보니 네트워크 상태가 변할 때에도 동일한 비트레이트로 스트리밍을 유지해야한다는 문제가 있음

		⇒ 따라서 호환성이 높은 HTTP를 기반으로, **네트워크 상태에 따라 비디오 품질을 실시간으로 조정** 가능한 **가변 비트레이트** 기능까지 도입된 것이 **HLS**


	### HLS(Hypertext Live Streaming)

	- HTTP기반의 단방향 미디어 스트리밍 프로토콜
	- 일반 웹서버 + CDN을 활용해 콘텐츠 배포

	### 왜 다른 프로토콜에 비해 지연시간이 길까?


	![12](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/12.png)_image.png_


	지연시간이 긴 것에는 다양한 원인이 있었음

	1. 동작 방식으로 인한 지연
		1. 서버에서 스트리밍할 비디오 파일을 짧은 세그먼트(2~10초)로 분할 
		→ 재생을 시작하기 위해선 **적어도 몇 개의 세그먼트가 필요해 초기 버퍼링 시간이 길어짐** (세그먼트 길이가 길수록 지연이 커질 수 있음)
		⇒ CDN으로 세그먼트 캐싱해서 데이터 전송 시간을 개선하려함
	2. HTTP 기반 요청-응답 지연
		1. HTTP 기반이므로 **각 세그먼트 마다 서버에 요청을 보내고 응답을 기다리는 시간**이 필요. 네트워크의 상태나 응답 속도에 종속
	3. 가변 비트레이트 지연
		1. 네트워크 상태에 따라 **최적의 비트레이트를 선택하기 위한 모니터링** 진행 
		→ 이 과정에서 비트레이트를 전환하며 지연이 발생함 
		⇒ 지연이 시청 환경을 개선하지만 실시간성에서는 불리함!
	4. CDN 캐싱과 서버 최적화 이슈
		1. 세그먼트 파일이 여러 서버에 캐시되어도 여전히 HTTP 기반으로 동작해 추가적인 통신과정 필요
		2. 특히 사용자 많은 라이브방송에서는 CDN이 적절히 분배되지 않으면 지연 발생

	⇒ 따라서 HLS는 라이브 스트리밍보다는 정적 비디오 플레이어에 더 적합


	### 치지직에서의 HLS 사용법


	[https://medium.com/@delivalue100/hls-http-live-streaming-4fb1d2992d57](https://medium.com/@delivalue100/hls-http-live-streaming-4fb1d2992d57)


	![13](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/13.png)_image.png_


	⇒ 결국 클라이언트가 플레이리스트의 미디어 세그먼트들을 순차적으로 GET하고 마지막쯤에 새로운 세그먼트를 요청하는 흐름이기 때문에 **단방향 통신으로 동작한다.**


	+) 뒤로 돌려보기 안되는 이유..? 돌려보기 자체에 리소스 소모가 큰듯. 그냥 방송 종료 후 다시보기 기능을 넣는게 이득


	### 지연시간 어떻게 개선할 수 있을까?


	[https://www.cdnetworks.com/ko/blog/media-delivery/http-live-streaming/](https://www.cdnetworks.com/ko/blog/media-delivery/http-live-streaming/)

	1. 세그먼트 길이 단축
		1. 6초 이상의 기본적인 세그먼트 길이를 2~1초로 줄이기
			1. 짧아질수록 서버와 클라이언트 사이에 요청이 많아 부하가 생길 수 있으니 균형점을 찾아야함
	2. LL-HLS 도입
		1. 애플이 개발한 HLS의 초저지연 버전
		2. 세그먼트 내에서 더 작은 단위인 파트로 나눠 전송하며, 세그먼트가 완전히 준비되지 않아도 일부를 먼저 전송함
	3. 세그먼트 프리페칭
		1. 클라이언트가 다음 세그먼트를 미리 예측하고 사전 다운로드
	4. 송출 환경 최적화
		1. 치지직 공지사항을 보니 송출 프로그램을 최적화하는 방법도..
		2. 스트리머가 키프레임 간격을 너무 짧게 설정 →세그먼트가 너무 짧아짐, 서버 부하 ⇒ 버퍼링 많아짐 이슈인듯
			1. [https://help.naver.com/notice/noticeView.help?noticeNo=17188&amp;amp;serviceNo=23946&amp;amp;lang=ko](https://help.naver.com/notice/noticeView.help?noticeNo=17188&amp;amp;serviceNo=23946&amp;amp;lang=ko)

	### 치지직의 경우


	기존에 화질이 깨지는 문제 → 서버 부하 이슈로 움직임이 적은 장면에서는 낮은 비트레이트, 빠르게 변하는 장면에서는 높은 비트레이트를 사용해 빠르게 변하는 장면에서 품질이 저하되도록 함.


	⇒ 이후에 서버 장비 도입으로 화질 제한을 풀고 원본 화질에 가깝게 (OBS로 스트리머가 송출하는 화질) 비디오를 전송


	여기서 든 생각 → 어차피 우리의 타겟은 컨퍼런스 발표임, 정적인 장면이 많은 콘텐츠. 초기 치지직 방식대로 낮은 비트레이트를 유지해도 화질 문제는 없을 것 같음. 프레임율 낮추고..


	### 결론

	- **높은 비트레이트와 긴 세그먼트**: 높은 비트레이트를 사용하면서 긴 세그먼트를 전송할 경우, 네트워크 대역폭을 효율적으로 사용할 수 있지만, 지연 시간이 증가. 특히 불안정한 네트워크에서는 재생 품질이 저하됨.
	- **낮은 비트레이트와 짧은 세그먼트**: 낮은 비트레이트와 짧은 세그먼트를 조합하면, 재생 안정성이 높아지고 지연 시간 감소, 비디오 품질은 저하. ⇒ 이게 우리서비스에 적합하지 않을까?

	### 비트레이트랑 세그먼트 조정 어케함?

	1. 비트레이트
		1. `m3u8` 플레이리스트 파일 수정
			1. `EXT-X-STREAM-INF` 태그를 사용하여 비트레이트를 설정

			
```
text
			#EXTM3U
			#EXT-X-VERSION:3
			
			#EXT-X-STREAM-INF:BANDWIDTH=1500000
			# 이 스트림에 대한 메타데이터를 정의
			# BANDWIDTH=1500000은 이 스트림의 대역폭 요구 사항이 1,500,000 비트(1.5 Mbps)임을 나타냄
			
			stream_1500.m3u8
			
```


	2. 세그먼트
		1. FFmpeg로 비디오를 여러 해상도로 인코딩할 때 `-hls_time`을 사용하여 세그먼트의 길이를 설정 (기본 10초)
		2. [https://frontdev.tistory.com/entry/ffmpeg%EB%A1%9C-hls-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EC%98%B5%EC%85%98%EC%A0%95%EB%A6%AC](https://frontdev.tistory.com/entry/ffmpeg%EB%A1%9C-hls-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EC%98%B5%EC%85%98%EC%A0%95%EB%A6%AC)

			
```
text
			- ffmpeg -i hasashin.mp4 -b:v 1M -g 60 -hls_time 2 -hls_list_size 0 -hls_segment_size 500000 output.m3u8
			출처: https://frontdev.tistory.com/entry/ffmpeg로-hls-만들기-옵션정리 [Front End Develop:티스토리]
			
```



## 김영길


	[https://velog.io/@devstefancho/obs-RTMP-%EC%84%9C%EB%B2%84%EB%A1%9C-Live-Streaming](https://velog.io/@devstefancho/obs-RTMP-%EC%84%9C%EB%B2%84%EB%A1%9C-Live-Streaming)


	[https://www.cloudflare.com/ko-kr/learning/video/what-is-http-live-streaming/](https://www.cloudflare.com/ko-kr/learning/video/what-is-http-live-streaming/)


	HLS 는 apple 의 기술이라서 apple 기기에 전부 호환


	반대로 안드로이드나 윈도우에서는 추가적인 로직 필요


	[비디오 → HTTP 파일 조각으로 나눔 → 전송 →] 재생


	HTTP 파일로 나누기 때문에 별도의 전용 서버가 필요하지 않다.


	![14](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/14.png)_image.png_


	![15](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/15.png)_image.png_

	- m3u8 : 메타데이터
		- 시작 태그
		- hls 프로토콜 버전
		- 세그먼트의 최대 길이
		- 첫 번째 세그먼트의 시퀀스 번호
		- 실제 세그먼트의 길이, 다음 세그먼트 인덱스
		- 종료 태그
	- ts : 실제 비디오의 조각들을 담고 있는 컨테이너

	LL-HLS : 저지연


	어떻게 지연 속도를 줄였나


	###  `세그먼트를 또 나누기 -&amp;gt; chunk`


	![16](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/16.png)_image.png_

	- 하나당 10초 정도인 ts 가 아닌 1초 이하 정도의 CMAF 컨테이너에 담아서 생성 즉시 전송한다.

	ㅅ또한 m3u8 파일에 추가적인 메타데이터가 들어간다.


	### 2.1 미디어 변경 또는 광고

	- **#EXT-X-DISCONTINUITY**: 이전 세그먼트와의 **연속성이 끊어짐**을 표시합니다. 이는 광고와 같은 **다른 유형의 미디어를 삽입**할 때 사용됩니다.

		
```
text
		m3u8
		#EXT-X-DISCONTINUITY
		
```


		- **예시**: 이 태그 뒤에 오는 세그먼트는 이전 미디어와는 다르게 인코딩되었거나 다른 타입의 미디어임을 의미합니다.

	### 2.2 변수 비트레이트 및 다중 스트림

	- **#EXT-X-STREAM-INF**: **다중 비트레이트 스트림** 또는 **적응형 스트리밍**을 위해 사용됩니다. 여러 비트레이트를 가진 대체 스트림이 있을 때, 클라이언트가 네트워크 상태에 따라 적절한 스트림을 선택할 수 있도록 합니다.

		
```
text
		m3u8
		#EXT-X-STREAM-INF:BANDWIDTH=800000,RESOLUTION=640x360
		low.m3u8
		#EXT-X-STREAM-INF:BANDWIDTH=1500000,RESOLUTION=1280x720
		medium.m3u8
		
```


		- **예시**: 800kbps, 1500kbps로 각각 다른 해상도의 스트림을 제공합니다. 클라이언트는 네트워크 상황에 따라 적절한 `m3u8` 파일을 선택하게 됩니다.

	### 2.3 키 프레임 및 암호화

	- **#EXT-X-KEY**: 세그먼트의 **암호화 키 정보**를 제공합니다. HLS에서는 콘텐츠 보호를 위해 **AES-128 암호화**를 사용하여 세그먼트를 암호화할 수 있습니다.

		
```
text
		m3u8
		#EXT-X-KEY:METHOD=AES-128,URI=&quot;https://example.com/key&quot;
		
```


		- **예시**: 세그먼트를 AES-128로 암호화하며, 암호화 키를 가져올 위치는 `https://example.com/key`입니다.

	### 2.4 LL-HLS 관련 메타데이터

	- **#EXT-X-PART-INF**: **저지연 HLS**에서 사용되는 태그로, 세그먼트가 **파편(chunk)**으로 나뉘어 전송되는 경우 각 파편의 정보를 포함합니다.

		
```
text
		m3u8
		#EXT-X-PART-INF:PART-TARGET=1.0
		
```


		- **예시**: 각 파편의 타겟 길이가 **1초**임을 의미합니다.
	- **#EXT-X-PRELOAD-HINT**: LL-HLS에서 아직 완료되지 않은 세그먼트나 파편에 대해 **미리 가져올 힌트**를 제공합니다. 이를 통해 클라이언트가 지연 시간을 줄이기 위해 미리 준비할 수 있습니다.

		
```
text
		m3u8
		#EXT-X-PRELOAD-HINT:TYPE=PART,URI=&quot;segment3_part1.ts&quot;
		
```


		- **예시**: `segment3_part1.ts` 파편을 미리 로드할 힌트입니다.

	### `응답 지연`


	저번 금요일에 회고 시간에,  Short Polling, Long Polling 이 나왔던 적이 있었는데 이와 비슷한 방식으로 지연 시간을 줄였다고 보면 쉬울 것 같다.


	Short Polling 은 주기적으로 서버에 요청을 보내서 업데이트 된 사항이 있는지를 체크한다. 만약 업데이트된 사항이 없다면 서버는 304(Not Modified), 200 를 반환한다.


	이때 클라이언트는 업데이트된 사항이 있을 때 까지 또 요청을 보낸다.


	Long Polling (200) 은 클라이언트가 서버에 요청을 보냈을 때, 업데이트가 되기 전까지는 서버가 응답을 되돌려주지 않고 연결을 유지(지연)하다가, 업데이트가 된 순간 응답을 보낸다. 


	기존 HLS는 메타데이터(플레이리스트) 인 .m3u8 파일을 지속적으로 서버에 요청해서 .m3u8 을 토대로 세그먼트를 재생하는 방식인데, `지속적으로 서버에 요청` 이 과정이 지연시간의 주범이다. 이 시간 동안 클라이언트는 세그먼트를 받는게 아니라 대기를 해버리기 때문에, 실제 동영상 파일인 세그먼트를 업데이트가 되고 나서야 받을 수 있다.


	기존 HLS 는 HTTP 요청을 주기적으로 보내서 .m3u8 이 업데이트가 되었는지 확인을 한다. 만약 업데이트가 되지 않았다면 또 서버에 요청을 보내고, 업데이트가 되었다는 응답을 받고 나서야 실제 스트리밍 데이터인 세그먼트를 받아온다. 


	LL-HLS 는 

	- **클라이언트의 플레이리스트 요청**:
		- 클라이언트가 서버에 `.m3u8` **플레이리스트**를 요청합니다. 이때 클라이언트는 **최신 세그먼트**를 가져오기를 원합니다.
	- **서버의 요청 지연(Blocking)**:
		- 만약 서버에 **새로운 세그먼트**가 아직 생성되지 않은 경우, 서버는 즉시 응답을 하지 않고 요청을 **일정 시간 동안 대기(Blocking)** 시킵니다. 이 대기 시간 동안 서버는 새로운 세그먼트가 생성되기를 기다립니다.
	- **새로운 세그먼트 생성 시 응답**:
		- 새로운 세그먼트가 생성되면 서버는 대기 중인 클라이언트의 요청에 응답하여 **최신 플레이리스트**를 반환합니다. 클라이언트는 이를 통해 바로 다음 세그먼트를 가져가 재생을 시작할 수 있습니다.
	- **업데이트 주기 단축**:
		- 이러한 방식은 기존의 주기적인 폴링 방식보다 **지연 시간**을 훨씬 줄일 수 있습니다. 즉, 클라이언트가 계속해서 플레이리스트를 요청하여 최신 정보를 받기 위해 대기하지 않도록 하여 지연 시간을 줄입니다.

	### `서버의 부하`


	LL-HLS 는 세그먼트를 더 짧게 생성하기 때문에 당연히 세그먼트를 더 자주 생성하게 되고, m3u8 의 업데이트도 더 많이 일어난다. 따라서 서버의 부담이 증가하게 된다.


	서버의 부담을 줄이는 방법은 있을까?


	### 2. 서버 부하를 줄이기 위한 방안

	1. **CDN(Content Delivery Network) 사용**
		- **LL-HLS**에서 서버 부하를 줄이기 위해 가장 많이 사용되는 방법 중 하나는 **CDN**을 사용하는 것입니다. CDN은 스트리밍 콘텐츠를 여러 지점에 **캐시**하고, 지리적으로 가까운 사용자에게 콘텐츠를 제공함으로써 **서버의 부하를 분산**시킵니다.
		- CDN을 사용하면 클라이언트가 직접 서버에 연결하는 대신 CDN에서 콘텐츠를 받아가므로, **서버의 직접적인 요청 수**를 줄일 수 있습니다.
	2. **효율적인 세그먼트 생성 및 캐싱**
		- 서버는 세그먼트를 효율적으로 생성하고, **재사용 가능한 세그먼트를 캐싱**함으로써 부하를 줄일 수 있습니다. 특히, 플레이리스트와 세그먼트가 자주 변경되기 때문에, 이를 적절히 캐싱하여 동일한 콘텐츠를 여러 클라이언트가 요청하는 경우 서버에서 재생성할 필요가 없도록 해야 합니다.
	3. **최적의 플레이리스트 및 세그먼트 길이 조정**
		- LL-HLS에서는 지연 시간을 줄이기 위해 세그먼트를 작은 크기로 나누지만, **너무 작은 단위의 세그먼트**는 서버 부하를 크게 증가시킬 수 있습니다. 따라서 **적절한 세그먼트 길이**와 **플레이리스트 갱신 주기**를 설정하여 서버 부하와 지연 시간을 균형 있게 맞추는 것이 중요합니다.

	대신 safari 를 제외한 브라우저에서는 &lt;video&gt; 태그만으로는 재생이 불가능하다. HLS 스트림 변환이 필요하다.

	- hls.js → hls 스트림을 브라우저가 이해할 수 있는 포맷으로 변환하여 &lt;video&gt; 요소에 전달하는 라이브러리
	- 지연시간이 왜 많이 생기는가?
		- UDP 를 사용하는 다른 프로토콜들과 달리 HLS 는 `TCP` 를 사용한다.
		- HLS 는 오히려 실시간에 집중하기 보다는 데이터의 신뢰성과 효율성에 집중한 프로토콜이다.
	- **저지연 HLS(LL-HLS)**
	- [https://medium.com/@cwh./%EB%8F%99%EC%98%81%EC%83%81-%EC%95%88%EB%81%8A%EA%B8%B0%EA%B3%A0-%EB%B3%B4%EB%8A%94%EB%B2%95-feat-ll-hls-a6a0c453b21f](https://medium.com/@cwh./%EB%8F%99%EC%98%81%EC%83%81-%EC%95%88%EB%81%8A%EA%B8%B0%EA%B3%A0-%EB%B3%B4%EB%8A%94%EB%B2%95-feat-ll-hls-a6a0c453b21f)
&lt;details&gt;
&lt;summary&gt;HLS vs WebRTC&lt;/summary&gt;

**HLS**(HTTP Live Streaming)와 **WebRTC**는 모두 실시간 스트리밍을 위한 기술이지만, **사용 목적**, **지연 시간**, **보안** 및 **호환성** 측면에서 큰 차이가 있습니다. 사용하려는 애플리케이션의 유형에 따라 각 기술의 장단점을 비교해보고 어떤 것이 더 적합한지 선택해야 합니다. 아래는 HLS와 WebRTC를 실시간 스트리밍 웹 서비스의 관점에서 비교한 것입니다.


### 1. 지연 시간

- **HLS**:
	- **지연 시간**: HLS는 HTTP 기반 프로토콜로 설계되어 있으며, **10~30초**의 지연 시간이 발생하는 것이 일반적입니다. 심지어 **저지연 HLS(LL-HLS)**를 사용하더라도 2~5초 정도의 지연 시간이 존재할 수 있습니다.
	- **용도**: 따라서 HLS는 실시간성이 요구되지 않는 스트리밍에 적합합니다. 예를 들어, 뉴스 방송, 스포츠 경기, 강의 등의 상황에서 몇 초 정도의 지연이 큰 문제가 되지 않는다면 HLS가 적합합니다.
- **WebRTC**:
	- **지연 시간**: WebRTC는 **1초 미만의 매우 낮은 지연 시간**을 목표로 설계되어, 실시간 인터랙티브한 통신에 적합합니다.
	- **용도**: 화상 회의, 게임 스트리밍, 실시간 원격 조작 등 **매우 빠른 반응**이 필요한 애플리케이션에 적합합니다. WebRTC의 P2P 연결 방식 덕분에 지연 시간을 최소화할 수 있습니다.

### 2. 사용 사례

- **HLS**:
	- **주로 대규모 시청자 대상의 스트리밍**: HLS는 대규모 스트리밍 서비스(예: YouTube, Twitch 등)에서 매우 효과적입니다. HTTP 기반이라 기존 **CDN(Content Delivery Network)** 인프라를 활용해 손쉽게 콘텐츠를 전송할 수 있으며, 수천에서 수백만 명의 시청자가 동시에 스트리밍을 보는 데 적합합니다.
	- **적응형 스트리밍**: 네트워크 상태에 따라 비디오 품질을 조정하는 **적응형 스트리밍**을 기본적으로 제공하므로, 시청자의 네트워크 환경에 맞춰 끊김 없이 서비스를 제공합니다.
- **WebRTC**:
	- **1:1 혹은 소규모 그룹 통신**: WebRTC는 **화상 통화**, **화상 회의**, **온라인 협업 툴** 등 소규모 실시간 커뮤니케이션에 최적화되어 있습니다. 또한, 게임 스트리밍과 같은 실시간 반응이 중요한 상황에도 적합합니다.
	- **P2P 연결**: WebRTC는 주로 **P2P 연결**을 통해 데이터를 직접 전송하므로 서버의 부하를 줄일 수 있지만, 대규모 시청자를 대상으로 하기에 효율적이지 않을 수 있습니다.

### 3. 확장성

- **HLS**:
	- **대규모 스트리밍에 최적**: HLS는 HTTP 기반이기 때문에 **CDN**을 사용하여 확장성을 쉽게 확보할 수 있습니다. 수천 명 이상의 사용자가 동시에 스트리밍을 소비할 수 있으며, 서버 부담을 덜 수 있습니다.
- **WebRTC**:
	- **제한된 확장성**: WebRTC는 브라우저 간 **P2P 연결**을 사용하므로, 직접 연결의 수가 증가할수록 확장성이 제한됩니다. 예를 들어, 많은 참가자 간의 연결이 필요하면 각 클라이언트의 네트워크 및 CPU 자원이 급격히 소모됩니다.
	- **SFU 사용**: 확장성을 늘리기 위해 **SFU(Selective Forwarding Unit)**를 도입하여 각 클라이언트가 모든 참가자와 직접 연결하지 않고 중앙 서버를 통해 연결을 관리할 수 있도록 할 수 있습니다. 이를 통해 약 100명 이상의 사용자까지 확장 가능합니다.

### 4. 네트워크 호환성 및 안정성

- **HLS**:
	- **HTTP 기반 전송**: HLS는 HTTP 기반이기 때문에, 대부분의 방화벽을 통과하고 네트워크 호환성이 매우 뛰어납니다.
	- **안정적**: HTTP와 TCP를 사용하여 데이터 전송이 신뢰적이며, 중간에 발생하는 패킷 손실을 재전송하는 메커니즘이 있어 안정적인 스트리밍을 제공합니다.
- **WebRTC**:
	- **NAT Traversal**: WebRTC는 P2P 연결을 위해 **STUN** 및 **TURN** 서버를 사용하여 NAT 뒤에 있는 클라이언트를 연결합니다. 하지만 네트워크 환경에 따라 연결 설정이 복잡해지거나 문제가 발생할 수 있습니다.
	- **UDP 기반 전송**: 주로 **UDP**를 사용하여 낮은 지연 시간을 제공하지만, 패킷 손실 시 재전송을 보장하지 않아 네트워크 상태가 좋지 않을 때 품질 저하가 발생할 수 있습니다.

### 5. 보안

- **HLS**:
	- **HTTPS와 함께 사용**: HLS는 HTTP 기반으로, **HTTPS**를 사용해 데이터를 암호화할 수 있습니다. 또한, **DRM(디지털 권리 관리)**과 함께 사용해 콘텐츠 보호를 구현할 수 있습니다.
- **WebRTC**:
	- **기본적으로 암호화된 통신**: WebRTC는 모든 오디오, 비디오, 데이터 스트림을 **DTLS**(Datagram Transport Layer Security)와 **SRTP**(Secure Real-Time Transport Protocol)를 사용해 암호화합니다. 기본적으로 강력한 보안이 내장되어 있습니다.

### 6. 브라우저 지원

- **HLS**:
	- **Safari와 iOS 네이티브 지원**: Apple 기기와 Safari 브라우저에서 기본적으로 지원하지만, Chrome, Firefox 등 다른 브라우저에서는 JavaScript 라이브러리(**hls.js**)가 필요합니다.
- **WebRTC**:
	- **모든 최신 브라우저 지원**: WebRTC는 **Chrome**, **Firefox**, **Safari**, **Edge** 등 대부분의 최신 브라우저에서 네이티브로 지원됩니다. 추가적인 플러그인이 필요 없이 실시간 통신 기능을 사용할 수 있습니다.

### 결론

- **HLS**는 **대규모 스트리밍**에 적합하며, 상대적으로 긴 지연 시간을 허용할 수 있는 **방송, 교육, 엔터테인먼트**와 같은 서비스에서 주로 사용됩니다. **HTTP 기반**이므로 네트워크 호환성이 높고, 기존 CDN 인프라를 활용할 수 있는 장점이 있습니다.
- **WebRTC**는 **즉각적인 반응이 필요한 실시간 인터랙티브 애플리케이션**에 적합합니다. **낮은 지연 시간**과 **보안성**을 갖추고 있어 **화상 회의, 실시간 통신, 온라인 협업 도구** 등에 적합하며, 브라우저에서 네이티브로 지원되는 장점이 있습니다. 다만, **확장성** 측면에서는 SFU와 같은 구조적 보완이 필요합니다.

따라서, **대규모 시청자와의 방송**에는 HLS가 적합하고, **소규모 실시간 상호작용**이나 **낮은 지연 시간이 필요한 서비스**에는 WebRTC가 더 나은 선택이 될 것입니다.


&lt;/details&gt;


## 홍창현


	# WebRTC (Web Real-Time Communication)


	웹 브라우저 간에 플러그인의 도움 없이 서로 통신할 수 있도록 설계된 **Javascript API**


	→ 별다른 소프트웨어 없이 카메라, 마이크 등을 사용하여 실시간 커뮤니케이션을 제공


	음성 통화, 영상 통화, P2P 파일 공유 등으로 활용됨


	## WebRTC의 장점


	### WebRTC는 낮은 Latency를 갖는다

	- WebRTC는 **`P2P(peer-to-peer)방식`**으로 데이터를 전송
		- **P2P**는 **중간 서버**를 거치지 않음
	- WebRTC는 **UDP 기반**으로 작동하여 신속하게 패킷을 전송
		- HLS와 RTMP는 **TCP 기반**

	### WebRTC는 호환성이 높다


	![17](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/17.png)_image.png_


	## WebRTC의 단점


	### 많은 사용자가 사용할 수 없다 (스케일링 문제)

	- WebRTC는 P2P(peer-to-peer) 구조로 작동하기 때문에 각 사용자 간의 직접적인 연결을 설정
	- 사용자가 많아질수록 필요한 연결 수가 **기하급수적으로 증가**함

	![18](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/18.png)_image.png_

	- N명의 사용자가 있을 때 사용자 한명이 추가되면 N개의 연결이 필요
		- 서버와 클라이언트 모두에 큰 부담
		- 네트워크 대역폭과 성능 저하 초래

	### 화질 문제 (성능문제)

	- 실시간 비디오와 오디오 스트리밍을 위해 상당한 대역폭을 소모
	- 특히 고화질 비디오 스트림은 많은 대역폭을 요구
	- 대역폭이 제한된 환경에서는 **패킷 손실**이 발생할 수 있으며, 이는 전체 스트림의 품질 저하로 이어짐
		- WebRTC는 **UDP 기반**이므로 패킷 손실이 일어날 수 있음
	- 다수의 사용자가 동시에 스트리밍을 시도하면 **대역폭이 고갈**될 위험

	### 대규모 라이브 방송에 불완전함

	- **예측 불가능한 대역폭 소모**
		- **HLS나 RTMP**의 예측 가능한 방식
			- HLS나 RTMP는 중앙 서버에서 스트리밍을 관리하고 일반적으로 미리 인코딩된 비디오 조각을 전송
			- 스케일링 가능 : 수많은 사용자에게 콘텐츠를 효율적으로 배포할 수 있음
		- **WebRTC**는 미리 인코딩된 스트림을 사용하지 않기 때문에 대역폭이 비디오 품질과 사용자 수에 따라 즉각적으로 변동함

	## WebRTC보다 빠른 기술이 있을까?


	## **WebTransport**

	- WebTransport는 UDP 기반으로 통신
	- WebRTC의 signaling 없이도 서버와의 실시간 데이터 교환 가능

	그러나 WebTransport는 아직 개발 단계이며, 안정적인 표준화가 이루어지지 않아 모든 브라우저에서의 지원이 불확실


	WebRTC처럼 실시간 오디오와 비디오 전송을 위한 최적화가 충분하지 않음


## 김준서


	&amp;gt; 참고자료  
	&amp;gt; [https://www.cdnetworks.com/ko/blog/media-delivery/what-is-rtmp-ingest/](https://www.cdnetworks.com/ko/blog/media-delivery/what-is-rtmp-ingest/)  
	&amp;gt; [https://ossrs.net/lts/en-us/docs/v6/doc/flv](https://ossrs.net/lts/en-us/docs/v6/doc/flv)  
	&amp;gt; [https://growthvalue.tistory.com/178](https://growthvalue.tistory.com/178)  
	&amp;gt; [https://ossrs.net/lts/en-us/docs/v4/doc/delivery-http-flv](https://ossrs.net/lts/en-us/docs/v4/doc/delivery-http-flv)  
	&amp;gt; [https://medium.com/@delivalue100/rtmp-realtime-messaging-protocol-c4474e464ffd](https://medium.com/@delivalue100/rtmp-realtime-messaging-protocol-c4474e464ffd)  
	&amp;gt; [https://obsproject.com/forum/whats-new/posts/2763754/](https://obsproject.com/forum/whats-new/posts/2763754/) - OBS 포럼   
	&amp;gt; [https://devocean.sk.com/blog/techBoardDetail.do?ID=164296](https://devocean.sk.com/blog/techBoardDetail.do?ID=164296)  
	&amp;gt; [https://blog.naver.com/mingyo01/222050438291](https://blog.naver.com/mingyo01/222050438291)  
	&amp;gt; [https://velog.io/@chosj1526/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8A%B8%EC%9C%84%EC%B9%98-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%94%94%EC%9E%90%EC%9D%B8](https://velog.io/@chosj1526/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8A%B8%EC%9C%84%EC%B9%98-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%94%94%EC%9E%90%EC%9D%B8)


	### 용어 정리


	bitrate - 시간당 처리하는 비트의 수


	### RTMP


	어도브에서 규정한 오디오, 비디오 데이터 통신 기술을 의미한다.


	어도브에서 규정한 만큼 기존에는 Flash Player을 지원하기 위해 작성된 기술이었다.


	그러나 최근 어도브에서 Flash Player의 지원을 중단한 만큼 점차 사용률이 저조해지고 있다.


	하지만 이는 클라이언트 단에서의 문제점이고, 영상 데이터를 서버로 옮기고 저장하는 데에 있어서는 높은 지연 시간과 효율을 가지고 있기에, HLS, MPEG-DASH, HTTP-FLV와 같은 기술과 함께 사용된다.


	![19](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/19.png)_image.png_


	![20](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/20.png)_image.png_


	RTMP(Real-Time Messaging Protocol)의 지연 시간이 빠른 이유는 다음과 같습니다:

	1. **지속적인 연결 유지**: RTMP는 클라이언트와 서버 간에 **지속적인 TCP 연결**을 유지합니다. 이는 데이터 전송 시마다 새로운 연결을 설정할 필요가 없기 때문에 **연결 설정에 따른 오버헤드**를 줄여줍니다.
	2. **작은 청크(chunk) 단위 전송**: 데이터를 **작은 청크로 분할하여 전송**함으로써, 데이터가 준비되는 즉시 전송할 수 있습니다. 이는 **버퍼링 시간을 최소화**하고, 실시간 성능을 향상시킵니다.

	트위치의 경우 스트리머 → Ingest → Transcode → Replication → Edge → 시청자를 거치며 스트리밍 데이터를 전송


	![21](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/21.png)_image.png_

	- Ingest - 스트리머의 비디오 영상이 트위치 데이터 센터로 가는 것
	- Transcode - 비디오 형식을 바꾸는 것
	- Replication - 복사. 안정성을 위해
	- Edge - CDN이라고도 부름

	![22](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/22.png)_image.png_


	![23](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/23.png)_image.png_


## 김지수


## RTMP 프로토콜

[bookmark](https://bmobmo.tistory.com/16)


### **1. 영상 전송 프로토콜 종류**

- RTSP : 1996년 온라인 비디오 스트리밍용 프로토콜
- RTMP : 2009년 기술 일반인 공개
- SRT : 2017년 오픈 라이선스 전환
- NDI : 2016년 다양한 소프트웨어에 뉴텍은 무상 배포
- HLS : 애플에 의해 2009년 공개
- DASH : 2011년 공개
- WebRTC : 구글 2011년 공개

### RTSP **(Real Time Streaming Protocol)**


스트리밍의 시작이라고 말할 수 있다. 1996년 등장하였으며 RTSP가 등장 전 영상, 음악 등 멀티미디어 정보를 완전히 다운로드한 후 시청할 수 있었다.


CCTV에서 사용하고 있는 프로토콜


다만 오래된 기술이라 화질 저하, 미디어 서버 운영에 대한 높은 난이도 등으로 도태되고 있는 실정이다.


### RTMP **(Real Time Messaging Protocol)**


### **개요**

- **개발자:** Adobe Systems (원래 Macromedia가 개발)
- **출시 시기:** 2003년
- **주요 용도:** 실시간 비디오 및 오디오 스트리밍, 특히 라이브 방송
- **특징:**
	- **저지연 스트리밍:** 실시간 스트리밍에 적합한 낮은 지연 시간
	- **양방향 통신:** 클라이언트와 서버 간의 실시간 데이터 전송 가능
	- **유연성:** 비디오, 오디오, 데이터 스트림을 동시에 전송

### **한계점**

- **보안:** 기본적으로 보안 기능이 내장되어 있지 않아 데이터 암호화가 필요할 경우 추가 설정이 필요함
- **방화벽 문제:** 전용 포트(기본적으로 1935)를 사용하므로 일부 네트워크 환경에서는 차단될 수 있음
- **모바일 지원 부족:** HTTP 기반 스트리밍 프로토콜(HLS, MPEG-DASH)에 비해 모바일 기기에서의 지원이 제한적
- **확장성:** 대규모

### **SRT (Secure Reliable Transport)**


OBS 사용


### **개요**

- **개발자:** Haivision
- **출시 시기:** 2017년
- **주요 용도:** 불안정한 네트워크 환경에서도 안정적이고 보안이 강화된 비디오 스트리밍
- **특징:**
	- **보안 강화:** AES 암호화를 통해 데이터 전송 시 보안을 보장
	- **신뢰성:** 패킷 손실, 지연, 네트워크 변동성에 강한 내성을 가짐
	- **적응성:** 다양한 네트워크 조건에 맞춰 동적으로 조정
	- **오픈 소스:** SRT는 오픈 소스 프로젝트로, 다양한 플랫폼과 쉽게 통합 가능

### **SRT의 주요 기능**

- **암호화:** 전송 중인 데이터를 암호화하여 도청 및 데이터 변조를 방지
- **재전송 메커니즘:** 패킷 손실 시 재전송을 통해 데이터의 완전성을 유지
- **동적 비트레이트 조정:** 네트워크 상태에 따라 비트레이트를 자동으로 조정하여 스트리밍 품질을 최적화
- **방화벽 우회:** UDP 기반이지만, NAT 및 방화벽 환경에서도 안정적으로 동작

### **장점**

1. **보안:** RTMP와 달리 기본적으로 데이터 암호화를 지원하여 보안성이 뛰어남
2. **신뢰성:** 불안정한 네트워크 환경에서도 안정적인 데이터 전송을 보장
3. **유연성:** 다양한 네트워크 조건에 적응하여 최적의 스트리밍 품질 제공
4. **확장성:** 대규모 스트리밍 환경에서도 효율적으로 확장 가능
5. **오픈 소스:** 무료로 사용 가능하며, 커뮤니티 지원을 통해 지속적으로 개선됨

### **단점**

1. **채택률:** RTMP에 비해 상대적으로 최근에 등장한 프로토콜로, 기존 인프라와의 호환성 문제 발생 가능
2. **설정 복잡성:** 초기 설정과 최적화를 위해 기술적인 지식이 필요할 수 있음

---


## **RTMP와 SRT의 비교**


| **특징**      | **RTMP**                         | **SRT**                   |
| ----------- | -------------------------------- | ------------------------- |
| **보안**      | 기본적으로 보안 기능 없음 (RTMPS로 보안 강화 가능) | AES 암호화 내장, 기본적으로 보안 강화   |
| **전송 프로토콜** | TCP 기반                           | UDP 기반                    |
| **신뢰성**     | TCP의 신뢰성 제공, 그러나 네트워크 변동성에 취약    | 패킷 손실 복구, 네트워크 변동성에 강한 내성 |
| **지연 시간**   | 낮음                               | 낮음                        |
| **방화벽 우회**  | 전용 포트 사용, 방화벽 문제 발생 가능           | NAT 및 방화벽 환경에서도 안정적 동작    |
| **확장성**     | 대규모 분산 환경에서 추가 설정 필요             | 대규모 스트리밍 환경에서 효율적으로 확장 가능 |
| **오픈 소스**   | 아니오                              | 예 (오픈 소스 프로젝트)            |


[bookmark](https://blog.naver.com/n_cloudplatform/222493527661)


**카메라 ▶ Encoder(인코더) ▶ Media Server(+CDN Server) ▶  동영상 플레이어 ▶ 시청자(Client)**


압축되지 않은 동영상은 용량이 크기 때문에 압축하는 과정이 필요하다. 이 과정에서 코덱을 활용한다.


코덱이란?


### **카메라 ▶ Encoder(인코더)**


대표적인 코덱에서는 H.264, 음성은 AAC


웹 배포용으로 사용


원본 파일을 압축할 때, 손실압축, 무손실 압축이 존재함


JPEG - 손실 압축


PNG - 무손실 압축. 이미지 디테일 손실이 없음, 상대적으로 많은 메모리 사용


상황과 목적에 맞는 압축 방식이 필요함


### **Encoder(인코더) ▶ Media Server(+CDN Server)**


스트리밍이란, **멀티미디어 파일을 다운로드 하는 동시에 실행하는 방법이나 기술**을 말합니다. 예를 들면 넷플릭스에서 영화를 보는데 영화 전체를 다운로드 받고 난 뒤에 즉, 2GB 가량의 영상을 전부 다운 받은 후 영화가 재생된다면 사용자 불만이 폭주하겠죠?


​


실제 넷플릭스는 그렇지 않습니다. **다운로드와 동시에 바로 재생이 되며, 추가 다운로드가 계속 진행되는 방식**을 스트리밍이라고 하며, 이러한 스트리밍의 규칙을 ​**스트리밍 프로토콜**이라고 부릅니다.


**Encoder : RTMP,RTSP,webRTC,SRT**
**Player : HLS,DASH,LL-HLS,webRTC,SRT**


**Encoder**의 경우 주로 **RTMP(Real Time Messaging Protocol) 프로토콜**을 사용합니다.


​


과거에는 UDP기반의 RTSP(Real Time Streaming Protocol) 프로토콜을 많이 사용하였으나 최근에는 RTMP 프로토콜이 거의 표준이 되어가고 있습니다.


**Player**의 경우에는 **HLS(HTTP-Live Streaming), MPEG-DASH**가 대표적입니다.


​


스트리밍이란 &apos;다운로드와 동시에 미디어가 재생되는 기술&apos;이라고 설명 드렸는데, 스트리밍의 효율적인 동작을 위해서는 파일을 작은 단위로 분할해야 합니다.


​


이 과정은 대표적인 Player 프로토콜인 HLS, DASH을 통해 알아보도록 하겠습니다.


**Player 프로토콜 작동 과정 이해하기** feat. HLS &amp;amp; DASH


**✅ 우선 H.264 + AAC등 포맷의 동영상 파일을 작은 단위로 분할**​합니다.


(용량에 따라 2초 ~10초 단위)


**​**


**✅ 이와 더불어 분할된 파일의 재생순서가 작성된 manifest 파일을 생성**합니다.


manifest파일에는 분할된 동영상 파일을 어떤 순서로 몇 초간 재생할 것인지에 대한 내용들이 텍스트로 작성되어 있습니다. HLS의 경우에는 .m3u8 파일이, Dash의 경우 .mpd(xml)와 같은 manifest 파일이 생성됩니다.이러한 과정을 거쳐 작은 단위로 분할된 미디어 파일은 mp2ts와 mp4로 구성되어 있고 mp2ts의 확장자는 .ts입니다.


**​**


**✅** 마지막으로 HLS, DASH를 지원하는 브라우저나 Application에서 **Manifest 파일을 읽어서 재생**합니다. Manifest 파일에 작성되어 있는 분할된 동영상 파일을 순차적으로 읽어 들여 재생하게 됩니다. 따라서 첫번째 segment file을 다 불러오게 되면 재생을 시작할 수 있게 되고, 재생이 진행되면서 2번째 및 3번째 segment file을 뒤에서 계속 실행합니다.


​


만약 동영상을 중간부터 재생한다고 하면 manifest 파일(.m3u8, mpd)에 근거하여 해당 타임에 맞는 segment file을 먼저 다운로드를 하게 될 것입니다.


로컬 PC에 녹화하는 기능


### **Media Server(+CDN Server) ▶  동영상 플레이어**


안정적인 송출을 위해서는 충분한 인터넷 업로드, 대역폭이 확보되어야 합니다. 따라서 **Bitrate를 변환**하는 작업도 필수적으로 필요합니다.


**비트레이트(Bitrate)**는 **특정한 시간 단위(이를테면 초 단위)마다 처리하는 비트의 수**를 뜻합니다.


​


나아가 **멀티비트레이트(Multi Bitrate)**는 비디오 플레이어에서 보여지는 화질 선택 기능과 밀접하게 관련이 있습니다. 멀티비트레이트는 **비트레이트가 다른 여러 개의 영상을 준비하여 필요에 따라 영상을 전환하는 방식이나 기술**을 뜻합니다.


### **동영상 플레이어 ▶ 시청자(Client)**


이후 실시간으로 생성한 HLS 및DASH 영상 조각 파일을 사용자에게 전달하려면


**전송 서버**


가 있어야합니다.


**일반적인 미디어 서버는 전송 서버의 역할까지 수행**


하지만, 동시 시청자가 많은 방송일 경우에는


**대규모 트래픽을 안정적으로 처리하기 위해 CDN을 사용**


하는 것을 권장합니다.


[bookmark](https://medium.com/@delivalue100/rtmp-realtime-messaging-protocol-c4474e464ffd)


[bookmark](https://blog.twitch.tv/en/2023/09/28/twitch-state-of-engineering-2023/)


**트랜스코딩** 시스템은 제작자로부터 들어오는 실시간 메시징 프로토콜(RTMP) 스트림을 가져와 HLS 호환 스트림으로 변환합니다.


[bookmark](https://blog.twitch.tv/en/2022/04/26/ingesting-live-video-streams-at-global-scale/)


[bookmark](https://blog.twitch.tv/en/2021/10/25/low-latency-high-reach-creating-an-unparalleled-live-video-streaming-network-at-twitch/)


## **1. 기본 용어**


### **1.1. 스트리밍 (Streaming)**

- **설명:** 동영상이나 오디오 콘텐츠를 다운로드하지 않고 실시간으로 재생하는 기술입니다. 사용자는 데이터가 전송되는 동시에 콘텐츠를 시청할 수 있습니다.
- **예시:** 유튜브, 넷플릭스에서의 동영상 시청.

### **1.2. 버퍼링 (Buffering)**

- **설명:** 원활한 스트리밍을 위해 일시적으로 데이터를 미리 다운로드하여 저장하는 과정입니다. 네트워크 지연이나 변동성이 있을 때 재생 중단을 최소화합니다.
- **예시:** 동영상이 로딩되면서 일시정지 상태가 되는 현상.

### **1.3. 지연 시간 (Latency)**

- **설명:** 데이터가 송신지에서 수신지까지 도달하는 데 걸리는 시간입니다. 실시간 스트리밍에서는 지연 시간이 짧을수록 더 원활한 경험을 제공합니다.
- **예시:** 라이브 방송에서의 채팅 반응 속도.

---


## **2. 기술적 용어**


### **2.1. 코덱 (Codec)**

- **설명:** 비디오와 오디오 데이터를 압축하고 압축을 해제하는 소프트웨어 또는 하드웨어입니다. 효율적인 전송과 저장을 가능하게 합니다.
- **종류:**
	- **H.264 (AVC):** 널리 사용되는 비디오 코덱.
	- **H.265 (HEVC):** H.264보다 더 높은 압축 효율.
	- **VP9, AV1:** 오픈 소스 비디오 코덱.
	- **AAC, MP3:** 오디오 코덱.

### **2.2. 비트레이트 (Bitrate)**

- **설명:** 동영상이나 오디오 데이터의 전송 속도를 비트 단위로 나타낸 값입니다. 높은 비트레이트는 더 나은 품질을 제공하지만, 더 많은 대역폭을 필요로 합니다.
- **종류:**
	- **고정 비트레이트 (CBR):** 일정한 비트레이트로 전송.
	- **가변 비트레이트 (VBR):** 필요에 따라 비트레이트를 조정.

### **2.3. 해상도 (Resolution)**

- **설명:** 화면의 가로와 세로 픽셀 수를 나타내는 지표로, 동영상의 선명도와 품질을 결정합니다.
- **예시:** 1920x1080 (Full HD), 1280x720 (HD), 3840x2160 (4K).

### **2.4. 프레임 레이트 (Frame Rate)**

- **설명:** 초당 표시되는 프레임 수로, 동영상의 부드러움을 결정합니다.
- **예시:** 24fps, 30fps, 60fps.

### **2.5. 컨테이너 (Container)**

- **설명:** 비디오, 오디오, 자막 등의 다양한 미디어 데이터를 하나의 파일로 묶는 형식입니다.
- **종류:**
	- **MP4:** 가장 널리 사용되는 컨테이너.
	- **MKV:** 다양한 코덱과 기능을 지원.
	- **AVI, MOV:** 다른 일반적인 컨테이너 형식.

---


## **3. 스트리밍 프로토콜**


### **3.1. RTMP (Real-Time Messaging Protocol)**

- **설명:** Adobe에서 개발한 실시간 스트리밍 프로토콜로, 라이브 스트리밍에 주로 사용됩니다.
- **특징:** 낮은 지연 시간, 양방향 통신 지원.

### **3.2. HLS (HTTP Live Streaming)**

- **설명:** Apple에서 개발한 HTTP 기반의 스트리밍 프로토콜로, 적응형 비트레이트 스트리밍을 지원합니다.
- **특징:** HTTP 인프라 활용, 광범위한 디바이스 호환성.

### **3.3. MPEG-DASH (Dynamic Adaptive Streaming over HTTP)**

- **설명:** ISO 표준의 HTTP 기반 스트리밍 프로토콜로, 적응형 비트레이트를 지원하며 다양한 미디어 형식을 지원합니다.
- **특징:** 개방형 표준, 다양한 플랫폼과 호환.

### **3.4. WebRTC (Web Real-Time Communication)**

- **설명:** 브라우저 간 실시간 통신을 가능하게 하는 오픈 소스 프로젝트로, 주로 화상 회의 등에 사용됩니다.
- **특징:** 매우 낮은 지연 시간, P2P 연결 지원, 보안 통신.

### **3.5. SRT (Secure Reliable Transport)**

- **설명:** Haivision에서 개발한 프로토콜로, 불안정한 네트워크 환경에서도 안정적인 전송을 목표로 합니다.
- **특징:** 패킷 손실 복구, 보안 기능 강화, 네트워크 적응성.

---


## **4. 인프라 관련 용어**


### **4.1. CDN (Content Delivery Network)**

- **설명:** 전 세계에 분산된 서버 네트워크로, 사용자에게 콘텐츠를 빠르고 안정적으로 전달합니다.
- **기능:** 지리적 근접 서버 사용, 대역폭 분산, 부하 분산.

### **4.2. 인코딩 (Encoding)**

- **설명:** 원본 미디어 데이터를 특정 코덱과 설정을 사용하여 압축 및 변환하는 과정입니다.
- **목적:** 효율적인 저장과 전송을 위해 비트레이트와 해상도를 조정.

### **4.3. 트랜스코딩 (Transcoding)**

- **설명:** 이미 인코딩된 미디어 데이터를 다른 형식이나 코덱으로 변환하는 과정입니다.
- **용도:** 다양한 디바이스와 플랫폼에 맞춘 스트리밍.

### **4.4. 패키징 (Packaging)**

- **설명:** 인코딩된 미디어를 특정 스트리밍 프로토콜 형식으로 변환하는 과정입니다.
- **예시:** HLS, MPEG-DASH를 위한 세그먼트 생성.

### **4.5. 캐싱 (Caching)**

- **설명:** 자주 요청되는 데이터를 임시로 저장하여 접근 속도를 높이는 기술입니다.
- **용도:** CDN에서의 콘텐츠 빠른 전달, 버퍼링 감소.

---


## **5. 품질 및 성능 관련 용어**


### **5.1. 적응형 비트레이트 (Adaptive Bitrate)**

- **설명:** 사용자의 네트워크 조건에 따라 자동으로 비트레이트를 조정하여 최적의 재생 품질을 유지하는 기술입니다.
- **프로토콜:** HLS, MPEG-DASH.

### **5.2. 시작 지연 시간 (Start-up Latency)**

- **설명:** 스트리밍 시작부터 첫 프레임이 재생되기까지 걸리는 시간입니다.
- **중요성:** 사용자 경험에 큰 영향을 미침.

### **5.3. 캐시 히트/미스 (Cache Hit/Miss)**

- **설명:** 요청된 데이터가 캐시에 존재하는지 여부를 나타냅니다. 캐시 히트는 빠른 응답을, 미스는 원본 서버로부터 데이터를 가져와야 함을 의미합니다.

### **5.4. 지터 (Jitter)**

- **설명:** 패킷 전송 간의 시간 변동을 의미하며, 실시간 스트리밍의 품질에 영향을 미칠 수 있습니다.
- **영향:** 영상의 끊김이나 오디오의 왜곡을 유발할 수 있음.

### **5.5. 패킷 손실 (Packet Loss)**

- **설명:** 전송 중에 데이터 패킷이 손실되는 현상입니다.
- **영향:** 영상 및 오디오 품질 저하, 재생 중단.

---


## **6. 기타 관련 용어**


### **6.1. DRM (Digital Rights Management)**

- **설명:** 디지털 콘텐츠의 저작권 보호를 위한 기술 및 정책입니다.
- **용도:** 불법 복제 방지, 콘텐츠 접근 제어.

### **6.2. QoS (Quality of Service)**

- **설명:** 네트워크 성능을 관리하고 보장하기 위한 기술 및 정책입니다.
- **용도:** 스트리밍의 안정성과 품질을 유지.

### **6.3. GOP (Group of Pictures)**

- **설명:** 비디오 인코딩에서 I-프레임, P-프레임, B-프레임 등으로 구성된 프레임 그룹입니다.
- **영향:** 압축 효율과 재생 품질에 영향을 미침.

### **6.4. HDR (High Dynamic Range)**

- **설명:** 더 넓은 색역과 명암 대비를 제공하는 영상 기술입니다.
- **장점:** 더 생동감 있고 현실적인 영상 표현.

### **6.5. LUT (Look-Up Table)**

- **설명:** 색 보정과 그레이딩을 위해 사용되는 표로, 색상 변환을 빠르게 적용할 수 있습니다.
- **용도:** 비디오 후반 작업에서 색상 일관성 유지.

### **6.6. 비디오 월 (Video Wall)**

- **설명:** 여러 대의 디스플레이를 연결하여 하나의 큰 화면을 구성하는 시스템입니다.
- **용도:** 대형 이벤트, 컨트롤 룸, 광고 등에서 사용.

### **6.7. OTT (Over-The-Top)**

- **설명:** 인터넷을 통해 제공되는 미디어 서비스로, 전통적인 방송 플랫폼을 거치지 않습니다.
- **예시:** 넷플릭스, 디즈니+, 아마존 프라임 비디오.

### **6.8. VOD (Video on Demand)**

- **설명:** 사용자가 원하는 시간에 원하는 콘텐츠를 시청할 수 있는 서비스입니다.
- **예시:** 넷플릭스, 유튜브의 프리미엄 서비스.

### **6.9. CDN (Content Delivery Network)**

- **설명:** 전 세계에 분산된 서버 네트워크로, 콘텐츠를 사용자에게 빠르고 효율적으로 전달합니다.
- **예시:** Akamai, Cloudflare, Amazon CloudFront.

### **6.10. 클라우드 인코딩 (Cloud Encoding)**

- **설명:** 클라우드 기반 서비스에서 비디오를 인코딩하는 프로세스입니다.
- **장점:** 확장성, 유연성, 비용 효율성.

## **1. Codec의 어원 (Etymology)**


&quot;Codec&quot;은 두 단어의 합성어입니다:

- **CO**der (인코더): 데이터를 특정 형식으로 변환하거나 압축하는 장치 또는 소프트웨어.
- **DE**coder (디코더): 인코딩된 데이터를 원래 형식으로 복원하거나 해제하는 장치 또는 소프트웨어.

따라서, &quot;Codec&quot;은 &quot;Coder&quot;와 &quot;Decoder&quot;의 결합으로 이루어진 단어입니다. 이 합성어는 1980년대 초반에 처음 등장했으며, 디지털 오디오와 비디오 데이터를 효율적으로 전송하고 저장하기 위해 개발된 기술을 지칭하기 위해 사용되었습니다.


&amp;lt;/details&amp;gt;

&lt;/video&gt;&lt;/video&gt;&lt;/details&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;gominzip&quot;, &quot;hoeeeeeh&quot;, &quot;Jisukim&quot;, &quot;홍창현&quot;, &quot;김준서&quot;]</name>
        
        
      </author>

      

      

      
        <summary type="html">목차</summary>
      

      
      
    </entry>
  
</feed>
