<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://blog.liboo.kr/author/Jisukim/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://blog.liboo.kr/" rel="alternate" type="text/html" />
  <updated>2025-01-13T04:23:45+00:00</updated>
  <id>https://blog.liboo.kr/author/Jisukim/feed.xml</id>

  
  
  

  
    <title type="html">Liboo.blog | </title>
  

  
    <subtitle>라이부 개발 블로그</subtitle>
  

  

  
    
      
    
      
    
      
    
      
    
      
    
  

  
  

  
    <entry>
      <title type="html">ts-pattern</title>
      <link href="https://blog.liboo.kr/ts-pattern" rel="alternate" type="text/html" title="ts-pattern" />
      <published>2024-11-27T04:16:00+00:00</published>
      <updated>2024-11-27T04:16:00+00:00</updated>
      <id>https://blog.liboo.kr/ts-pattern</id>
      <content type="html" xml:base="https://blog.liboo.kr/ts-pattern">&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/package/ts-pattern/v/4.0.1&quot;&gt;https://www.npmjs.com/package/ts-pattern/v/4.0.1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.kimcoder.io/blog/ts-pattern&quot;&gt;https://www.kimcoder.io/blog/ts-pattern&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://toss.tech/article/ts-pattern-usage&quot;&gt;https://toss.tech/article/ts-pattern-usage&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mermaid
stateDiagram-v2
    [*] --&amp;gt; Initialized: 플레이어 마운트
    %% 공통 플레이어 상태
    state &quot;공통 플레이어 상태&quot; as PlayerState {
        %% 재생 상태
        state &quot;재생 상태&quot; as PlayState {
            Playing --&amp;gt; Paused: 일시정지
            Paused --&amp;gt; Playing: 재생
        }
        %% 볼륨 상태
        state &quot;볼륨 상태&quot; as VolumeState {
            Unmuted --&amp;gt; Muted: 음소거
            Muted --&amp;gt; Unmuted: 음소거 해제
            
            %% 볼륨 레벨
            state &quot;볼륨 레벨&quot; as VolumeLevel {
                [*] --&amp;gt; Normal
                Normal --&amp;gt; Low: 볼륨 감소
                Low --&amp;gt; Normal: 볼륨 증가
                Normal --&amp;gt; High: 볼륨 증가
                High --&amp;gt; Normal: 볼륨 감소
            }
        }
        %% 화면 상태
        state &quot;화면 상태&quot; as ScreenState {
            Normal --&amp;gt; Fullscreen: 전체화면
            Fullscreen --&amp;gt; Normal: 전체화면 종료
        }
        %% 라이브 스트림 상태
        state &quot;라이브 스트림 상태&quot; as LiveState {
            Live --&amp;gt; DVR: 뒤로 이동
            DVR --&amp;gt; Live: 실시간으로 이동
        }
        %% 진행바 상태
        state &quot;진행바 상태&quot; as Progress {
            %% 시청 진행
            state &quot;시청 진행&quot; as TimeProgress {
                [*] --&amp;gt; Watching
                Watching --&amp;gt; Seeking: 진행바 클릭/드래그
                Seeking --&amp;gt; Watching: 시간 이동 완료
            }
            
            %% 버퍼링
            state &quot;버퍼링&quot; as BufferState {
                [*] --&amp;gt; Buffering
                Buffering --&amp;gt; Buffered: 버퍼링 완료
                Buffered --&amp;gt; Buffering: 추가 버퍼링 필요
            }
        }
    }
    %% 컨트롤 UI 상태
    state &quot;컨트롤 UI 상태&quot; as ControlUI {
        Visible --&amp;gt; Hidden: 마우스 멈춤 (3초)
        Hidden --&amp;gt; Visible: 마우스 움직임
    }
    %% 전역 상태 연결
    Initialized --&amp;gt; PlayerState: 초기화 완료
    Initialized --&amp;gt; ControlUI: 초기 컨트롤 상태 설정
    %% 노트: 키보드 컨트롤
    note right of PlayerState
        스페이스바: 재생/일시정지
        F: 전체화면
        좌/우 방향키: 앞/뒤로 이동
    end note

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;Jisukim&quot;]</name>
        
        
      </author>

      

      

      
        <summary type="html">https://www.npmjs.com/package/ts-pattern/v/4.0.1</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">리액트 훅 폼 딥다이브</title>
      <link href="https://blog.liboo.kr/%EB%A6%AC%EC%95%A1%ED%8A%B8_%ED%9B%85_%ED%8F%BC_%EB%94%A5%EB%8B%A4%EC%9D%B4%EB%B8%8C" rel="alternate" type="text/html" title="리액트 훅 폼 딥다이브" />
      <published>2024-11-23T04:03:00+00:00</published>
      <updated>2024-11-23T04:03:00+00:00</updated>
      <id>https://blog.liboo.kr/%EB%A6%AC%EC%95%A1%ED%8A%B8_%ED%9B%85_%ED%8F%BC_%EB%94%A5%EB%8B%A4%EC%9D%B4%EB%B8%8C</id>
      <content type="html" xml:base="https://blog.liboo.kr/%EB%A6%AC%EC%95%A1%ED%8A%B8_%ED%9B%85_%ED%8F%BC_%EB%94%A5%EB%8B%A4%EC%9D%B4%EB%B8%8C">&lt;h1 id=&quot;리액트-훅-폼&quot;&gt;리액트 훅 폼&lt;/h1&gt;

&lt;h2 id=&quot;react-hook-form-딥다이브&quot;&gt;React Hook Form 딥다이브&lt;/h2&gt;

&lt;h2 id=&quot;1-소개&quot;&gt;1. 소개&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;React Hook Form이 해결하고자 하는 문제&lt;/li&gt;
  &lt;li&gt;기존 폼 관리의 한계점 (Controlled vs Uncontrolled)&lt;/li&gt;
  &lt;li&gt;React Hook Form의 핵심 철학&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-핵심-원리&quot;&gt;2. 핵심 원리&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;useRef를 활용한 상태 관리&lt;/li&gt;
  &lt;li&gt;불필요한 리렌더링 방지 전략&lt;/li&gt;
  &lt;li&gt;폼 데이터의 중앙 집중식 관리&lt;/li&gt;
  &lt;li&gt;Context API를 활용한 상태 공유&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-주요-기능-구현&quot;&gt;3. 주요 기능 구현&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;register 함수의 동작 원리&lt;/li&gt;
  &lt;li&gt;validation 시스템 설계&lt;/li&gt;
  &lt;li&gt;handleSubmit과 폼 제출 과정&lt;/li&gt;
  &lt;li&gt;watch와 상태 구독 시스템&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-성능-최적화&quot;&gt;4. 성능 최적화&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Controlled vs Uncontrolled Components&lt;/li&gt;
  &lt;li&gt;리렌더링 최소화 전략&lt;/li&gt;
  &lt;li&gt;메모이제이션 활용&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5-실제-사용-사례&quot;&gt;5. 실제 사용 사례&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;기본적인 폼 구현&lt;/li&gt;
  &lt;li&gt;동적 폼 필드 관리&lt;/li&gt;
  &lt;li&gt;복잡한 유효성 검사 시나리오&lt;/li&gt;
  &lt;li&gt;중첩된 폼 데이터 처리&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6-직접-구현해보기&quot;&gt;6. 직접 구현해보기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;미니 버전 React Hook Form 구현&lt;/li&gt;
  &lt;li&gt;핵심 기능 단계별 구현&lt;/li&gt;
  &lt;li&gt;타입 시스템 설계&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;7-심화-주제&quot;&gt;7. 심화 주제&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;FormProvider와 Context API 활용&lt;/li&gt;
  &lt;li&gt;비동기 유효성 검사&lt;/li&gt;
  &lt;li&gt;커스텀 훅과의 통합&lt;/li&gt;
  &lt;li&gt;테스트 전략&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;8-마무리&quot;&gt;8. 마무리&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;React Hook Form의 장단점&lt;/li&gt;
  &lt;li&gt;사용시 주의사항&lt;/li&gt;
  &lt;li&gt;대안 라이브러리와의 비교&lt;/li&gt;
  &lt;li&gt;추가 학습 자료&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;react-hook-form--폼-상태-관리의-패러다임-전환&quot;&gt;React Hook Form : 폼 상태 관리의 패러다임 전환&lt;/h1&gt;

&lt;h2 id=&quot;1-소개-1&quot;&gt;1. 소개&lt;/h2&gt;

&lt;h3 id=&quot;react-hook-form이-해결하고자-하는-문제&quot;&gt;React Hook Form이 해결하고자 하는 문제&lt;/h3&gt;

&lt;p&gt;리액트 애플리케이션에서 폼(Form)은 사용자 입력을 받기 위한 필수적인 요소입니다. 그러나 복잡한 폼을 효율적으로 관리하고 검증하는 것은 쉽지 않은 과제입니다. 전통적으로 리액트에서는 폼 상태를 관리하기 위해 &lt;strong&gt;컨트롤드 컴포넌트(Controlled Components)&lt;/strong&gt; 방식을 주로 사용해왔습니다. 이 방식은 각 입력 필드의 상태를 리액트의 상태 관리(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useState&lt;/code&gt;)로 관리하여, 입력 값이 변경될 때마다 상태를 업데이트하고, 이에 따라 컴포넌트가 리렌더링되는 구조를 가집니다.&lt;/p&gt;

&lt;p&gt;하지만 &lt;strong&gt;컨트롤드 컴포넌트&lt;/strong&gt; 방식은 다음과 같은 문제점을 안고 있습니다:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;퍼포먼스 이슈:&lt;/strong&gt; 폼 필드가 많아질수록 상태 업데이트와 리렌더링이 빈번하게 발생하여 성능 저하가 발생할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;코드 복잡성:&lt;/strong&gt; 각 입력 필드마다 별도의 상태 관리 로직이 필요하므로 코드가 복잡해지고 유지보수가 어려워집니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;실시간 검증의 어려움:&lt;/strong&gt; 입력 값이 변경될 때마다 검증 로직을 실행해야 하므로, 복잡한 검증 로직을 구현하기 어렵습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이러한 문제를 해결하기 위해 &lt;strong&gt;React Hook Form&lt;/strong&gt;이 등장했습니다. React Hook Form은 &lt;strong&gt;언컨트롤드 컴포넌트(Uncontrolled Components)&lt;/strong&gt; 방식을 기본으로 하여 폼 상태를 효율적으로 관리하고, 불필요한 리렌더링을 최소화함으로써 퍼포먼스를 최적화합니다. 또한, 간결한 API를 제공하여 폼 관리의 복잡성을 줄이고, 다양한 검증 로직을 쉽게 구현할 수 있도록 지원합니다.&lt;/p&gt;

&lt;h3 id=&quot;기존-폼-관리의-한계점-controlled-vs-uncontrolled&quot;&gt;기존 폼 관리의 한계점 (Controlled vs Uncontrolled)&lt;/h3&gt;

&lt;p&gt;리액트에서 폼을 관리하는 방식은 주로 &lt;strong&gt;컨트롤드 컴포넌트&lt;/strong&gt;와 &lt;strong&gt;언컨트롤드 컴포넌트&lt;/strong&gt; 두 가지로 나뉩니다. 각 방식은 고유의 장단점을 가지고 있으며, 특정 상황에 따라 적합한 선택이 필요합니다.&lt;/p&gt;

&lt;h3 id=&quot;컨트롤드-컴포넌트-controlled-components&quot;&gt;컨트롤드 컴포넌트 (Controlled Components)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;개념:&lt;/strong&gt; 폼의 각 입력 필드의 값을 리액트의 상태(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useState&lt;/code&gt;)로 관리합니다. 입력 값이 변경될 때마다 상태를 업데이트하고, 이에 따라 컴포넌트가 리렌더링됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;장점:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;실시간 검증 및 피드백:&lt;/strong&gt; 사용자가 입력할 때마다 실시간으로 값을 검증하거나 UI를 업데이트할 수 있습니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;동기화된 데이터 관리:&lt;/strong&gt; 입력 값이 항상 리액트 상태와 동기화되므로, 다른 컴포넌트나 로직에서 쉽게 접근하고 사용할 수 있습니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;복잡한 상호작용 처리:&lt;/strong&gt; 동적 폼 필드, 조건부 렌더링 등 복잡한 폼 로직을 쉽게 구현할 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;단점:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;퍼포먼스 이슈:&lt;/strong&gt; 폼 필드가 많아질수록 상태 업데이트와 리렌더링이 빈번해져 성능 저하가 발생할 수 있습니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;코드 복잡성:&lt;/strong&gt; 각 입력 필드마다 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useState&lt;/code&gt;를 사용하여 상태를 관리해야 하므로 코드가 복잡해질 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;언컨트롤드-컴포넌트-uncontrolled-components&quot;&gt;언컨트롤드 컴포넌트 (Uncontrolled Components)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;개념:&lt;/strong&gt; 입력 필드의 값을 리액트의 상태가 아닌 DOM 자체에서 관리합니다. 입력 값에 접근할 때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ref&lt;/code&gt;를 사용하거나 폼 제출 시 값을 한꺼번에 수집합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;장점:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;성능 최적화:&lt;/strong&gt; 상태 관리가 최소화되므로 폼 필드가 많아도 리렌더링 비용이 적습니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;간단한 구현:&lt;/strong&gt; 상태 관리 로직이 필요 없으므로 코드가 단순해집니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;레거시 코드와의 호환성:&lt;/strong&gt; 기존의 폼 라이브러리나 레거시 코드와 쉽게 통합될 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;단점:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;실시간 상호작용 제한:&lt;/strong&gt; 입력 값에 대한 실시간 검증이나 피드백이 어렵습니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;데이터 동기화의 어려움:&lt;/strong&gt; 리액트 상태와 입력 값이 별도로 관리되므로, 데이터를 동기화하는 로직이 필요할 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;react-hook-form의-핵심-철학&quot;&gt;React Hook Form의 핵심 철학&lt;/h3&gt;

&lt;p&gt;React Hook Form은 기존 폼 관리 방식의 한계를 극복하고자 다음과 같은 핵심 철학을 바탕으로 설계되었습니다:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;퍼포먼스 최적화:&lt;/strong&gt; 언컨트롤드 컴포넌트를 기본으로 사용하여 폼 필드의 상태 관리를 최소화하고, 불필요한 리렌더링을 방지함으로써 높은 퍼포먼스를 유지합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;간결하고 직관적인 API:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useForm&lt;/code&gt; 훅을 통해 폼의 상태 관리, 검증, 제출 등을 간단하고 직관적으로 처리할 수 있는 API를 제공합니다. 이를 통해 개발자는 복잡한 상태 관리 로직을 작성할 필요 없이 폼을 쉽게 구현할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유연한 검증 시스템:&lt;/strong&gt; 기본적인 검증 규칙 외에도 커스텀 검증 로직을 쉽게 추가할 수 있으며, Yup과 같은 외부 검증 라이브러리와의 통합을 지원하여 다양한 검증 시나리오를 구현할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;컴포넌트 재사용성 향상:&lt;/strong&gt; 폼 로직을 컴포넌트 외부에서 관리함으로써 폼 컴포넌트의 재사용성을 높이고, 코드의 가독성과 유지보수성을 향상시킵니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;확장성과 유연성:&lt;/strong&gt; Context API를 활용하여 폼 상태를 여러 컴포넌트 간에 공유할 수 있으며, 동적 폼 필드나 복잡한 폼 구조도 유연하게 관리할 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;제어-컴포넌트를-언제-사용하고-비제어-컴포넌트를-언제-사용하는가&quot;&gt;제어 컴포넌트를 언제 사용하고, 비제어 컴포넌트를 언제 사용하는가?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;*제어 컴포넌트(Controlled Components)&lt;strong&gt;와 **비제어 컴포넌트(Uncontrolled Components)&lt;/strong&gt;는 각각의 특성과 장단점에 따라 사용 시기가 달라집니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제어-컴포넌트-controlled-components-사용-시기&quot;&gt;제어 컴포넌트 (Controlled Components) 사용 시기:&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;실시간 검증 및 피드백이 필요한 경우:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;사용자가 입력할 때마다 실시간으로 입력 값을 검증하고, 그에 따른 피드백을 제공해야 하는 경우.&lt;/li&gt;
      &lt;li&gt;예: 비밀번호 강도 표시, 실시간 검색어 추천.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;복잡한 상호작용이 필요한 경우:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;입력 값에 따라 동적으로 다른 UI 요소를 표시하거나, 다른 컴포넌트와의 상호작용이 많은 경우.&lt;/li&gt;
      &lt;li&gt;예: 조건부 렌더링, 동적 필드 추가/제거.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;입력 값이 다른 로직이나 컴포넌트와 밀접하게 연관된 경우:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;입력 값이 다른 상태나 컴포넌트의 동작에 직접적인 영향을 미치는 경우.&lt;/li&gt;
      &lt;li&gt;예: 입력 값에 따라 다른 컴포넌트의 표시 여부를 결정.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;비제어-컴포넌트-uncontrolled-components-사용-시기&quot;&gt;비제어 컴포넌트 (Uncontrolled Components) 사용 시기:&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;단순한 폼을 구현할 때:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;입력 값의 실시간 검증이나 피드백이 필요 없는 단순한 폼.&lt;/li&gt;
      &lt;li&gt;예: 간단한 회원가입 폼, 연락처 폼.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;입력 필드가 많은 폼을 관리할 때:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;많은 수의 입력 필드가 있는 경우, 각 필드의 상태를 개별적으로 관리하는 대신 제출 시 한꺼번에 데이터를 수집하는 방식이 더 효율적입니다.&lt;/li&gt;
      &lt;li&gt;예: 대규모 설문조사 폼, 다단계 폼.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;성능 최적화가 중요한 경우:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;많은 입력 필드가 존재하여 리렌더링이 빈번하게 발생할 경우, 언컨트롤드 컴포넌트를 사용하여 리렌더링 비용을 줄이는 것이 유리합니다.&lt;/li&gt;
      &lt;li&gt;예: 실시간 데이터 입력이 많지 않은 폼.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;react-hook-form에서의-적용-사례&quot;&gt;React Hook Form에서의 적용 사례&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;React Hook Form&lt;/strong&gt;은 주로 &lt;strong&gt;언컨트롤드 컴포넌트&lt;/strong&gt; 방식을 채택하여 다음과 같은 상황에서 큰 효과를 발휘합니다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;폼에 입력 필드가 많은 경우:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;대부분의 상황에서 폼에는 여러 개의 입력 필드가 존재합니다. 각 필드의 값을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useState&lt;/code&gt;로 개별적으로 관리하면 코드가 복잡해지고, 리렌더링이 빈번하게 발생하여 성능 저하가 발생할 수 있습니다. React Hook Form은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;register&lt;/code&gt; 함수를 통해 입력 필드를 등록하고, 필요할 때만 데이터를 수집하여 제출함으로써 이러한 문제를 해결합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;실시간 검색어 추천과 같은 경우:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;반대로, 실시간 검색어 추천과 같이 사용자의 입력에 따라 즉각적인 피드백을 제공해야 하는 경우에는 &lt;strong&gt;컨트롤드 컴포넌트&lt;/strong&gt; 방식을 사용하는 것이 적합합니다. 이 경우, 입력 값을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useState&lt;/code&gt;로 관리하여 사용자의 입력에 따라 즉시 서버에서 추천 검색어를 가져와 렌더링할 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;예시: 간단한 회원가입 폼과 실시간 검색어 추천&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
jsx
코드 복사
// 간단한 회원가입 폼 (언컨트롤드 컴포넌트)
import React from &apos;react&apos;;
import { useForm } from &apos;react-hook-form&apos;;

function SignupForm() {
  const { register, handleSubmit, formState: { errors } } = useForm();

  const onSubmit = data =&amp;gt; {
    console.log(&apos;제출된 데이터:&apos;, data);
  };

  return (
    &amp;lt;form onSubmit={handleSubmit(onSubmit)}&amp;gt;
      &amp;lt;div&amp;gt;
        &amp;lt;label&amp;gt;이름:&amp;lt;/label&amp;gt;
        &amp;lt;input {...register(&apos;name&apos;, { required: &apos;이름은 필수 항목입니다.&apos; })} /&amp;gt;
        {errors.name &amp;amp;&amp;amp; &amp;lt;p style=&amp;gt;{errors.name.message}&amp;lt;/p&amp;gt;}
      &amp;lt;/div&amp;gt;

      &amp;lt;div&amp;gt;
        &amp;lt;label&amp;gt;이메일:&amp;lt;/label&amp;gt;
        &amp;lt;input
          type=&quot;email&quot;
          {...register(&apos;email&apos;, {
            required: &apos;이메일은 필수 항목입니다.&apos;,
            pattern: {
              value: /^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$/,
              message: &apos;유효한 이메일 주소를 입력해주세요.&apos;
            }
          })}
        /&amp;gt;
        {errors.email &amp;amp;&amp;amp; &amp;lt;p style=&amp;gt;{errors.email.message}&amp;lt;/p&amp;gt;}
      &amp;lt;/div&amp;gt;

      &amp;lt;div&amp;gt;
        &amp;lt;label&amp;gt;비밀번호:&amp;lt;/label&amp;gt;
        &amp;lt;input
          type=&quot;password&quot;
          {...register(&apos;password&apos;, {
            required: &apos;비밀번호는 필수 항목입니다.&apos;,
            minLength: { value: 6, message: &apos;비밀번호는 최소 6자 이상이어야 합니다.&apos; }
          })}
        /&amp;gt;
        {errors.password &amp;amp;&amp;amp; &amp;lt;p style=&amp;gt;{errors.password.message}&amp;lt;/p&amp;gt;}
      &amp;lt;/div&amp;gt;

      &amp;lt;button type=&quot;submit&quot;&amp;gt;가입하기&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
  );
}

export default SignupForm;

// 실시간 검색어 추천 (컨트롤드 컴포넌트)
import React, { useState, useEffect } from &apos;react&apos;;

function SearchInput() {
  const [query, setQuery] = useState(&apos;&apos;);
  const [suggestions, setSuggestions] = useState([]);

  useEffect(() =&amp;gt; {
    if (query.length &amp;gt; 2) {
      // 서버에서 추천 검색어를 가져오는 로직
      fetch(`/api/suggestions?q=${query}`)
        .then(response =&amp;gt; response.json())
        .then(data =&amp;gt; setSuggestions(data));
    } else {
      setSuggestions([]);
    }
  }, [query]);

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;input
        value={query}
        onChange={(e) =&amp;gt; setQuery(e.target.value)}
        placeholder=&quot;검색어를 입력하세요&quot;
      /&amp;gt;
      &amp;lt;ul&amp;gt;
        {suggestions.map(suggestion =&amp;gt; (
          &amp;lt;li key={suggestion}&amp;gt;{suggestion}&amp;lt;/li&amp;gt;
        ))}
      &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
  );
}

export default SearchInput;



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;결론&quot;&gt;&lt;strong&gt;결론&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;폼 관리 방식은 애플리케이션의 요구 사항과 폼의 복잡성에 따라 달라집니다. &lt;strong&gt;컨트롤드 컴포넌트&lt;/strong&gt;는 실시간 검증과 복잡한 상호작용이 필요한 경우에 적합하며, &lt;strong&gt;언컨트롤드 컴포넌트&lt;/strong&gt;는 많은 입력 필드를 효율적으로 관리하고 성능을 최적화하는 데 유리합니다. React Hook Form은 언컨트롤드 컴포넌트를 기반으로 하여 폼 관리의 성능과 효율성을 극대화하며, 필요에 따라 컨트롤드 컴포넌트의 기능도 유연하게 활용할 수 있도록 설계되었습니다.&lt;/p&gt;

&lt;p&gt;다음 섹션에서는 React Hook Form의 핵심 원리에 대해 자세히 살펴보겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2-핵심-원리-1&quot;&gt;2. 핵심 원리&lt;/h2&gt;

&lt;p&gt;React Hook Form은 폼 관리를 효율적으로 처리하기 위해 몇 가지 핵심 원리를 기반으로 설계되었습니다. 이 섹션에서는 React Hook Form이 어떻게 폼 상태를 관리하고, 성능을 최적화하며, 폼 데이터를 중앙 집중식으로 관리하는지에 대해 자세히 알아보겠습니다. 또한, Context API를 활용하여 폼 상태를 여러 컴포넌트 간에 공유하는 방법도 살펴보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;1-useref를-활용한-상태-관리&quot;&gt;&lt;strong&gt;1.&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useRef&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;를 활용한 상태 관리&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;React Hook Form은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useRef&lt;/code&gt; 훅을 활용하여 폼 필드의 상태를 관리합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useRef&lt;/code&gt;는 리액트의 렌더링 사이클과 무관하게 특정 값을 유지할 수 있는 방법을 제공합니다. 이를 통해 폼 필드의 값을 추적하고, 필요할 때 접근할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;useref의-역할&quot;&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useRef&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;의 역할&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;DOM 요소 참조:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useRef&lt;/code&gt;를 사용하여 각 입력 필드의 DOM 요소에 직접 접근할 수 있습니다. 이를 통해 입력 값의 변화를 추적하고, 폼 제출 시 데이터를 수집합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;상태 관리 최소화:&lt;/strong&gt; 폼 필드의 상태를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useState&lt;/code&gt;로 관리하지 않고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useRef&lt;/code&gt;를 사용함으로써, 상태 업데이트로 인한 리렌더링을 방지합니다. 이는 성능 최적화에 크게 기여합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;예제-useref를-사용한-간단한-폼-관리&quot;&gt;&lt;strong&gt;예제:&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useRef&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;를 사용한 간단한 폼 관리&lt;/strong&gt;&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
jsx
코드 복사
import React, { useRef } from &apos;react&apos;;

function SimpleForm() {
  const formRef = useRef({});

  const handleSubmit = (e) =&amp;gt; {
    e.preventDefault();
    const data = {};
    for (const name in formRef.current) {
      data[name] = formRef.current[name].value;
    }
    console.log(&apos;폼 데이터:&apos;, data);
  };

  const register = (name) =&amp;gt; ({
    name,
    ref: (el) =&amp;gt; {
      formRef.current[name] = el;
    }
  });

  return (
    &amp;lt;form onSubmit={handleSubmit}&amp;gt;
      &amp;lt;div&amp;gt;
        &amp;lt;label&amp;gt;이름:&amp;lt;/label&amp;gt;
        &amp;lt;input {...register(&apos;name&apos;)} /&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div&amp;gt;
        &amp;lt;label&amp;gt;이메일:&amp;lt;/label&amp;gt;
        &amp;lt;input type=&quot;email&quot; {...register(&apos;email&apos;)} /&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;button type=&quot;submit&quot;&amp;gt;제출&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
  );
}

export default SimpleForm;



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;설명:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;formRef&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;객체:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useRef&lt;/code&gt;를 사용하여 폼 필드의 DOM 요소를 저장하는 객체를 생성합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;register&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;함수:&lt;/strong&gt; 입력 필드를 등록하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ref&lt;/code&gt; 콜백을 통해 해당 필드의 DOM 요소를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;formRef.current&lt;/code&gt;에 저장합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handleSubmit&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;함수:&lt;/strong&gt; 폼 제출 시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;formRef.current&lt;/code&gt;에 저장된 모든 입력 필드의 값을 수집하여 데이터를 출력합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-불필요한-리렌더링-방지-전략&quot;&gt;&lt;strong&gt;2. 불필요한 리렌더링 방지 전략&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;React Hook Form은 폼 필드의 상태 관리를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useRef&lt;/code&gt;와 내부적으로 최적화된 로직을 통해 처리함으로써, 불필요한 리렌더링을 방지합니다. 이는 폼 성능을 크게 향상시키며, 특히 많은 입력 필드를 가진 복잡한 폼에서 효과적입니다.&lt;/p&gt;

&lt;h3 id=&quot;리렌더링-최소화-방법&quot;&gt;&lt;strong&gt;리렌더링 최소화 방법&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;언컨트롤드 컴포넌트 사용:&lt;/strong&gt; 폼 필드의 상태를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useState&lt;/code&gt;로 관리하지 않고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useRef&lt;/code&gt;를 통해 DOM 요소에 직접 접근함으로써 상태 변화에 따른 리렌더링을 피합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;부분 업데이트:&lt;/strong&gt; 폼의 특정 필드에 변화가 있을 때, 전체 폼 컴포넌트를 리렌더링하지 않고 해당 필드만 업데이트합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메모이제이션:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useCallback&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React.memo&lt;/code&gt;를 활용하여 컴포넌트의 불필요한 재생성을 방지합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;예제-리렌더링-최소화&quot;&gt;&lt;strong&gt;예제: 리렌더링 최소화&lt;/strong&gt;&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
jsx
코드 복사
import React, { useRef, useState } from &apos;react&apos;;

function OptimizedForm() {
  const formRef = useRef({});
  const [submittedData, setSubmittedData] = useState(null);

  const handleSubmit = (e) =&amp;gt; {
    e.preventDefault();
    const data = {};
    for (const name in formRef.current) {
      data[name] = formRef.current[name].value;
    }
    setSubmittedData(data);
  };

  const register = (name) =&amp;gt; ({
    name,
    ref: (el) =&amp;gt; {
      formRef.current[name] = el;
    }
  });

  return (
    &amp;lt;form onSubmit={handleSubmit}&amp;gt;
      &amp;lt;div&amp;gt;
        &amp;lt;label&amp;gt;이름:&amp;lt;/label&amp;gt;
        &amp;lt;input {...register(&apos;name&apos;)} /&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div&amp;gt;
        &amp;lt;label&amp;gt;이메일:&amp;lt;/label&amp;gt;
        &amp;lt;input type=&quot;email&quot; {...register(&apos;email&apos;)} /&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;button type=&quot;submit&quot;&amp;gt;제출&amp;lt;/button&amp;gt;

      {submittedData &amp;amp;&amp;amp; (
        &amp;lt;div&amp;gt;
          &amp;lt;h3&amp;gt;제출된 데이터:&amp;lt;/h3&amp;gt;
          &amp;lt;pre&amp;gt;{JSON.stringify(submittedData, null, 2)}&amp;lt;/pre&amp;gt;
        &amp;lt;/div&amp;gt;
      )}
    &amp;lt;/form&amp;gt;
  );
}

export default OptimizedForm;



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;설명:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;상태 관리:&lt;/strong&gt; 폼의 제출된 데이터를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useState&lt;/code&gt;로 관리하지만, 입력 필드의 값은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useRef&lt;/code&gt;를 통해 관리하여 리렌더링을 최소화합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;부분 업데이트:&lt;/strong&gt; 입력 필드의 변화는 리렌더링을 유발하지 않으며, 제출 시에만 상태가 업데이트됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-폼-데이터의-중앙-집중식-관리&quot;&gt;&lt;strong&gt;3. 폼 데이터의 중앙 집중식 관리&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;React Hook Form은 폼 데이터를 중앙에서 관리함으로써, 데이터의 일관성과 접근성을 높입니다. 이는 복잡한 폼 구조에서도 효율적으로 데이터를 관리할 수 있게 해줍니다.&lt;/p&gt;

&lt;h3 id=&quot;중앙-집중식-관리의-장점&quot;&gt;&lt;strong&gt;중앙 집중식 관리의 장점&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;데이터 일관성:&lt;/strong&gt; 모든 폼 필드의 데이터가 중앙에서 관리되므로, 데이터의 일관성을 유지할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;쉬운 접근성:&lt;/strong&gt; 폼 데이터가 중앙에 저장되므로, 필요한 컴포넌트나 로직에서 쉽게 접근하고 사용할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유지보수성:&lt;/strong&gt; 데이터 관리 로직이 중앙에 집중되어 있어, 유지보수가 용이하고 코드의 가독성이 향상됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;예제-중앙-집중식-데이터-관리&quot;&gt;&lt;strong&gt;예제: 중앙 집중식 데이터 관리&lt;/strong&gt;&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
jsx
코드 복사
import React from &apos;react&apos;;
import { useForm, FormProvider } from &apos;react-hook-form&apos;;

function FormProviderExample() {
  const methods = useForm();

  const onSubmit = (data) =&amp;gt; {
    console.log(&apos;제출된 데이터:&apos;, data);
  };

  return (
    &amp;lt;FormProvider {...methods}&amp;gt;
      &amp;lt;form onSubmit={methods.handleSubmit(onSubmit)}&amp;gt;
        &amp;lt;InputField name=&quot;name&quot; label=&quot;이름&quot; /&amp;gt;
        &amp;lt;InputField name=&quot;email&quot; label=&quot;이메일&quot; type=&quot;email&quot; /&amp;gt;
        &amp;lt;button type=&quot;submit&quot;&amp;gt;제출&amp;lt;/button&amp;gt;
      &amp;lt;/form&amp;gt;
    &amp;lt;/FormProvider&amp;gt;
  );
}

function InputField({ name, label, type = &apos;text&apos; }) {
  const { register, formState: { errors } } = useFormContext();

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;label&amp;gt;{label}:&amp;lt;/label&amp;gt;
      &amp;lt;input type={type} {...register(name, { required: `${label}은 필수 항목입니다.` })} /&amp;gt;
      {errors[name] &amp;amp;&amp;amp; &amp;lt;p style=&amp;gt;{errors[name].message}&amp;lt;/p&amp;gt;}
    &amp;lt;/div&amp;gt;
  );
}

export default FormProviderExample;



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;설명:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FormProvider&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt; React Hook Form의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FormProvider&lt;/code&gt;를 사용하여 폼의 상태를 하위 컴포넌트와 공유합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useFormContext&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt; 하위 컴포넌트에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useFormContext&lt;/code&gt; 훅을 사용하여 폼 상태에 접근하고, 중앙 집중식으로 관리된 데이터를 활용합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;재사용 가능한 입력 필드:&lt;/strong&gt; 중앙에서 관리되는 데이터를 기반으로 재사용 가능한 입력 필드 컴포넌트를 생성할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-context-api를-활용한-상태-공유&quot;&gt;&lt;strong&gt;4. Context API를 활용한 상태 공유&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;React Hook Form은 Context API를 활용하여 폼의 상태를 여러 컴포넌트 간에 공유할 수 있게 합니다. 이는 복잡한 폼 구조에서 컴포넌트 간의 데이터 전달을 간소화하고, 폼 상태를 일관되게 유지하는 데 도움을 줍니다.&lt;/p&gt;

&lt;h3 id=&quot;context-api의-역할&quot;&gt;&lt;strong&gt;Context API의 역할&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;상태 공유:&lt;/strong&gt; 폼의 상태를 Context를 통해 하위 컴포넌트에 전달하여, 깊이 있는 컴포넌트 트리에서도 쉽게 접근할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;컴포넌트 간의 의존성 감소:&lt;/strong&gt; 폼 상태를 Context로 관리함으로써, 하위 컴포넌트가 상위 컴포넌트와 직접적으로 의존하지 않고 독립적으로 동작할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유지보수성 향상:&lt;/strong&gt; Context를 활용하여 상태를 공유하면, 상태 관리 로직이 명확해지고 코드의 유지보수성이 향상됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;예제-context-api를-활용한-상태-공유&quot;&gt;&lt;strong&gt;예제: Context API를 활용한 상태 공유&lt;/strong&gt;&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
jsx
코드 복사
import React from &apos;react&apos;;
import { useForm, FormProvider, useFormContext } from &apos;react-hook-form&apos;;

function ComplexForm() {
  const methods = useForm();

  const onSubmit = (data) =&amp;gt; {
    console.log(&apos;제출된 데이터:&apos;, data);
  };

  return (
    &amp;lt;FormProvider {...methods}&amp;gt;
      &amp;lt;form onSubmit={methods.handleSubmit(onSubmit)}&amp;gt;
        &amp;lt;Section title=&quot;개인 정보&quot;&amp;gt;
          &amp;lt;InputField name=&quot;firstName&quot; label=&quot;이름&quot; /&amp;gt;
          &amp;lt;InputField name=&quot;lastName&quot; label=&quot;성&quot; /&amp;gt;
        &amp;lt;/Section&amp;gt;
        &amp;lt;Section title=&quot;연락처 정보&quot;&amp;gt;
          &amp;lt;InputField name=&quot;email&quot; label=&quot;이메일&quot; type=&quot;email&quot; /&amp;gt;
          &amp;lt;InputField name=&quot;phone&quot; label=&quot;전화번호&quot; type=&quot;tel&quot; /&amp;gt;
        &amp;lt;/Section&amp;gt;
        &amp;lt;button type=&quot;submit&quot;&amp;gt;제출&amp;lt;/button&amp;gt;
      &amp;lt;/form&amp;gt;
    &amp;lt;/FormProvider&amp;gt;
  );
}

function Section({ title, children }) {
  return (
    &amp;lt;fieldset&amp;gt;
      &amp;lt;legend&amp;gt;{title}&amp;lt;/legend&amp;gt;
      {children}
    &amp;lt;/fieldset&amp;gt;
  );
}

function InputField({ name, label, type = &apos;text&apos; }) {
  const { register, formState: { errors } } = useFormContext();

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;label&amp;gt;{label}:&amp;lt;/label&amp;gt;
      &amp;lt;input type={type} {...register(name, { required: `${label}은 필수 항목입니다.` })} /&amp;gt;
      {errors[name] &amp;amp;&amp;amp; &amp;lt;p style=&amp;gt;{errors[name].message}&amp;lt;/p&amp;gt;}
    &amp;lt;/div&amp;gt;
  );
}

export default ComplexForm;



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;설명:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FormProvider&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;와&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useFormContext&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FormProvider&lt;/code&gt;를 통해 폼의 상태를 Context로 공유하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useFormContext&lt;/code&gt;를 사용하여 하위 컴포넌트에서 폼 상태에 접근합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;섹션 분리:&lt;/strong&gt; 폼을 여러 섹션으로 나누어 관리함으로써, 폼 구조를 더욱 명확하게 유지하고 관리할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;재사용 가능한 입력 필드:&lt;/strong&gt; 다양한 섹션에서 재사용 가능한 입력 필드 컴포넌트를 활용하여 코드의 중복을 줄이고, 유지보수성을 높입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-react-hook-form의-핵심-원리-요약&quot;&gt;&lt;strong&gt;5. React Hook Form의 핵심 원리 요약&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;React Hook Form은 다음과 같은 핵심 원리를 바탕으로 폼 상태를 효율적으로 관리합니다:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useRef&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;를 통한 상태 관리:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useRef&lt;/code&gt;를 활용하여 폼 필드의 DOM 요소에 직접 접근하고, 상태 업데이트로 인한 리렌더링을 방지합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;불필요한 리렌더링 방지:&lt;/strong&gt; 언컨트롤드 컴포넌트 방식을 채택하고, 부분 업데이트와 메모이제이션을 통해 폼 성능을 최적화합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;중앙 집중식 데이터 관리:&lt;/strong&gt; 폼 데이터를 중앙에서 관리하여 데이터의 일관성과 접근성을 높이고, 유지보수성을 향상시킵니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Context API를 활용한 상태 공유:&lt;/strong&gt; Context API를 통해 폼 상태를 여러 컴포넌트 간에 공유하여, 복잡한 폼 구조에서도 효율적으로 상태를 관리할 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이러한 핵심 원리를 바탕으로 React Hook Form은 복잡한 폼을 효율적으로 관리하고, 높은 퍼포먼스를 유지하며, 개발자의 생산성을 높이는 데 기여합니다. 다음 섹션에서는 React Hook Form의 주요 기능 구현에 대해 자세히 살펴보겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;3-주요-기능-구현-1&quot;&gt;3. 주요 기능 구현&lt;/h2&gt;

&lt;p&gt;React Hook Form은 간결하고 효율적인 API를 통해 다양한 폼 기능을 손쉽게 구현할 수 있도록 지원합니다. 이 섹션에서는 React Hook Form의 핵심 기능인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;register&lt;/code&gt; 함수의 동작 원리, 검증 시스템 설계, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handleSubmit&lt;/code&gt;과 폼 제출 과정, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;watch&lt;/code&gt;와 상태 구독 시스템에 대해 자세히 살펴보겠습니다. 이러한 기능들을 이해하고 구현함으로써 React Hook Form의 내부 메커니즘을 깊이 있게 파악할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;1-register-함수의-동작-원리&quot;&gt;&lt;strong&gt;1.&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;register&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;함수의 동작 원리&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;register&lt;/code&gt; 함수는 폼 필드를 React Hook Form에 등록하여 해당 필드의 값을 추적하고 검증을 수행할 수 있게 해주는 핵심 메서드입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;register&lt;/code&gt;는 각 입력 필드에 대한 설정을 정의하고, 해당 필드의 DOM 요소에 접근할 수 있도록 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ref&lt;/code&gt;를 설정합니다.&lt;/p&gt;

&lt;h3 id=&quot;동작-방식&quot;&gt;&lt;strong&gt;동작 방식:&lt;/strong&gt;&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;필드 등록:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;register&lt;/code&gt; 함수는 입력 필드의 이름과 검증 규칙을 인수로 받아 해당 필드를 폼에 등록합니다.&lt;/li&gt;
      &lt;li&gt;내부적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ref&lt;/code&gt;를 사용하여 DOM 요소에 직접 접근하고, 필드의 현재 값을 추적합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;검증 규칙 적용:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;register&lt;/code&gt; 함수의 두 번째 인수로 검증 규칙을 설정할 수 있습니다. 예를 들어, 필수 입력, 패턴 매칭, 최소 길이 등을 정의할 수 있습니다.&lt;/li&gt;
      &lt;li&gt;이러한 규칙은 폼 제출 시 또는 특정 이벤트 발생 시 검증 로직에 의해 적용됩니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;퍼포먼스 최적화:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;register&lt;/code&gt;는 언컨트롤드 컴포넌트 방식을 채택하여, 각 입력 필드의 상태를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useState&lt;/code&gt;로 관리하지 않고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ref&lt;/code&gt;를 통해 직접 접근함으로써 불필요한 리렌더링을 방지합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;예제-register-함수-사용&quot;&gt;&lt;strong&gt;예제:&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;register&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;함수 사용&lt;/strong&gt;&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
jsx
코드 복사
import React from &apos;react&apos;;
import { useForm } from &apos;react-hook-form&apos;;

function SignupForm() {
  const { register, handleSubmit, formState: { errors } } = useForm();

  const onSubmit = data =&amp;gt; {
    console.log(&apos;제출된 데이터:&apos;, data);
  };

  return (
    &amp;lt;form onSubmit={handleSubmit(onSubmit)}&amp;gt;
      {/* 이름 필드 */}
      &amp;lt;div&amp;gt;
        &amp;lt;label&amp;gt;이름:&amp;lt;/label&amp;gt;
        &amp;lt;input
          {...register(&apos;name&apos;, { required: &apos;이름은 필수 항목입니다.&apos; })}
        /&amp;gt;
        {errors.name &amp;amp;&amp;amp; &amp;lt;p style=&amp;gt;{errors.name.message}&amp;lt;/p&amp;gt;}
      &amp;lt;/div&amp;gt;

      {/* 이메일 필드 */}
      &amp;lt;div&amp;gt;
        &amp;lt;label&amp;gt;이메일:&amp;lt;/label&amp;gt;
        &amp;lt;input
          type=&quot;email&quot;
          {...register(&apos;email&apos;, {
            required: &apos;이메일은 필수 항목입니다.&apos;,
            pattern: {
              value: /^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$/,
              message: &apos;유효한 이메일 주소를 입력해주세요.&apos;,
            },
          })}
        /&amp;gt;
        {errors.email &amp;amp;&amp;amp; &amp;lt;p style=&amp;gt;{errors.email.message}&amp;lt;/p&amp;gt;}
      &amp;lt;/div&amp;gt;

      {/* 비밀번호 필드 */}
      &amp;lt;div&amp;gt;
        &amp;lt;label&amp;gt;비밀번호:&amp;lt;/label&amp;gt;
        &amp;lt;input
          type=&quot;password&quot;
          {...register(&apos;password&apos;, {
            required: &apos;비밀번호는 필수 항목입니다.&apos;,
            minLength: {
              value: 6,
              message: &apos;비밀번호는 최소 6자 이상이어야 합니다.&apos;,
            },
          })}
        /&amp;gt;
        {errors.password &amp;amp;&amp;amp; &amp;lt;p style=&amp;gt;{errors.password.message}&amp;lt;/p&amp;gt;}
      &amp;lt;/div&amp;gt;

      &amp;lt;button type=&quot;submit&quot;&amp;gt;가입하기&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
  );
}

export default SignupForm;



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;설명:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;각 입력 필드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;register&lt;/code&gt; 함수를 통해 폼에 등록됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;required&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pattern&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;minLength&lt;/code&gt; 등의 검증 규칙을 설정하여 입력 값의 유효성을 검사합니다.&lt;/li&gt;
  &lt;li&gt;검증 오류가 발생할 경우, 해당 오류 메시지를 사용자에게 표시합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-validation-시스템-설계&quot;&gt;&lt;strong&gt;2. Validation 시스템 설계&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;React Hook Form은 강력하고 유연한 검증 시스템을 제공합니다. 기본적인 HTML5 검증 규칙 외에도, 커스텀 검증 로직을 쉽게 추가할 수 있으며, 외부 검증 라이브러리와의 통합도 용이합니다.&lt;/p&gt;

&lt;h3 id=&quot;검증-규칙-설정&quot;&gt;&lt;strong&gt;검증 규칙 설정:&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;기본 검증 규칙:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;required&lt;/code&gt;: 필수 입력 필드 설정&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pattern&lt;/code&gt;: 정규식을 이용한 패턴 매칭&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;minLength&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;maxLength&lt;/code&gt;: 입력 값의 최소/최대 길이 설정&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;validate&lt;/code&gt;: 커스텀 검증 함수 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;커스텀 검증:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;특정 조건에 따른 복잡한 검증 로직을 직접 구현할 수 있습니다.&lt;/li&gt;
      &lt;li&gt;예를 들어, 비밀번호에 숫자와 특수 문자가 포함되어 있는지 확인하는 검증을 추가할 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;예제-커스텀-검증-로직-추가&quot;&gt;&lt;strong&gt;예제: 커스텀 검증 로직 추가&lt;/strong&gt;&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
jsx
코드 복사
import React from &apos;react&apos;;
import { useForm } from &apos;react-hook-form&apos;;

function PasswordForm() {
  const { register, handleSubmit, formState: { errors } } = useForm();

  const onSubmit = data =&amp;gt; {
    console.log(&apos;제출된 데이터:&apos;, data);
  };

  const validatePassword = (value) =&amp;gt; {
    const hasNumber = /\d/.test(value);
    const hasSpecialChar = /[!@#$%^&amp;amp;*(),.?&quot;:{}|&amp;lt;&amp;gt;]/.test(value);
    if (!hasNumber) {
      return &apos;비밀번호에는 숫자가 포함되어야 합니다.&apos;;
    }
    if (!hasSpecialChar) {
      return &apos;비밀번호에는 특수 문자가 포함되어야 합니다.&apos;;
    }
    return true;
  };

  return (
    &amp;lt;form onSubmit={handleSubmit(onSubmit)}&amp;gt;
      {/* 비밀번호 필드 */}
      &amp;lt;div&amp;gt;
        &amp;lt;label&amp;gt;비밀번호:&amp;lt;/label&amp;gt;
        &amp;lt;input
          type=&quot;password&quot;
          {...register(&apos;password&apos;, {
            required: &apos;비밀번호는 필수 항목입니다.&apos;,
            minLength: {
              value: 6,
              message: &apos;비밀번호는 최소 6자 이상이어야 합니다.&apos;,
            },
            validate: validatePassword,
          })}
        /&amp;gt;
        {errors.password &amp;amp;&amp;amp; &amp;lt;p style=&amp;gt;{errors.password.message}&amp;lt;/p&amp;gt;}
      &amp;lt;/div&amp;gt;

      &amp;lt;button type=&quot;submit&quot;&amp;gt;제출&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
  );
}

export default PasswordForm;



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;설명:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;validate&lt;/code&gt; 속성을 사용하여 커스텀 검증 함수를 추가했습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;validatePassword&lt;/code&gt; 함수는 비밀번호에 숫자와 특수 문자가 포함되어 있는지 확인합니다.&lt;/li&gt;
  &lt;li&gt;검증에 실패할 경우, 적절한 오류 메시지를 반환하여 사용자에게 피드백을 제공합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;외부 검증 라이브러리 통합 (간략하게):&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;React Hook Form은 Yup과 같은 외부 검증 라이브러리와 쉽게 통합할 수 있습니다. 이를 통해 스키마 기반의 검증을 간편하게 구현할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
jsx
코드 복사
import React from &apos;react&apos;;
import { useForm } from &apos;react-hook-form&apos;;
import { yupResolver } from &apos;@hookform/resolvers/yup&apos;;
import * as Yup from &apos;yup&apos;;

// Yup 스키마 정의
const validationSchema = Yup.object().shape({
  name: Yup.string().required(&apos;이름은 필수 항목입니다.&apos;),
  email: Yup.string()
    .required(&apos;이메일은 필수 항목입니다.&apos;)
    .email(&apos;유효한 이메일 주소를 입력해주세요.&apos;),
  password: Yup.string()
    .required(&apos;비밀번호는 필수 항목입니다.&apos;)
    .min(6, &apos;비밀번호는 최소 6자 이상이어야 합니다.&apos;)
    .matches(/\d/, &apos;비밀번호에는 숫자가 포함되어야 합니다.&apos;)
    .matches(/[!@#$%^&amp;amp;*(),.?&quot;:{}|&amp;lt;&amp;gt;]/, &apos;비밀번호에는 특수 문자가 포함되어야 합니다.&apos;),
});

function SignupFormWithYup() {
  const { register, handleSubmit, formState: { errors } } = useForm({
    resolver: yupResolver(validationSchema),
  });

  const onSubmit = data =&amp;gt; {
    console.log(&apos;제출된 데이터:&apos;, data);
  };

  return (
    &amp;lt;form onSubmit={handleSubmit(onSubmit)}&amp;gt;
      {/* 이름 필드 */}
      &amp;lt;div&amp;gt;
        &amp;lt;label&amp;gt;이름:&amp;lt;/label&amp;gt;
        &amp;lt;input {...register(&apos;name&apos;)} /&amp;gt;
        {errors.name &amp;amp;&amp;amp; &amp;lt;p style=&amp;gt;{errors.name.message}&amp;lt;/p&amp;gt;}
      &amp;lt;/div&amp;gt;

      {/* 이메일 필드 */}
      &amp;lt;div&amp;gt;
        &amp;lt;label&amp;gt;이메일:&amp;lt;/label&amp;gt;
        &amp;lt;input type=&quot;email&quot; {...register(&apos;email&apos;)} /&amp;gt;
        {errors.email &amp;amp;&amp;amp; &amp;lt;p style=&amp;gt;{errors.email.message}&amp;lt;/p&amp;gt;}
      &amp;lt;/div&amp;gt;

      {/* 비밀번호 필드 */}
      &amp;lt;div&amp;gt;
        &amp;lt;label&amp;gt;비밀번호:&amp;lt;/label&amp;gt;
        &amp;lt;input type=&quot;password&quot; {...register(&apos;password&apos;)} /&amp;gt;
        {errors.password &amp;amp;&amp;amp; &amp;lt;p style=&amp;gt;{errors.password.message}&amp;lt;/p&amp;gt;}
      &amp;lt;/div&amp;gt;

      &amp;lt;button type=&quot;submit&quot;&amp;gt;가입하기&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
  );
}

export default SignupFormWithYup;



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-handlesubmit과-폼-제출-과정&quot;&gt;&lt;strong&gt;3.&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handleSubmit&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;과 폼 제출 과정&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handleSubmit&lt;/code&gt; 함수는 폼 제출 이벤트를 처리하는 메서드로, 폼 데이터를 수집하고 검증을 수행한 후, 유효한 데이터만을 콜백 함수로 전달합니다. 이 과정을 통해 폼 제출 시의 로직을 간결하게 관리할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;동작-방식-1&quot;&gt;&lt;strong&gt;동작 방식:&lt;/strong&gt;&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;폼 제출 이벤트 핸들링:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handleSubmit&lt;/code&gt;은 폼의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onSubmit&lt;/code&gt; 이벤트에 연결되어, 제출 시 자동으로 호출됩니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;검증 수행:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;폼 제출 시, 등록된 모든 필드에 대해 검증을 수행합니다.&lt;/li&gt;
      &lt;li&gt;검증에 실패한 필드가 있을 경우, 해당 오류 메시지를 업데이트하고 제출을 중단합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;콜백 함수 호출:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;모든 필드가 유효한 경우, 콜백 함수가 호출되며, 폼 데이터가 인수로 전달됩니다.&lt;/li&gt;
      &lt;li&gt;이 데이터를 활용하여 서버에 전송하거나, 다른 로직을 실행할 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;예제-handlesubmit-사용&quot;&gt;&lt;strong&gt;예제:&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handleSubmit&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;사용&lt;/strong&gt;&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
jsx
코드 복사
import React from &apos;react&apos;;
import { useForm } from &apos;react-hook-form&apos;;

function ContactForm() {
  const { register, handleSubmit, formState: { errors } } = useForm();

  const onSubmit = data =&amp;gt; {
    // 폼 데이터 처리 로직 (예: 서버에 전송)
    console.log(&apos;제출된 데이터:&apos;, data);
  };

  return (
    &amp;lt;form onSubmit={handleSubmit(onSubmit)}&amp;gt;
      {/* 이름 필드 */}
      &amp;lt;div&amp;gt;
        &amp;lt;label&amp;gt;이름:&amp;lt;/label&amp;gt;
        &amp;lt;input {...register(&apos;name&apos;, { required: &apos;이름은 필수 항목입니다.&apos; })} /&amp;gt;
        {errors.name &amp;amp;&amp;amp; &amp;lt;p style=&amp;gt;{errors.name.message}&amp;lt;/p&amp;gt;}
      &amp;lt;/div&amp;gt;

      {/* 메시지 필드 */}
      &amp;lt;div&amp;gt;
        &amp;lt;label&amp;gt;메시지:&amp;lt;/label&amp;gt;
        &amp;lt;textarea {...register(&apos;message&apos;, { required: &apos;메시지는 필수 항목입니다.&apos; })} /&amp;gt;
        {errors.message &amp;amp;&amp;amp; &amp;lt;p style=&amp;gt;{errors.message.message}&amp;lt;/p&amp;gt;}
      &amp;lt;/div&amp;gt;

      &amp;lt;button type=&quot;submit&quot;&amp;gt;제출&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
  );
}

export default ContactForm;



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;설명:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handleSubmit&lt;/code&gt; 함수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onSubmit&lt;/code&gt; 콜백과 연결되어, 폼 제출 시 자동으로 호출됩니다.&lt;/li&gt;
  &lt;li&gt;폼 데이터가 유효할 경우, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onSubmit&lt;/code&gt; 함수가 호출되어 데이터를 처리합니다.&lt;/li&gt;
  &lt;li&gt;검증에 실패한 필드가 있을 경우, 해당 오류 메시지가 표시되고, 콜백 함수는 호출되지 않습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-watch와-상태-구독-시스템&quot;&gt;&lt;strong&gt;4.&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;watch&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;와 상태 구독 시스템&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;watch&lt;/code&gt; 함수는 특정 폼 필드의 값을 실시간으로 추적하고, 그 변화를 구독할 수 있는 기능을 제공합니다. 이를 통해 입력 필드의 값에 따라 동적으로 UI를 업데이트하거나, 조건부 로직을 구현할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;동작-방식-2&quot;&gt;&lt;strong&gt;동작 방식:&lt;/strong&gt;&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;값 추적:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;watch&lt;/code&gt; 함수는 특정 필드의 현재 값을 반환하거나, 모든 필드의 값을 반환할 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;상태 구독:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;watch&lt;/code&gt;를 사용하여 특정 필드의 값 변화를 구독하고, 해당 값이 변경될 때마다 컴포넌트가 업데이트됩니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;동적 UI 업데이트:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;입력 필드의 값에 따라 동적으로 다른 컴포넌트를 표시하거나, 폼의 특정 부분을 활성화/비활성화할 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;예제-watch를-사용한-동적-ui-업데이트&quot;&gt;&lt;strong&gt;예제:&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;watch&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;를 사용한 동적 UI 업데이트&lt;/strong&gt;&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
jsx
코드 복사
import React from &apos;react&apos;;
import { useForm } from &apos;react-hook-form&apos;;

function SurveyForm() {
  const { register, handleSubmit, watch, formState: { errors } } = useForm();
  const hasPet = watch(&apos;hasPet&apos;, false); // 기본값은 false

  const onSubmit = data =&amp;gt; {
    console.log(&apos;제출된 데이터:&apos;, data);
  };

  return (
    &amp;lt;form onSubmit={handleSubmit(onSubmit)}&amp;gt;
      {/* 이름 필드 */}
      &amp;lt;div&amp;gt;
        &amp;lt;label&amp;gt;이름:&amp;lt;/label&amp;gt;
        &amp;lt;input {...register(&apos;name&apos;, { required: &apos;이름은 필수 항목입니다.&apos; })} /&amp;gt;
        {errors.name &amp;amp;&amp;amp; &amp;lt;p style=&amp;gt;{errors.name.message}&amp;lt;/p&amp;gt;}
      &amp;lt;/div&amp;gt;

      {/* 애완동물 여부 */}
      &amp;lt;div&amp;gt;
        &amp;lt;label&amp;gt;애완동물이 있나요?&amp;lt;/label&amp;gt;
        &amp;lt;input type=&quot;checkbox&quot; {...register(&apos;hasPet&apos;)} /&amp;gt;
      &amp;lt;/div&amp;gt;

      {/* 애완동물 이름 필드 (조건부 렌더링) */}
      {hasPet &amp;amp;&amp;amp; (
        &amp;lt;div&amp;gt;
          &amp;lt;label&amp;gt;애완동물 이름:&amp;lt;/label&amp;gt;
          &amp;lt;input {...register(&apos;petName&apos;, { required: &apos;애완동물 이름은 필수 항목입니다.&apos; })} /&amp;gt;
          {errors.petName &amp;amp;&amp;amp; &amp;lt;p style=&amp;gt;{errors.petName.message}&amp;lt;/p&amp;gt;}
        &amp;lt;/div&amp;gt;
      )}

      &amp;lt;button type=&quot;submit&quot;&amp;gt;제출&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
  );
}

export default SurveyForm;



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;설명:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;watch&lt;/code&gt; 함수를 사용하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hasPet&lt;/code&gt; 필드의 현재 값을 추적합니다.&lt;/li&gt;
  &lt;li&gt;사용자가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hasPet&lt;/code&gt; 체크박스를 선택하면, 애완동물 이름 입력 필드가 동적으로 표시됩니다.&lt;/li&gt;
  &lt;li&gt;이는 조건부 렌더링을 통해 사용자 경험을 향상시키고, 필요한 데이터만을 수집할 수 있게 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;watch와-getvalues의-차이점-및-팁&quot;&gt;&lt;strong&gt;Watch와 getValues의 차이점 및 팁&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;watch&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt; 실시간으로 필드의 변화를 추적하고, 해당 값이 변경될 때마다 컴포넌트를 리렌더링합니다. 이는 동적 UI 업데이트나 실시간 피드백이 필요한 경우에 유용합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getValues&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt; 현재 폼의 값을 즉시 가져오지만, 값의 변화에 따른 리렌더링을 유발하지 않습니다. 이는 특정 시점에 폼 데이터를 참조해야 할 때 유용합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;팁:&lt;/strong&gt;
언컨트롤드 컴포넌트의 관점에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;watch&lt;/code&gt;는 실시간으로 필드의 변화를 추적할 수 있게 해주므로, 조건부 렌더링이나 동적 UI 업데이트가 필요한 경우 필수적입니다. 반면, 단순히 폼 제출 시에만 데이터를 수집할 때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getValues&lt;/code&gt;를 사용하는 것이 더 효율적일 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;예제-watch와-getvalues의-활용&quot;&gt;&lt;strong&gt;예제:&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;watch&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;와&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getValues&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;의 활용&lt;/strong&gt;&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
jsx
코드 복사
import React from &apos;react&apos;;
import { useForm } from &apos;react-hook-form&apos;;

function ExampleForm() {
  const { register, handleSubmit, watch, getValues, formState: { errors } } = useForm();
  const watchField = watch(&apos;fieldToWatch&apos;, &apos;&apos;);

  const onSubmit = data =&amp;gt; {
    console.log(&apos;getValues로 가져온 데이터:&apos;, getValues());
    console.log(&apos;onSubmit 데이터:&apos;, data);
  };

  return (
    &amp;lt;form onSubmit={handleSubmit(onSubmit)}&amp;gt;
      {/* 추적할 필드 */}
      &amp;lt;div&amp;gt;
        &amp;lt;label&amp;gt;필드:&amp;lt;/label&amp;gt;
        &amp;lt;input {...register(&apos;fieldToWatch&apos;)} /&amp;gt;
      &amp;lt;/div&amp;gt;

      {/* 실시간 값 표시 */}
      &amp;lt;div&amp;gt;
        &amp;lt;p&amp;gt;실시간 값: {watchField}&amp;lt;/p&amp;gt;
      &amp;lt;/div&amp;gt;

      &amp;lt;button type=&quot;submit&quot;&amp;gt;제출&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
  );
}

export default ExampleForm;



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;설명:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;watch&lt;/code&gt;를 사용하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fieldToWatch&lt;/code&gt; 필드의 값을 실시간으로 추적하고, 해당 값을 화면에 표시합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getValues&lt;/code&gt;를 사용하여 폼 제출 시 현재 모든 값을 가져옵니다.&lt;/li&gt;
  &lt;li&gt;이처럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;watch&lt;/code&gt;는 실시간 상호작용을, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getValues&lt;/code&gt;는 특정 시점의 데이터를 참조하는 데 유용하게 활용됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;결론-1&quot;&gt;&lt;strong&gt;결론&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;React Hook Form의 주요 기능인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;register&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handleSubmit&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;validation&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;watch&lt;/code&gt;는 폼 상태 관리와 검증을 간결하고 효율적으로 처리할 수 있게 해줍니다. 이러한 기능들을 활용하면 복잡한 폼 로직도 손쉽게 구현할 수 있으며, 퍼포먼스 최적화와 코드의 유지보수성을 높일 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음 섹션에서는 React Hook Form의 성능 최적화 전략에 대해 자세히 살펴보겠습니다. 이를 통해 더욱 효율적인 폼 관리를 실현할 수 있을 것입니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;4-성능-최적화-1&quot;&gt;4. 성능 최적화&lt;/h2&gt;

&lt;p&gt;React Hook Form은 폼 관리의 효율성을 극대화하기 위해 다양한 성능 최적화 전략을 제공합니다. 이 섹션에서는 &lt;strong&gt;컨트롤드 컴포넌트(Controlled Components)&lt;/strong&gt;와 &lt;strong&gt;언컨트롤드 컴포넌트(Uncontrolled Components)&lt;/strong&gt;의 성능 차이를 이해하고, &lt;strong&gt;리렌더링 최소화 전략&lt;/strong&gt;과 &lt;strong&gt;메모이제이션 활용&lt;/strong&gt; 방법에 대해 자세히 살펴보겠습니다. 이를 통해 더욱 빠르고 효율적인 폼을 구현할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;1-컨트롤드-컴포넌트-vs-언컨트롤드-컴포넌트&quot;&gt;&lt;strong&gt;1. 컨트롤드 컴포넌트 vs 언컨트롤드 컴포넌트&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;앞서 살펴본 바와 같이, 리액트에서 폼을 관리하는 방식은 주로 컨트롤드 컴포넌트와 언컨트롤드 컴포넌트로 나뉩니다. 각 방식은 성능과 코드 구조 측면에서 고유한 특성을 가지고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;컨트롤드-컴포넌트-controlled-components-1&quot;&gt;&lt;strong&gt;컨트롤드 컴포넌트 (Controlled Components)&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;특징:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;입력 필드의 값을 리액트의 상태(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useState&lt;/code&gt;)로 관리합니다.&lt;/li&gt;
      &lt;li&gt;입력 값이 변경될 때마다 상태를 업데이트하고, 이에 따라 컴포넌트가 리렌더링됩니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;성능 측면:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;입력 필드가 많아질수록 상태 업데이트와 리렌더링이 빈번하게 발생하여 성능 저하가 발생할 수 있습니다.&lt;/li&gt;
      &lt;li&gt;각 입력 필드마다 상태 관리 로직이 필요하므로 코드가 복잡해질 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;언컨트롤드-컴포넌트-uncontrolled-components-1&quot;&gt;&lt;strong&gt;언컨트롤드 컴포넌트 (Uncontrolled Components)&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;특징:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;입력 필드의 값을 DOM 자체에서 관리합니다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ref&lt;/code&gt;를 사용하여 입력 값에 접근하거나, 폼 제출 시 값을 한꺼번에 수집합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;성능 측면:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;상태 관리가 최소화되므로 폼 필드가 많아도 리렌더링 비용이 적습니다.&lt;/li&gt;
      &lt;li&gt;입력 필드의 상태를 개별적으로 관리하지 않아 코드가 단순해집니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;성능-차이-요약&quot;&gt;&lt;strong&gt;성능 차이 요약&lt;/strong&gt;&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;컨트롤드 컴포넌트 (Controlled)&lt;/th&gt;
      &lt;th&gt;언컨트롤드 컴포넌트 (Uncontrolled)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;리렌더링 빈도&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;높음&lt;/td&gt;
      &lt;td&gt;낮음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;코드 복잡성&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;높음&lt;/td&gt;
      &lt;td&gt;낮음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;실시간 검증&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;용이&lt;/td&gt;
      &lt;td&gt;제한적&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;성능 최적화&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;어려움&lt;/td&gt;
      &lt;td&gt;용이&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;React Hook Form&lt;/strong&gt;은 언컨트롤드 컴포넌트를 기본으로 채택하여, 폼 필드가 많아도 높은 퍼포먼스를 유지할 수 있도록 설계되었습니다. 그러나 필요에 따라 컨트롤드 컴포넌트의 기능도 유연하게 활용할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;2-리렌더링-최소화-전략&quot;&gt;&lt;strong&gt;2. 리렌더링 최소화 전략&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;불필요한 리렌더링을 최소화하는 것은 리액트 애플리케이션의 성능을 향상시키는 핵심 요소 중 하나입니다. React Hook Form은 다음과 같은 전략을 통해 리렌더링을 효과적으로 최소화합니다.&lt;/p&gt;

&lt;h3 id=&quot;a-언컨트롤드-컴포넌트-사용&quot;&gt;&lt;strong&gt;a. 언컨트롤드 컴포넌트 사용&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;언컨트롤드 컴포넌트는 입력 필드의 상태를 리액트의 상태로 관리하지 않고 DOM에서 직접 관리하므로, 입력 값이 변경될 때마다 전체 폼 컴포넌트가 리렌더링되지 않습니다. 이는 리렌더링 횟수를 현저히 줄여 퍼포먼스를 향상시킵니다.&lt;/p&gt;

&lt;h3 id=&quot;b-register-함수의-최적화&quot;&gt;&lt;strong&gt;b.&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;register&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;함수의 최적화&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;register&lt;/code&gt; 함수는 입력 필드를 등록할 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ref&lt;/code&gt;를 통해 DOM 요소에 직접 접근하고, 필요한 이벤트 핸들러만을 설정합니다. 이를 통해 입력 값의 변화가 리렌더링을 유발하지 않도록 합니다.&lt;/p&gt;

&lt;h3 id=&quot;c-조건부-렌더링-최소화&quot;&gt;&lt;strong&gt;c. 조건부 렌더링 최소화&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;조건부 렌더링은 필요할 때만 특정 컴포넌트를 렌더링하여 리렌더링 횟수를 줄일 수 있습니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;watch&lt;/code&gt;를 사용하여 특정 조건이 만족될 때만 컴포넌트를 렌더링하도록 설정할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;d-분리된-컴포넌트-구조&quot;&gt;&lt;strong&gt;d. 분리된 컴포넌트 구조&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;폼을 여러 개의 작은 컴포넌트로 분리하여 관리하면, 특정 필드의 변화가 전체 폼 컴포넌트를 리렌더링하지 않고 해당 필드만 리렌더링되도록 할 수 있습니다. 이를 통해 리렌더링 범위를 최소화할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;예제-리렌더링-최소화를-위한-컴포넌트-분리&quot;&gt;&lt;strong&gt;예제: 리렌더링 최소화를 위한 컴포넌트 분리&lt;/strong&gt;&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
jsx
코드 복사
// ParentForm.js
import React from &apos;react&apos;;
import { useForm, FormProvider } from &apos;react-hook-form&apos;;
import NameField from &apos;./NameField&apos;;
import EmailField from &apos;./EmailField&apos;;
import PasswordField from &apos;./PasswordField&apos;;

function ParentForm() {
  const methods = useForm();

  const onSubmit = data =&amp;gt; {
    console.log(&apos;제출된 데이터:&apos;, data);
  };

  return (
    &amp;lt;FormProvider {...methods}&amp;gt;
      &amp;lt;form onSubmit={methods.handleSubmit(onSubmit)}&amp;gt;
        &amp;lt;NameField /&amp;gt;
        &amp;lt;EmailField /&amp;gt;
        &amp;lt;PasswordField /&amp;gt;
        &amp;lt;button type=&quot;submit&quot;&amp;gt;가입하기&amp;lt;/button&amp;gt;
      &amp;lt;/form&amp;gt;
    &amp;lt;/FormProvider&amp;gt;
  );
}

export default ParentForm;

// NameField.js
import React from &apos;react&apos;;
import { useFormContext } from &apos;react-hook-form&apos;;

function NameField() {
  const { register, formState: { errors } } = useFormContext();

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;label&amp;gt;이름:&amp;lt;/label&amp;gt;
      &amp;lt;input {...register(&apos;name&apos;, { required: &apos;이름은 필수 항목입니다.&apos; })} /&amp;gt;
      {errors.name &amp;amp;&amp;amp; &amp;lt;p style=&amp;gt;{errors.name.message}&amp;lt;/p&amp;gt;}
    &amp;lt;/div&amp;gt;
  );
}

export default React.memo(NameField);

// EmailField.js
import React from &apos;react&apos;;
import { useFormContext } from &apos;react-hook-form&apos;;

function EmailField() {
  const { register, formState: { errors } } = useFormContext();

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;label&amp;gt;이메일:&amp;lt;/label&amp;gt;
      &amp;lt;input
        type=&quot;email&quot;
        {...register(&apos;email&apos;, {
          required: &apos;이메일은 필수 항목입니다.&apos;,
          pattern: {
            value: /^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$/,
            message: &apos;유효한 이메일 주소를 입력해주세요.&apos;,
          },
        })}
      /&amp;gt;
      {errors.email &amp;amp;&amp;amp; &amp;lt;p style=&amp;gt;{errors.email.message}&amp;lt;/p&amp;gt;}
    &amp;lt;/div&amp;gt;
  );
}

export default React.memo(EmailField);

// PasswordField.js
import React from &apos;react&apos;;
import { useFormContext } from &apos;react-hook-form&apos;;

function PasswordField() {
  const { register, formState: { errors } } = useFormContext();

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;label&amp;gt;비밀번호:&amp;lt;/label&amp;gt;
      &amp;lt;input
        type=&quot;password&quot;
        {...register(&apos;password&apos;, {
          required: &apos;비밀번호는 필수 항목입니다.&apos;,
          minLength: {
            value: 6,
            message: &apos;비밀번호는 최소 6자 이상이어야 합니다.&apos;,
          },
        })}
      /&amp;gt;
      {errors.password &amp;amp;&amp;amp; &amp;lt;p style=&amp;gt;{errors.password.message}&amp;lt;/p&amp;gt;}
    &amp;lt;/div&amp;gt;
  );
}

export default React.memo(PasswordField);



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;설명:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;컴포넌트 분리:&lt;/strong&gt; 각 입력 필드를 별도의 컴포넌트(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NameField&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EmailField&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PasswordField&lt;/code&gt;)로 분리하여 관리합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React.memo&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;사용:&lt;/strong&gt; 각 필드 컴포넌트를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React.memo&lt;/code&gt;로 감싸면, 해당 필드의 props가 변경되지 않는 한 리렌더링되지 않습니다. 이는 불필요한 리렌더링을 방지하여 성능을 최적화합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FormProvider&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;와&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useFormContext&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt; 폼 상태를 Context API를 통해 하위 컴포넌트와 공유하여, 각 컴포넌트가 독립적으로 폼 상태에 접근하고 관리할 수 있도록 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-메모이제이션-활용&quot;&gt;&lt;strong&gt;3. 메모이제이션 활용&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;메모이제이션은 리액트 컴포넌트의 성능을 최적화하는 중요한 기법 중 하나입니다. React Hook Form과 함께 메모이제이션을 활용하면, 불필요한 컴포넌트 재생성을 줄이고, 리렌더링 비용을 최소화할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;a-reactmemo&quot;&gt;&lt;strong&gt;a.&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React.memo&lt;/code&gt;&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React.memo&lt;/code&gt;는 고차 컴포넌트(Higher-Order Component)로, 컴포넌트의 props가 변경되지 않으면 리렌더링을 방지합니다. 주로 함수형 컴포넌트에서 사용되며, 컴포넌트의 성능을 향상시킬 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;예제:&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React.memo&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;사용&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
jsx
코드 복사
import React from &apos;react&apos;;
import { useFormContext } from &apos;react-hook-form&apos;;

const OptimizedInputField = React.memo(({ name, label, type = &apos;text&apos; }) =&amp;gt; {
  const { register, formState: { errors } } = useFormContext();

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;label&amp;gt;{label}:&amp;lt;/label&amp;gt;
      &amp;lt;input type={type} {...register(name, { required: `${label}은 필수 항목입니다.` })} /&amp;gt;
      {errors[name] &amp;amp;&amp;amp; &amp;lt;p style=&amp;gt;{errors[name].message}&amp;lt;/p&amp;gt;}
    &amp;lt;/div&amp;gt;
  );
});

export default OptimizedInputField;



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;설명:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;컴포넌트 감싸기:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OptimizedInputField&lt;/code&gt; 컴포넌트를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React.memo&lt;/code&gt;로 감싸면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;label&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type&lt;/code&gt; 등의 props가 변경되지 않는 한 컴포넌트가 리렌더링되지 않습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;성능 향상:&lt;/strong&gt; 폼 필드가 많아질수록 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React.memo&lt;/code&gt;를 사용하여 각 필드의 리렌더링을 최소화함으로써 전체 폼의 성능을 향상시킬 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;b-usecallback과-usememo&quot;&gt;&lt;strong&gt;b.&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useCallback&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;과&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useMemo&lt;/code&gt;&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useCallback&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useMemo&lt;/code&gt;는 함수와 값을 메모이제이션하는 데 사용되는 리액트 훅입니다. 이를 활용하여 컴포넌트의 불필요한 재생성을 방지할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;예제:&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useCallback&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;사용&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
jsx
코드 복사
import React, { useCallback } from &apos;react&apos;;
import { useForm } from &apos;react-hook-form&apos;;

function MemoizedForm() {
  const { register, handleSubmit, formState: { errors } } = useForm();

  const onSubmit = useCallback(data =&amp;gt; {
    console.log(&apos;제출된 데이터:&apos;, data);
  }, []);

  return (
    &amp;lt;form onSubmit={handleSubmit(onSubmit)}&amp;gt;
      &amp;lt;div&amp;gt;
        &amp;lt;label&amp;gt;이름:&amp;lt;/label&amp;gt;
        &amp;lt;input {...register(&apos;name&apos;, { required: &apos;이름은 필수 항목입니다.&apos; })} /&amp;gt;
        {errors.name &amp;amp;&amp;amp; &amp;lt;p style=&amp;gt;{errors.name.message}&amp;lt;/p&amp;gt;}
      &amp;lt;/div&amp;gt;
      &amp;lt;button type=&quot;submit&quot;&amp;gt;제출&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
  );
}

export default React.memo(MemoizedForm);



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;설명:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useCallback&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;사용:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onSubmit&lt;/code&gt; 함수를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useCallback&lt;/code&gt;으로 감싸면, 컴포넌트가 리렌더링될 때마다 함수가 재생성되지 않습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React.memo&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;와 함께 사용:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React.memo&lt;/code&gt;와 함께 사용하면, props가 변경되지 않는 한 컴포넌트가 리렌더링되지 않습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-react-hook-form에서의-최적화-팁&quot;&gt;&lt;strong&gt;4. React Hook Form에서의 최적화 팁&lt;/strong&gt;&lt;/h3&gt;

&lt;h3 id=&quot;a-필드-컴포넌트-분리와-reactmemo-사용&quot;&gt;&lt;strong&gt;a. 필드 컴포넌트 분리와&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React.memo&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;사용&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;입력 필드를 별도의 컴포넌트로 분리하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React.memo&lt;/code&gt;를 사용하면, 각 필드의 변경이 전체 폼의 리렌더링을 유발하지 않도록 할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;b-usewatch-사용-최소화&quot;&gt;&lt;strong&gt;b.&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useWatch&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;사용 최소화&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;watch&lt;/code&gt;나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useWatch&lt;/code&gt;는 입력 필드의 변화를 추적하므로, 사용 시 리렌더링을 유발할 수 있습니다. 필요한 경우에만 사용하고, 불필요한 사용을 피하는 것이 좋습니다.&lt;/p&gt;

&lt;h3 id=&quot;c-폼-데이터-수집-시점-최적화&quot;&gt;&lt;strong&gt;c. 폼 데이터 수집 시점 최적화&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;폼 제출 시에만 데이터를 수집하도록 설정하여, 실시간 데이터 추적을 최소화하면 성능을 더욱 향상시킬 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;d-최적화된-검증-로직-구현&quot;&gt;&lt;strong&gt;d. 최적화된 검증 로직 구현&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;검증 로직이 복잡할 경우, 필요한 경우에만 실행되도록 최적화하여 리렌더링 비용을 줄일 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;결론-2&quot;&gt;&lt;strong&gt;결론&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;React Hook Form은 언컨트롤드 컴포넌트 방식을 기본으로 채택하여 폼 관리의 성능을 최적화합니다. 리렌더링 최소화 전략과 메모이제이션 활용을 통해 높은 퍼포먼스를 유지하면서도, 복잡한 폼 로직을 효율적으로 관리할 수 있습니다. 이러한 최적화 기법을 적절히 활용하면, 대규모 폼에서도 뛰어난 사용자 경험을 제공할 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음 섹션에서는 React Hook Form의 실제 사용 사례를 통해 다양한 상황에서의 활용 방법을 살펴보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;마무리&quot;&gt;마무리&lt;/h2&gt;

&lt;h3 id=&quot;react-hook-form의-장단점&quot;&gt;&lt;strong&gt;React Hook Form의 장단점&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;React Hook Form은 현대 리액트 애플리케이션에서 복잡한 폼을 효율적으로 관리할 수 있도록 다양한 기능과 최적화 기법을 제공합니다. 그러나 모든 도구와 마찬가지로, 장단점이 존재합니다.&lt;/p&gt;

&lt;h3 id=&quot;장점&quot;&gt;&lt;strong&gt;장점:&lt;/strong&gt;&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;퍼포먼스 최적화:&lt;/strong&gt; 언컨트롤드 컴포넌트 방식을 기본으로 채택하여, 많은 입력 필드가 있어도 리렌더링을 최소화하고 높은 퍼포먼스를 유지합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;간결한 API:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useForm&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;register&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handleSubmit&lt;/code&gt; 등의 간단하고 직관적인 API를 제공하여, 폼 관리가 용이합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유연한 검증 시스템:&lt;/strong&gt; 기본적인 검증 규칙 외에도 커스텀 검증 로직을 쉽게 추가할 수 있으며, Yup과 같은 외부 검증 라이브러리와의 통합을 지원합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;컴포넌트 재사용성:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FormProvider&lt;/code&gt;와 Context API를 활용하여, 폼 상태를 여러 컴포넌트 간에 쉽게 공유하고 재사용할 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;단점&quot;&gt;&lt;strong&gt;단점:&lt;/strong&gt;&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;학습 곡선:&lt;/strong&gt; React Hook Form의 다양한 기능과 최적화 기법을 모두 숙지하는 데 시간이 걸릴 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;복잡한 커스텀 로직:&lt;/strong&gt; 매우 복잡한 폼 로직을 구현할 때는, 일부 경우에 기존의 컨트롤드 컴포넌트 방식이 더 직관적일 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;제한된 내장 기능:&lt;/strong&gt; 특정 고급 기능(예: 특정 UI 라이브러리와의 완벽한 통합)은 추가적인 설정이나 커스텀이 필요할 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;사용-시-주의사항&quot;&gt;&lt;strong&gt;사용 시 주의사항&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;React Hook Form을 효과적으로 사용하기 위해서는 몇 가지 주의사항을 염두에 두어야 합니다:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;입력 필드 등록 필수:&lt;/strong&gt; 모든 입력 필드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;register&lt;/code&gt; 함수를 통해 등록되어야 합니다. 등록하지 않은 필드는 폼 데이터에 포함되지 않습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;동적 필드 관리:&lt;/strong&gt; 동적으로 입력 필드를 추가하거나 제거할 때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useFieldArray&lt;/code&gt; 훅을 사용하여 폼 상태를 일관되게 관리해야 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비동기 검증 로직 처리:&lt;/strong&gt; 비동기 검증 로직을 구현할 때는, 사용자가 입력을 완료한 후에 검증을 수행하도록 적절한 이벤트 핸들러(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onBlur&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onChange&lt;/code&gt; 등)를 설정해야 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;최적화 기법 활용:&lt;/strong&gt; 폼이 복잡하거나 입력 필드가 많은 경우, 컴포넌트 분리와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React.memo&lt;/code&gt; 사용 등을 통해 리렌더링을 최소화해야 합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;React Hook Form&lt;/strong&gt;은 이들 라이브러리와 비교하여, &lt;strong&gt;높은 퍼포먼스&lt;/strong&gt;와 &lt;strong&gt;간결한 API&lt;/strong&gt;를 제공하면서도 &lt;strong&gt;유연한 검증 시스템&lt;/strong&gt;을 지원합니다. 특히, &lt;strong&gt;언컨트롤드 컴포넌트&lt;/strong&gt; 방식을 통해 리렌더링을 최소화하여, 복잡한 폼에서도 뛰어난 퍼포먼스를 유지할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;추가-학습-자료&quot;&gt;&lt;strong&gt;추가 학습 자료&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;React Hook Form의 깊은 이해와 활용을 위해 다음과 같은 리소스를 참고하세요:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;공식 문서:&lt;/strong&gt; &lt;a href=&quot;https://react-hook-form.com/&quot;&gt;React Hook Form Documentation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GitHub 레포지토리:&lt;/strong&gt; &lt;a href=&quot;https://github.com/react-hook-form/react-hook-form&quot;&gt;React Hook Form GitHub&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;튜토리얼 및 블로그 포스트:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;How to Use React Hook Form&lt;/li&gt;
      &lt;li&gt;Building Forms with React Hook Form&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;커뮤니티:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/tagged/react-hook-form&quot;&gt;Stack Overflow: React Hook Form&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/react-hook-form/react-hook-form/discussions&quot;&gt;React Hook Form Discussions&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;React Hook Form은 현대 리액트 애플리케이션에서 폼 관리를 혁신적으로 단순화하고, 높은 퍼포먼스와 유연성을 제공합니다. 컨트롤드 컴포넌트의 한계를 극복하고, 언컨트롤드 컴포넌트의 장점을 극대화하여, 복잡한 폼도 효율적으로 관리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://jskdev.vercel.app/docs/dev/React/React-Hook-Form/2024-11-23-React-Hook-Form/&quot;&gt;bookmark&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;1-기본-개념-이해&quot;&gt;1. 기본 개념 이해&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;controlled vs uncontrolled&lt;/li&gt;
  &lt;li&gt;useForm 훅 동작 원리 및 핵심 메서드 파악&lt;/li&gt;
  &lt;li&gt;폼 상태 관리의 성능 최적화 방식&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-핵심-기능-구현&quot;&gt;2. 핵심 기능 구현&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;register 함수 구현 - 폼 필드 등록하고 검증하는 방식&lt;/li&gt;
  &lt;li&gt;handleSubmit 함수 동작 방식 파악&lt;/li&gt;
  &lt;li&gt;폼 상태 관리를 위한 내부 상태 관리 메커니즘 파악&lt;/li&gt;
  &lt;li&gt;validation 로직 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-고급-기능-탐구&quot;&gt;3. 고급 기능 탐구&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;watch 기능 파악&lt;/li&gt;
  &lt;li&gt;formState 관리 방식&lt;/li&gt;
  &lt;li&gt;error 핸들링 방식&lt;/li&gt;
  &lt;li&gt;중첩 폼 필드 처리&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://react-hook-form.com/get-started&quot;&gt;https://react-hook-form.com/get-started&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/react-hook-form/react-hook-form/releases/tag/v1.0.0&quot;&gt;https://github.com/react-hook-form/react-hook-form/releases/tag/v1.0.0&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;register: 필드 등록과 이벤트 바인딩&lt;/li&gt;
  &lt;li&gt;handleSubmit: 제출 로직과 검증&lt;/li&gt;
  &lt;li&gt;formState: 상태 추적과 에러 관리&lt;/li&gt;
  &lt;li&gt;watch: 반응형 업데이트와 의존성 처리&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-register-함수의-역할-이해하기&quot;&gt;&lt;strong&gt;1.&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;register&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;함수의 역할 이해하기&lt;/strong&gt;&lt;/h2&gt;

&lt;h3 id=&quot;주요-역할&quot;&gt;&lt;strong&gt;주요 역할:&lt;/strong&gt;&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;입력 필드 등록:&lt;/strong&gt; 폼에 있는 각 입력 필드를 추적할 수 있도록 등록합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;값 추적:&lt;/strong&gt; 입력 필드의 현재 값을 추적하고 필요 시 가져올 수 있게 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;검증 로직 적용:&lt;/strong&gt; 입력 값에 대한 유효성 검사를 수행합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;성능 최적화:&lt;/strong&gt; 리렌더링을 최소화하여 성능을 최적화합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;react-hook-form의-register-vs-controlled-components&quot;&gt;&lt;strong&gt;React Hook Form의&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;register&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;vs Controlled Components:&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;React Hook Form의&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;register&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;언컨트롤드 컴포넌트 방식을 사용하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ref&lt;/code&gt;를 통해 DOM 요소에 직접 접근합니다.&lt;/li&gt;
      &lt;li&gt;입력 값의 변경 시 상태를 업데이트하지 않아 리렌더링을 최소화합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Controlled Components:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useState&lt;/code&gt; 등을 사용하여 입력 값의 상태를 React 상태로 관리합니다.&lt;/li&gt;
      &lt;li&gt;입력 값이 변경될 때마다 상태가 업데이트되어 리렌더링이 발생합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
import { useRef } from &apos;react&apos;;

function useForm() {
  const formRef = useRef({});
  
  const register = (name) =&amp;gt; {
    return {
      name,
      ref: (el) =&amp;gt; {
        formRef.current[name] = el;
      }
    };
  };
  
  const handleSubmit = (callback) =&amp;gt; (event) =&amp;gt; {
    event.preventDefault();
    const data = {};
    for (const name in formRef.current) {
      data[name] = formRef.current[name].value;
    }
    callback(data);
  };
  
  return { register, handleSubmit };
}

export default useForm;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
interface FieldValues {
  [key: string]: any;
}

type RegisterOptions = {
  required?: boolean | string;
  validate?: (value: any) =&amp;gt; boolean | string;
}

function useForm&amp;lt;T extends FieldValues&amp;gt;() {
// 1. 폼 데이터를 관리하는 저장소
  const fieldsRef = useRef&amp;lt;T&amp;gt;({} as T);

// 2. 검증 규칙을 저장하는 저장소
  const validationRef = useRef&amp;lt;Record&amp;lt;keyof T, RegisterOptions&amp;gt;&amp;gt;({} as Record&amp;lt;keyof T, RegisterOptions&amp;gt;);

// 3. 에러 상태 관리
  const [errors, setErrors] = useState&amp;lt;Partial&amp;lt;Record&amp;lt;keyof T, string&amp;gt;&amp;gt;&amp;gt;({});

// 4. register: 필드 등록 및 이벤트 바인딩
  const register = (name: keyof T, options: RegisterOptions = {}) =&amp;gt; {
// 검증 규칙 저장
    validationRef.current[name] = options;

// 필드에 바인딩될 props 반환
    return {
      name,
      onChange: (e: ChangeEvent&amp;lt;HTMLInputElement&amp;gt;) =&amp;gt; {
// 값 업데이트
        fieldsRef.current[name] = e.target.value;

// 에러 검증
        validateField(name, e.target.value);
      },
      value: fieldsRef.current[name] || &apos;&apos;
    };
  };

// 5. 필드 검증 로직
  const validateField = (name: keyof T, value: any) =&amp;gt; {
    const rules = validationRef.current[name];
    if (!rules) return;

    let error = &apos;&apos;;

    if (rules.required) {
      const message = typeof rules.required === &apos;string&apos; ? rules.required : &apos;필수 값입니다&apos;;
      if (!value) error = message;
    }

    if (rules.validate &amp;amp;&amp;amp; !error) {
      const result = rules.validate(value);
      if (typeof result === &apos;string&apos;) error = result;
      if (result === false) error = &apos;유효하지 않은 값입니다&apos;;
    }

    setErrors(prev =&amp;gt; ({
      ...prev,
      [name]: error
    }));
  };

// 6. 폼 제출 핸들러
  const handleSubmit = (onSubmit: (data: T) =&amp;gt; void) =&amp;gt; {
    return (e: FormEvent) =&amp;gt; {
      e.preventDefault();
      onSubmit(fieldsRef.current);
    };
  };

  return {
    register,
    handleSubmit,
    errors
  };
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;주요 컨셉 설명:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;값 관리 전략&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
typescript
Copy
const fieldsRef = useRef&amp;lt;T&amp;gt;({} as T);


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;useState 대신 useRef를 사용하여 불필요한 리렌더링 방지&lt;/li&gt;
  &lt;li&gt;폼 데이터를 중앙 집중식으로 관리
    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;등록 메커니즘&lt;/strong&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
typescript
Copy
const register = (name: keyof T, options = {}) =&amp;gt; {
  return {
    name,
    onChange: (e) =&amp;gt; {
      fieldsRef.current[name] = e.target.value;
    },
    value: fieldsRef.current[name] || &apos;&apos;
  };
};


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;필드를 등록하고 이벤트를 바인딩하는 단일 진입점&lt;/li&gt;
  &lt;li&gt;Props spreading을 통한 간편한 사용성
    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;검증 시스템&lt;/strong&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
typescript
Copy
const validationRef = useRef&amp;lt;Record&amp;lt;keyof T, RegisterOptions&amp;gt;&amp;gt;({} as Record&amp;lt;keyof T, RegisterOptions&amp;gt;);

const validateField = (name: keyof T, value: any) =&amp;gt; {
  const rules = validationRef.current[name];
// 검증 로직...
};


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;검증 규칙을 별도 저장소에서 관리&lt;/li&gt;
  &lt;li&gt;필요할 때만 검증 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사용 예시:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
typescript
Copy
function SignupForm() {
  const { register, handleSubmit, errors } = useForm&amp;lt;{
    email: string;
    password: string;
  }&amp;gt;();

  const onSubmit = (data) =&amp;gt; {
    console.log(data);
  };

  return (
    &amp;lt;form onSubmit={handleSubmit(onSubmit)}&amp;gt;
      &amp;lt;input
        {...register(&apos;email&apos;, {
          required: &apos;이메일을 입력해주세요&apos;,
          validate: (value) =&amp;gt; value.includes(&apos;@&apos;) || &apos;유효한 이메일을 입력해주세요&apos;
        })}
      /&amp;gt;
      {errors.email &amp;amp;&amp;amp; &amp;lt;span&amp;gt;{errors.email}&amp;lt;/span&amp;gt;}

      &amp;lt;input
        type=&quot;password&quot;
        {...register(&apos;password&apos;, {
          required: true
        })}
      /&amp;gt;
      {errors.password &amp;amp;&amp;amp; &amp;lt;span&amp;gt;{errors.password}&amp;lt;/span&amp;gt;}

      &amp;lt;button type=&quot;submit&quot;&amp;gt;가입하기&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
  );
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;Jisukim&quot;]</name>
        
        
      </author>

      

      

      
        <summary type="html">리액트 훅 폼</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Input 이미지 처리 방식</title>
      <link href="https://blog.liboo.kr/Input_%EC%9D%B4%EB%AF%B8%EC%A7%80_%EC%B2%98%EB%A6%AC_%EB%B0%A9%EC%8B%9D" rel="alternate" type="text/html" title="Input 이미지 처리 방식" />
      <published>2024-11-20T06:08:00+00:00</published>
      <updated>2024-11-20T06:08:00+00:00</updated>
      <id>https://blog.liboo.kr/Input_%EC%9D%B4%EB%AF%B8%EC%A7%80_%EC%B2%98%EB%A6%AC_%EB%B0%A9%EC%8B%9D</id>
      <content type="html" xml:base="https://blog.liboo.kr/Input_%EC%9D%B4%EB%AF%B8%EC%A7%80_%EC%B2%98%EB%A6%AC_%EB%B0%A9%EC%8B%9D">&lt;p&gt;Base64 방식과 FormData 방식의 장단점을 정리합니다.&lt;/p&gt;

&lt;h3 id=&quot;1-base64-방식&quot;&gt;1. Base64 방식&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;장점:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;즉각적인 미리보기 가능 (별도의 URL 생성 불필요)&lt;/li&gt;
  &lt;li&gt;단일 HTTP 요청으로 처리 가능&lt;/li&gt;
  &lt;li&gt;JSON 페이로드에 직접 포함 가능&lt;/li&gt;
  &lt;li&gt;바이너리 데이터를 텍스트로 안전하게 전송&lt;/li&gt;
  &lt;li&gt;클라이언트에서 이미지 처리/조작이 용이&lt;/li&gt;
  &lt;li&gt;AJAX 요청과 함께 보내기 쉬움&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;단점:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파일 크기가 약 33% 증가 (인코딩 오버헤드)&lt;/li&gt;
  &lt;li&gt;브라우저 메모리 사용량 증가&lt;/li&gt;
  &lt;li&gt;대용량 파일 처리에 부적합&lt;/li&gt;
  &lt;li&gt;인코딩/디코딩 과정에서 CPU 리소스 사용&lt;/li&gt;
  &lt;li&gt;서버 부하 증가 가능성&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;적합한 사용 사례:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
// Base64 적합 사례
const handleSmallImage = async (file: File) =&amp;gt; {
// 1MB 이하의 작은 이미지
  if (file.size &amp;lt;= 1 * 1024 * 1024) {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () =&amp;gt; {
// 즉시 미리보기 가능
      setPreviewImage(reader.result as string);
// 바로 JSON으로 전송 가능
      uploadImage({ image: reader.result });
    };
  }
};


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-formdata-방식&quot;&gt;2. FormData 방식&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;장점:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;원본 파일 유지 (데이터 손실 없음)&lt;/li&gt;
  &lt;li&gt;메모리 효율적&lt;/li&gt;
  &lt;li&gt;대용량 파일 전송에 적합&lt;/li&gt;
  &lt;li&gt;멀티파트 요청으로 파일 전송 최적화&lt;/li&gt;
  &lt;li&gt;프로그레스 모니터링 용이&lt;/li&gt;
  &lt;li&gt;여러 파일 동시 전송 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;단점:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;추가적인 HTTP 요청 필요할 수 있음&lt;/li&gt;
  &lt;li&gt;미리보기를 위한 별도 처리 필요&lt;/li&gt;
  &lt;li&gt;브라우저 호환성 고려 필요&lt;/li&gt;
  &lt;li&gt;전송 과정이 상대적으로 복잡&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;적합한 사용 사례:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
// FormData 적합 사례
const handleLargeFile = async (file: File) =&amp;gt; {
  const formData = new FormData();
  formData.append(&apos;file&apos;, file);

  try {
    const response = await axios.post(&apos;/upload&apos;, formData, {
      headers: {
        &apos;Content-Type&apos;: &apos;multipart/form-data&apos;
      },
      onUploadProgress: (progressEvent) =&amp;gt; {
        const progress = (progressEvent.loaded / (progressEvent.total || 0)) * 100;
        setUploadProgress(progress);
      }
    });

// 업로드 후 URL을 받아서 처리
    setImageUrl(response.data.url);
  } catch (error) {
    console.error(&apos;Upload failed:&apos;, error);
  }
};


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;선택-가이드&quot;&gt;선택 가이드&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Base64 선택:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;파일 크기가 작은 경우 (1MB 이하)&lt;/li&gt;
  &lt;li&gt;즉각적인 미리보기가 필요한 경우&lt;/li&gt;
  &lt;li&gt;이미지 처리가 클라이언트에서 필요한 경우&lt;/li&gt;
  &lt;li&gt;단순한 구현이 필요한 경우&lt;/li&gt;
  &lt;li&gt;썸네일이나 프로필 이미지와 같은 작은 이미지&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
// Base64 사용 예시
if (file.size &amp;lt;= 1 * 1024 * 1024) {
  const base64 = await convertToBase64(file);
// 즉시 미리보기 가능
  setPreview(base64);
// 바로 API 전송
  await uploadImage({ image: base64 });
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;FormData 선택:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;대용량 파일 전송 (1MB 초과)&lt;/li&gt;
  &lt;li&gt;원본 품질 유지가 중요한 경우&lt;/li&gt;
  &lt;li&gt;다중 파일 업로드가 필요한 경우&lt;/li&gt;
  &lt;li&gt;업로드 진행률 표시가 필요한 경우&lt;/li&gt;
  &lt;li&gt;서버 리소스 최적화가 중요한 경우&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
// FormData 사용 예시
const formData = new FormData();
formData.append(&apos;file&apos;, file);
formData.append(&apos;type&apos;, &apos;original&apos;);

// 프로그레스 모니터링 가능
await axios.post(&apos;/upload&apos;, formData, {
  onUploadProgress: (e) =&amp;gt; {
    const progress = (e.loaded / (e.total || 0)) * 100;
    setProgress(progress);
  }
});


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;Jisukim&quot;]</name>
        
        
      </author>

      

      

      
        <summary type="html">Base64 방식과 FormData 방식의 장단점을 정리합니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">삭제한 브랜치 remote 정리</title>
      <link href="https://blog.liboo.kr/%EC%82%AD%EC%A0%9C%ED%95%9C_%EB%B8%8C%EB%9E%9C%EC%B9%98_remote_%EC%A0%95%EB%A6%AC" rel="alternate" type="text/html" title="삭제한 브랜치 remote 정리" />
      <published>2024-11-18T12:27:00+00:00</published>
      <updated>2024-11-18T12:27:00+00:00</updated>
      <id>https://blog.liboo.kr/%EC%82%AD%EC%A0%9C%ED%95%9C_%EB%B8%8C%EB%9E%9C%EC%B9%98_remote_%EC%A0%95%EB%A6%AC</id>
      <content type="html" xml:base="https://blog.liboo.kr/%EC%82%AD%EC%A0%9C%ED%95%9C_%EB%B8%8C%EB%9E%9C%EC%B9%98_remote_%EC%A0%95%EB%A6%AC">&lt;p&gt;git prune&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://ondemand.tistory.com/383&quot;&gt;https://ondemand.tistory.com/383&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git remote update&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shell
git remote prune {리모트명}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;Jisukim&quot;]</name>
        
        
      </author>

      

      

      
        <summary type="html">git prune</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">PR 슬랙봇으로 자동 리뷰 요청하기</title>
      <link href="https://blog.liboo.kr/PR_%EC%8A%AC%EB%9E%99%EB%B4%87%EC%9C%BC%EB%A1%9C_%EC%9E%90%EB%8F%99_%EB%A6%AC%EB%B7%B0_%EC%9A%94%EC%B2%AD%ED%95%98%EA%B8%B0" rel="alternate" type="text/html" title="PR 슬랙봇으로 자동 리뷰 요청하기" />
      <published>2024-11-13T02:14:00+00:00</published>
      <updated>2024-11-13T02:14:00+00:00</updated>
      <id>https://blog.liboo.kr/PR_%EC%8A%AC%EB%9E%99%EB%B4%87%EC%9C%BC%EB%A1%9C_%EC%9E%90%EB%8F%99_%EB%A6%AC%EB%B7%B0_%EC%9A%94%EC%B2%AD%ED%95%98%EA%B8%B0</id>
      <content type="html" xml:base="https://blog.liboo.kr/PR_%EC%8A%AC%EB%9E%99%EB%B4%87%EC%9C%BC%EB%A1%9C_%EC%9E%90%EB%8F%99_%EB%A6%AC%EB%B7%B0_%EC%9A%94%EC%B2%AD%ED%95%98%EA%B8%B0">&lt;p&gt;&lt;img src=&quot;/upload/2024-11-13-PR_슬랙봇으로_자동_리뷰_요청하기.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-11-13&lt;/em&gt;%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.18.11.png_&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-11-13-PR_슬랙봇으로_자동_리뷰_요청하기.md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-11-13&lt;/em&gt;%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.17.51.png_&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://api.slack.com/apps/A08151XRH2L/incoming-webhooks&quot;&gt;https://api.slack.com/apps/A08151XRH2L/incoming-webhooks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://ek12mv2.tistory.com/486&quot;&gt;https://ek12mv2.tistory.com/486&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://slack.com/intl/ko-kr/help/articles/221769328-Slack-URL-%EB%98%90%EB%8A%94-ID-%EC%B0%BE%EA%B8%B0&quot;&gt;https://slack.com/intl/ko-kr/help/articles/221769328-Slack-URL-%EB%98%90%EB%8A%94-ID-%EC%B0%BE%EA%B8%B0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://careerly.co.kr/comments/107297&quot;&gt;https://careerly.co.kr/comments/107297&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;Jisukim&quot;]</name>
        
        
      </author>

      

      

      
        <summary type="html">%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-11-13%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.18.11.png_</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">커스텀 react 스니펫 만들기</title>
      <link href="https://blog.liboo.kr/_%EC%BB%A4%EC%8A%A4%ED%85%80_react_%EC%8A%A4%EB%8B%88%ED%8E%AB_%EB%A7%8C%EB%93%A4%EA%B8%B0" rel="alternate" type="text/html" title=" 커스텀 react 스니펫 만들기" />
      <published>2024-11-08T04:25:00+00:00</published>
      <updated>2024-11-08T04:25:00+00:00</updated>
      <id>https://blog.liboo.kr/_%EC%BB%A4%EC%8A%A4%ED%85%80_react_%EC%8A%A4%EB%8B%88%ED%8E%AB_%EB%A7%8C%EB%93%A4%EA%B8%B0</id>
      <content type="html" xml:base="https://blog.liboo.kr/_%EC%BB%A4%EC%8A%A4%ED%85%80_react_%EC%8A%A4%EB%8B%88%ED%8E%AB_%EB%A7%8C%EB%93%A4%EA%B8%B0">&lt;p&gt;&lt;a href=&quot;https://jskdev.vercel.app/docs/dev/React/2024-11-08-custom-snippets/&quot;&gt;bookmark&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;Jisukim&quot;]</name>
        
        
      </author>

      

      

      
        <summary type="html">bookmark</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">반응형 비디오 플레이어 구현: 패딩 탑 기법</title>
      <link href="https://blog.liboo.kr/%EB%B0%98%EC%9D%91%ED%98%95_%EB%B9%84%EB%94%94%EC%98%A4_%ED%94%8C%EB%A0%88%EC%9D%B4%EC%96%B4_%EA%B5%AC%ED%98%84-_%ED%8C%A8%EB%94%A9_%ED%83%91_%EA%B8%B0%EB%B2%95" rel="alternate" type="text/html" title="반응형 비디오 플레이어 구현: 패딩 탑 기법" />
      <published>2024-11-08T02:52:00+00:00</published>
      <updated>2024-11-08T02:52:00+00:00</updated>
      <id>https://blog.liboo.kr/%EB%B0%98%EC%9D%91%ED%98%95_%EB%B9%84%EB%94%94%EC%98%A4_%ED%94%8C%EB%A0%88%EC%9D%B4%EC%96%B4_%EA%B5%AC%ED%98%84:_%ED%8C%A8%EB%94%A9_%ED%83%91_%EA%B8%B0%EB%B2%95</id>
      <content type="html" xml:base="https://blog.liboo.kr/%EB%B0%98%EC%9D%91%ED%98%95_%EB%B9%84%EB%94%94%EC%98%A4_%ED%94%8C%EB%A0%88%EC%9D%B4%EC%96%B4_%EA%B5%AC%ED%98%84-_%ED%8C%A8%EB%94%A9_%ED%83%91_%EA%B8%B0%EB%B2%95">&lt;p&gt;&lt;a href=&quot;https://jskdev.vercel.app/docs/dev/VideoStreaming/2024-11-07-padding-top/&quot;&gt;bookmark&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;Jisukim&quot;]</name>
        
        
      </author>

      

      

      
        <summary type="html">bookmark</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">패키지 매니저 및 모노레포 정하기</title>
      <link href="https://blog.liboo.kr/%ED%8C%A8%ED%82%A4%EC%A7%80_%EB%A7%A4%EB%8B%88%EC%A0%80_%EB%B0%8F_%EB%AA%A8%EB%85%B8%EB%A0%88%ED%8F%AC_%EC%A0%95%ED%95%98%EA%B8%B0" rel="alternate" type="text/html" title="패키지 매니저 및 모노레포 정하기" />
      <published>2024-10-31T05:59:00+00:00</published>
      <updated>2024-10-31T05:59:00+00:00</updated>
      <id>https://blog.liboo.kr/%ED%8C%A8%ED%82%A4%EC%A7%80_%EB%A7%A4%EB%8B%88%EC%A0%80_%EB%B0%8F_%EB%AA%A8%EB%85%B8%EB%A0%88%ED%8F%AC_%EC%A0%95%ED%95%98%EA%B8%B0</id>
      <content type="html" xml:base="https://blog.liboo.kr/%ED%8C%A8%ED%82%A4%EC%A7%80_%EB%A7%A4%EB%8B%88%EC%A0%80_%EB%B0%8F_%EB%AA%A8%EB%85%B8%EB%A0%88%ED%8F%AC_%EC%A0%95%ED%95%98%EA%B8%B0">&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;목차&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;패키지-매니저&quot;&gt;패키지 매니저&lt;/h1&gt;

&lt;p&gt;패키지 매니저의 등장 배경부터 시작하여 npm, Yarn, pnpm, Yarn Berry의 특징과 장단점을 분석하고, 팀 프로젝트에 가장 적합한 패키지 매니저를 선택한 이유를 제시합니다.&lt;/p&gt;

&lt;h2 id=&quot;패키지-매니저의-등장-배경&quot;&gt;패키지 매니저의 등장 배경&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;의존성 관리의 복잡성 증가&lt;/li&gt;
  &lt;li&gt;일관된 개발 환경 필요&lt;/li&gt;
  &lt;li&gt;배포 및 업데이트의 효율성&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;일반적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;package.json&lt;/code&gt; 파일에 디펜던시를 명시하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;npm install&lt;/code&gt; 혹은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yarn install&lt;/code&gt;을 하면, 해당 의존성의 명시된 버전을 설치하게 됩니다. 즉, &lt;strong&gt;패키지 매니저는 모호한 버저닝 문제를 해결해줍니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;패키지-매니저가-동작하는-세-단계&quot;&gt;&lt;strong&gt;패키지 매니저가 동작하는 세 단계&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Resolution 단계&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;라이브러리 버전 고정&lt;/li&gt;
  &lt;li&gt;라이브러리의 다른 의존성 확인&lt;/li&gt;
  &lt;li&gt;라이브러리의 다른 의존성 버전 고정&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;fetch-단계&quot;&gt;&lt;strong&gt;Fetch 단계&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;결정된 버전의 파일을 다운로드 하는 과정&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;link-단계&quot;&gt;&lt;strong&gt;Link 단계&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Resolution/Fetch 된 라이브러리를 소스 코드에서 사용할 수 있는 환경을 제공하는 과정&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;npm-node-package-manager&quot;&gt;npm (Node Package Manager)&lt;/h2&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;광범위한 생태계&lt;/strong&gt;: 수백만 개의 패키지를 제공하여 다양한 기능을 손쉽게 구현 가능&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;활발한 커뮤니티&lt;/strong&gt;: 풍부한 자료와 지원을 받을 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;느린 설치 속도&lt;/strong&gt;: 대규모 프로젝트에서 설치 시간이 길어질 수 있음&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;의존성 트리의 중복&lt;/strong&gt;: 동일한 패키지가 여러 버전으로 설치되어 디스크 공간을 비효율적으로 사용&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/upload/2024-10-31-패키지_매니저_및_모노레포_정하기.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/upload/2024-10-31-패키지_매니저_및_모노레포_정하기.md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;yarn&quot;&gt;yarn&lt;/h2&gt;

&lt;p&gt;Yarn은 Facebook에서 npm의 단점을 보완하기 위해 개발한 패키지 매니저로, 속도와 일관성에 초점을 맞추고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;장점-1&quot;&gt;장점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;빠른 설치 속도&lt;/strong&gt;: 병렬 다운로드와 캐싱을 통해 설치 시간을 단축&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;신뢰성 있는 버전 관리&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yarn.lock&lt;/code&gt; 파일을 통해 의존성 버전을 고정하여 일관성 유지&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;효율적인 네트워크 사용&lt;/strong&gt;: 동일한 패키지를 재사용하여 네트워크 트래픽 감소&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;단점-1&quot;&gt;단점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;호환성 이슈&lt;/strong&gt;: 일부 패키지가 Yarn과 완벽히 호환되지 않을 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pnpm&quot;&gt;pnpm&lt;/h2&gt;

&lt;p&gt;pnpm은 패키지를 설치할 때 하드 링크와 심볼릭 링크를 활용하여 디스크 공간을 절약하는 패키지 매니저입니다.&lt;/p&gt;

&lt;h3 id=&quot;장점-2&quot;&gt;장점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;디스크 공간 효율성&lt;/strong&gt;: 동일한 패키지를 한 곳에 저장하여 중복 제거&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;빠른 설치 속도&lt;/strong&gt;: 파일 시스템 링크를 사용하여 설치 시간을 단축&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;엄격한 의존성 격리&lt;/strong&gt;: 프로젝트별로 의존성을 격리하여 충돌 방지&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;단점-2&quot;&gt;단점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;호환성 문제&lt;/strong&gt;: 일부 도구나 스크립트가 pnpm의 구조를 지원하지 않을 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;yarn-berry-yarn-2&quot;&gt;Yarn Berry (Yarn 2)&lt;/h2&gt;

&lt;p&gt;Yarn Berry는 Yarn의 두 번째 메이저 버전으로, Plug’n’Play(PnP) 시스템을 도입하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node_modules&lt;/code&gt; 폴더 없이 패키지를 관리합니다.&lt;/p&gt;

&lt;h3 id=&quot;장점-3&quot;&gt;장점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;향상된 성능&lt;/strong&gt;: PnP를 통해 모듈 해결 시간을 단축&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;보안 강화&lt;/strong&gt;: 의존성 접근을 엄격히 통제하여 보안성 향상&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;구성 가능성&lt;/strong&gt;: 다양한 플러그인과 설정을 통해 커스터마이징 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;단점-3&quot;&gt;단점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;호환성 이슈&lt;/strong&gt;: PnP를 지원하지 않는 패키지나 도구가 존재&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;학습 곡선&lt;/strong&gt;: 기존 Yarn과 달라진 점이 많아 학습 필요&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;설정 복잡성&lt;/strong&gt;: 초기 설정과 환경 구성이 복잡할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;패키지-매니저-비교-및-선택&quot;&gt;패키지 매니저 비교 및 선택&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;패키지 매니저&lt;/th&gt;
      &lt;th&gt;설치 속도&lt;/th&gt;
      &lt;th&gt;디스크 공간 효율성&lt;/th&gt;
      &lt;th&gt;호환성&lt;/th&gt;
      &lt;th&gt;학습 난이도&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;npm&lt;/td&gt;
      &lt;td&gt;느림&lt;/td&gt;
      &lt;td&gt;낮음&lt;/td&gt;
      &lt;td&gt;높음&lt;/td&gt;
      &lt;td&gt;낮음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Yarn&lt;/td&gt;
      &lt;td&gt;빠름&lt;/td&gt;
      &lt;td&gt;중간&lt;/td&gt;
      &lt;td&gt;높음&lt;/td&gt;
      &lt;td&gt;중간&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;pnpm&lt;/td&gt;
      &lt;td&gt;매우 빠름&lt;/td&gt;
      &lt;td&gt;높음&lt;/td&gt;
      &lt;td&gt;중간&lt;/td&gt;
      &lt;td&gt;중간&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Yarn Berry&lt;/td&gt;
      &lt;td&gt;빠름&lt;/td&gt;
      &lt;td&gt;높음&lt;/td&gt;
      &lt;td&gt;낮음&lt;/td&gt;
      &lt;td&gt;높음&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-31-패키지_매니저_및_모노레포_정하기.md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-31&lt;/em&gt;%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.03.23.png_&lt;/p&gt;

&lt;h3 id=&quot;pnp-vs-zero-install&quot;&gt;&lt;strong&gt;PnP vs. Zero-install&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;PnP는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node_modules&lt;/code&gt; 없이 JavaScript Map 객체를 활용해 의존성을 엄격하고 빠르게 관리하는 접근 방식입니다. 그리고 Zero-install은 PnP의 JavaScript Map 객체와 Fetch된 의존성들까지 모두 Git에 넣어 버전을 관리하자는 방식입니다.&lt;/p&gt;

&lt;p&gt;쉽게 말해, npm을 사용하면서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node_modules&lt;/code&gt; 디렉토리를 버전 관리하는 것이 Zero-install이죠.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-31-패키지_매니저_및_모노레포_정하기.md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;우리 프로젝트는 &lt;strong&gt;모노레포&lt;/strong&gt; 구조로 구현되며, &lt;strong&gt;동일한 환경에서 동작&lt;/strong&gt;할 수 있도록 &lt;strong&gt;제로 인스톨&lt;/strong&gt;을 채택하기로 결정하였습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;모노레포 지원&lt;/strong&gt;: 프로젝트가 다수의 패키지로 구성된 모노레포 구조이므로, 여러 패키지를 효율적으로 관리할 수 있는 워크스페이스 기능이 필수적입니다. Yarn Workspaces와 pnpm Workspaces는 이를 효과적으로 지원하지만, Yarn Berry는 더욱 향상된 모노레포 관리 기능을 제공합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;제로 인스톨&lt;/strong&gt;: 개발 환경 설정을 단순화하고 초기 설치 단계를 제거하기 위해 제로 인스톨 방식을 도입하였습니다. Yarn Berry의 Plug’n’Play(PnP) 기능은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node_modules&lt;/code&gt; 폴더 없이 패키지를 관리할 수 있어 제로 인스톨을 구현하는 데 최적입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;디스크 공간 및 설치 속도&lt;/strong&gt;: 대규모 모노레포에서는 디스크 공간 사용과 설치 속도가 중요한 요소입니다. Yarn Berry와 pnpm은 디스크 공간을 효율적으로 사용하며 빠른 설치 속도를 제공합니다. 특히 pnpm은 하드 링크를 활용하여 공간을 절약하지만, Yarn Berry도 PnP와 캐싱을 통해 유사한 이점을 제공합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이러한 이유로, &lt;strong&gt;Yarn Berry&lt;/strong&gt;가 우리 프로젝트의 요구사항에 가장 적합한 패키지 매니저로 판단되었습니다. Yarn Berry를 사용함으로써 모노레포 관리의 효율성을 높이고, 제로 인스톨을 구현하여 개발 환경 설정을 간소화하며, 빠른 설치 속도와 디스크 공간 효율성을 확보할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;패키지-매니저에서-workspace의-역할&quot;&gt;패키지 매니저에서 workspace의 역할&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://classic.yarnpkg.com/lang/en/docs/workspaces/&quot;&gt;https://classic.yarnpkg.com/lang/en/docs/workspaces/&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;여러 패키지를 설정하여 한 번만 실행하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yarn install&lt;/code&gt;모든 패키지를 한 번에 설치할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;모든 프로젝트 종속성은 함께 설치되므로 Yarn이 이를 더 자유롭게 최적화할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;Yarn은 프로젝트마다 다른 잠금 파일을 사용하는 대신 단일 잠금 파일을 사용하므로 충돌이 적고 검토가 수월해집니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=Ds7EjE8Rhjs&quot;&gt;https://www.youtube.com/watch?v=Ds7EjE8Rhjs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://toss.tech/article/lightning-talks-package-manager&quot;&gt;https://toss.tech/article/lightning-talks-package-manager&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://d2.naver.com/helloworld/0923884&quot;&gt;https://d2.naver.com/helloworld/0923884&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://d2.naver.com/helloworld/7553804&quot;&gt;https://d2.naver.com/helloworld/7553804&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://monorepo.tools/#polyrepo-concept&quot;&gt;https://monorepo.tools/#polyrepo-concept&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://toss.tech/article/monorepo-pipeline&quot;&gt;https://toss.tech/article/monorepo-pipeline&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://2023.stateofjs.com/ko-KR/libraries/monorepo_tools/&quot;&gt;https://2023.stateofjs.com/ko-KR/libraries/monorepo_tools/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=Ix9gxqKOatY&quot;&gt;https://www.youtube.com/watch?v=Ix9gxqKOatY&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=DHPeeEvDbdo&quot;&gt;https://www.youtube.com/watch?v=DHPeeEvDbdo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=Bycg5w5qXfE&quot;&gt;https://www.youtube.com/watch?v=Bycg5w5qXfE&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=2IE68SDTYvI&quot;&gt;https://www.youtube.com/watch?v=2IE68SDTYvI&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;Jisukim&quot;]</name>
        
        
      </author>

      

      

      
        <summary type="html">목차</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">커스텀 ESLint 만들기</title>
      <link href="https://blog.liboo.kr/%EC%BB%A4%EC%8A%A4%ED%85%80_ESLint_%EB%A7%8C%EB%93%A4%EA%B8%B0" rel="alternate" type="text/html" title="커스텀 ESLint 만들기" />
      <published>2024-10-31T05:28:00+00:00</published>
      <updated>2024-10-31T05:28:00+00:00</updated>
      <id>https://blog.liboo.kr/%EC%BB%A4%EC%8A%A4%ED%85%80_ESLint_%EB%A7%8C%EB%93%A4%EA%B8%B0</id>
      <content type="html" xml:base="https://blog.liboo.kr/%EC%BB%A4%EC%8A%A4%ED%85%80_ESLint_%EB%A7%8C%EB%93%A4%EA%B8%B0">&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;목차&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;팀에서-사용할-eslint-만들기&quot;&gt;팀에서 사용할 ESLint 만들기&lt;/h1&gt;

&lt;p&gt;팀 프로젝트에서 사용할 ESLint 설정을 만들고 배포하는 과정을 다루며, 이를 통해 코드 품질을 향상시키고 개발 효율성을 높이는 방법을 제시합니다.&lt;/p&gt;

&lt;h2 id=&quot;eslint란&quot;&gt;ESLint란?&lt;/h2&gt;

&lt;h3 id=&quot;정의&quot;&gt;정의&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;ESLint&lt;/strong&gt;는 자바스크립트와 타입스크립트 코드의 품질을 유지하기 위한 정적 분석 도구입니다. 소스 코드를 실행하지 않고 코드의 문법과 논리적 오류, 스타일 문제 등을 분석하여 결함을 사전에 발견할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;주요-기능&quot;&gt;주요 기능&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;문법 검사&lt;/strong&gt;: 코드의 문법 오류를 자동으로 감지&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;스타일 가이드 준수&lt;/strong&gt;: 팀에서 정한 코드 스타일 규칙을 적용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;플러그인 지원&lt;/strong&gt;: 다양한 플러그인을 통해 기능 확장&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;자동 수정&lt;/strong&gt;: 일부 오류와 스타일 문제를 자동으로 수정&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;eslint의-필요성&quot;&gt;ESLint의 필요성&lt;/h2&gt;

&lt;h3 id=&quot;코드-품질-향상&quot;&gt;코드 품질 향상&lt;/h3&gt;

&lt;p&gt;ESLint는 코드의 일관성을 유지하고 잠재적인 버그를 사전에 발견하여 코드 품질을 높입니다.&lt;/p&gt;

&lt;h3 id=&quot;팀-간-협업-강화&quot;&gt;팀 간 협업 강화&lt;/h3&gt;

&lt;p&gt;팀원 간의 코드 스타일과 규칙이 일관되면 협업이 원활해집니다. ESLint는 팀 전체가 동일한 규칙을 따르도록 강제하여 코드베이스의 일관성을 유지합니다.&lt;/p&gt;

&lt;h3 id=&quot;자동화된-개발-워크플로우&quot;&gt;자동화된 개발 워크플로우&lt;/h3&gt;

&lt;p&gt;ESLint는 CI/CD 파이프라인에 통합하여 코드가 병합되기 전에 자동으로 검사할 수 있습니다. 이를 통해 오류가 포함된 코드가 메인 브랜치에 합쳐지는 것을 방지할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;eslint-설정-파일-이해하기&quot;&gt;ESLint 설정 파일 이해하기&lt;/h2&gt;

&lt;h3 id=&quot;기본-구조&quot;&gt;기본 구조&lt;/h3&gt;

&lt;p&gt;ESLint 설정 파일은 JSON 또는 JavaScript 형식으로 작성할 수 있으며, 일반적으로 프로젝트 루트 디렉토리에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.eslintrc.json&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.eslintrc.js&lt;/code&gt; 파일로 위치합니다. 기본 구조는 다음과 같습니다:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;json
{
  &quot;env&quot;: {
    &quot;browser&quot;: true,
    &quot;es2021&quot;: true},
  &quot;extends&quot;: [&quot;eslint:recommended&quot;],
  &quot;parserOptions&quot;: {
    &quot;ecmaVersion&quot;: 12,
    &quot;sourceType&quot;: &quot;module&quot;
  },
  &quot;rules&quot;: {
    &quot;indent&quot;: [&quot;error&quot;, 2],
    &quot;linebreak-style&quot;: [&quot;error&quot;, &quot;unix&quot;],
    &quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;],
    &quot;semi&quot;: [&quot;error&quot;, &quot;always&quot;]
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;주요-옵션&quot;&gt;주요 옵션&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;env&lt;/strong&gt;: 코드가 실행될 환경을 지정 (예: 브라우저, Node.js)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;extends&lt;/strong&gt;: 기존의 ESLint 설정을 확장 (예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eslint:recommended&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;parserOptions&lt;/strong&gt;: ECMAScript 버전과 모듈 시스템 등을 설정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;rules&lt;/strong&gt;: 적용할 개별 규칙과 그 강도를 정의&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;root-옵션&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt; 옵션&lt;/h3&gt;

&lt;p&gt;모노레포와 같은 다중 프로젝트 환경에서 ESLint 설정 파일의 상속 관계를 관리하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt; 옵션을 사용합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;root: true&lt;/strong&gt;: 이 설정 파일을 최상위로 간주하고 상위 디렉토리의 설정을 무시&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;root: false&lt;/strong&gt;: 상위 디렉토리의 설정을 상속받음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;예시:&lt;/strong&gt; 프로젝트 최상위 디렉토리의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.eslintrc.json&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;json
{
  &quot;root&quot;: true,
  &quot;extends&quot;: [&quot;eslint:recommended&quot;],
  &quot;rules&quot;: { /* 공통 규칙 */ }
}



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;나만의-린트-만들어보기&quot;&gt;나만의 린트 만들어보기&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-jsk-rules&quot;&gt;https://www.npmjs.com/package/eslint-plugin-jsk-rules&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/jsk3342/eslint-plugin-jsk-rules&quot;&gt;https://github.com/jsk3342/eslint-plugin-jsk-rules&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-31-커스텀_ESLint_만들기.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-30&lt;/em&gt;%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.15.43.png_&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-31-커스텀_ESLint_만들기.md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-30&lt;/em&gt;%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.15.31.png_&lt;/p&gt;

&lt;h3 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://velog.io/@imkkuk/Prettier-ESLint-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B3%A0-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0&quot;&gt;https://velog.io/@imkkuk/Prettier-ESLint-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B3%A0-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://poiemaweb.com/eslint&quot;&gt;https://poiemaweb.com/eslint&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://techblog.woowahan.com/15903/&quot;&gt;https://techblog.woowahan.com/15903/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=Be9q0k5BJ_s&quot;&gt;https://www.youtube.com/watch?v=Be9q0k5BJ_s&lt;/a&gt;
&lt;a href=&quot;https://tech.kakao.com/posts/375&quot;&gt;https://tech.kakao.com/posts/375&lt;/a&gt;
&lt;a href=&quot;https://medium.com/@iamkjw/eslint-%EC%95%8C%EA%B3%A0-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-6babb63da4d6&quot;&gt;https://medium.com/@iamkjw/eslint-%EC%95%8C%EA%B3%A0-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-6babb63da4d6&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://yceffort.kr/2022/06/how-to-write-my-own-eslint-rules&quot;&gt;https://yceffort.kr/2022/06/how-to-write-my-own-eslint-rules&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://junghyeonsu.com/posts/eslint-configs-library/#%EC%99%84%EC%84%B1%EB%90%9C-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EB%AF%B8%EB%A6%AC-%EB%B3%B4%EA%B8%B0&quot;&gt;https://junghyeonsu.com/posts/eslint-configs-library/#%EC%99%84%EC%84%B1%EB%90%9C-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EB%AF%B8%EB%A6%AC-%EB%B3%B4%EA%B8%B0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://eslint.org/docs/latest/extend/shareable-configs&quot;&gt;https://eslint.org/docs/latest/extend/shareable-configs&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;Jisukim&quot;]</name>
        
        
      </author>

      

      

      
        <summary type="html">목차</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">동영상 스트리밍 처리 프로토콜을 알아보자</title>
      <link href="https://blog.liboo.kr/%EB%8F%99%EC%98%81%EC%83%81_%EC%8A%A4%ED%8A%B8%EB%A6%AC%EB%B0%8D_%EC%B2%98%EB%A6%AC_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%84_%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90" rel="alternate" type="text/html" title="동영상 스트리밍 처리 프로토콜을 알아보자" />
      <published>2024-10-28T02:40:00+00:00</published>
      <updated>2024-10-28T02:40:00+00:00</updated>
      <id>https://blog.liboo.kr/%EB%8F%99%EC%98%81%EC%83%81_%EC%8A%A4%ED%8A%B8%EB%A6%AC%EB%B0%8D_%EC%B2%98%EB%A6%AC_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%84_%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90</id>
      <content type="html" xml:base="https://blog.liboo.kr/%EB%8F%99%EC%98%81%EC%83%81_%EC%8A%A4%ED%8A%B8%EB%A6%AC%EB%B0%8D_%EC%B2%98%EB%A6%AC_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%84_%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90">&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;목차&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;학습-이유&quot;&gt;🤔 학습 이유&lt;/h1&gt;

&lt;p&gt;서비스의 레퍼런스로 Zoom과 치지직 등 여러 스트리밍 서비스의 동작원리를 조사하던 중, 각 서비스별로 서로 다른 프로토콜을 사용하는 것을 발견할 수 있었다.&lt;/p&gt;

&lt;p&gt;영상 송출에 사용되는 프로토콜을 조사하고 우리 서비스에 적합한 프로토콜을 선정하고자 한다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동영상 스트리밍 처리 프로토콜
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;HLS&lt;/strong&gt; &lt;strong&gt;- 지연시간이 높지만 호환성이 좋음 (치지직) - 민지, 영길&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;왜 다른 프로토콜에 비해 지연시간이 길까?&lt;/li&gt;
          &lt;li&gt;어떻게 지연시간을 낮출 수 있을까?&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;WebRTC - 지연시간이 낮지만 P2P에 적합 (구글미트) - 창현&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;RTMP - 지연시간 낮음 (트위치) - 준서, 지수&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;Dynamic Adapltive Streaming over HTTP&lt;/li&gt;
      &lt;li&gt;SRT&lt;/li&gt;
      &lt;li&gt;RTSP&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;1️⃣rtsp-real-time-streaming-protocol&quot;&gt;1️⃣ RTSP &lt;strong&gt;(Real Time Streaming Protocol)&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;스트리밍의 시작이라고 말할 수 있다. 1996년 등장하였으며 RTSP가 등장 전 영상, 음악 등 멀티미디어 정보를 완전히 다운로드한 후 시청할 수 있었음.&lt;/p&gt;

&lt;p&gt;다만 오래된 기술이라 화질 저하, 미디어 서버 운영에 대한 높은 난이도 등으로 도태되고 있는 실정.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;애플은 HLS가 개발되기 이전에 &lt;strong&gt;RTSP&lt;/strong&gt; 기반의 QTSS로 비디오와 오디오를 처리했었음
    &lt;ul&gt;
      &lt;li&gt;하지만 QTSS가 애플 생태계에서만 최적화가 되어있었기 때문에 호환성 이유가 있었음&lt;/li&gt;
      &lt;li&gt;RTSP는 HTTP 기반이 아닌 TCP, UDP 사용 
  → 네트워크 상태나 방화벽 문제로 인해 HTTP보다 호환성 낮음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CCTV에서 사용하고 있는 프로토콜&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;스트리머 → rtmp → 서버 → hls → 클라이언트&lt;/p&gt;

&lt;h1 id=&quot;2️⃣hls-hypertext-live-streaming&quot;&gt;2️⃣ HLS (Hypertext Live Streaming)&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;참고자료&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[https://medium.com/@cwh./%EB%8F%99%EC%98%81%EC%83%81-%EC%95%88%EB%81%8A%EA%B8%B0%EA%B3%A0-%EB%B3%B4%EB%8A%94%EB%B2%95-feat-ll-hls-a6a0c453b21f](https://medium.com/@cwh./%EB%8F%99%EC%98%81%EC%83%81-%EC%95%88%EB%81%8A%EA%B8%B0%EA%B3%A0-%EB%B3%B4%EB%8A%94%EB%B2%95-feat-ll-hls-a6a0c453b21f)


[https://medium.com/@delivalue100/hls-http-live-streaming-4fb1d2992d57](https://medium.com/@delivalue100/hls-http-live-streaming-4fb1d2992d57)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;왜-만들어졌을까-feat-rtsp&quot;&gt;왜 만들어졌을까? feat. RTSP&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;RTSP는 고정된 비트레이트로 콘텐츠 스트리밍에 최적화
    &lt;ul&gt;
      &lt;li&gt;고정 비트레이트의 경우 한가지 속도로만 데이터를 전송하다 보니 네트워크 상태가 변할 때에도 동일한 비트레이트로 스트리밍을 유지해야한다는 문제가 있음&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;⇒ 따라서 호환성이 높은 HTTP를 기반으로, &lt;strong&gt;네트워크 상태에 따라 비디오 품질을 실시간으로 조정&lt;/strong&gt; 가능한 &lt;strong&gt;가변 비트레이트&lt;/strong&gt; 기능까지 도입된 것이 &lt;strong&gt;HLS&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;동작-원리-이해하기&quot;&gt;동작 원리 이해하기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP기반의 단방향 미디어 스트리밍 프로토콜&lt;/li&gt;
  &lt;li&gt;일반 웹서버 + CDN을 활용해 콘텐츠 배포&lt;/li&gt;
  &lt;li&gt;[비디오 → HTTP 파일 조각으로 나눔 → 전송 →] 재생&lt;/li&gt;
  &lt;li&gt;HTTP 파일로 나누기 때문에 별도의 전용 서버가 필요하지 않다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;m3u8 : 메타데이터
    &lt;ul&gt;
      &lt;li&gt;시작 태그&lt;/li&gt;
      &lt;li&gt;hls 프로토콜 버전&lt;/li&gt;
      &lt;li&gt;세그먼트의 최대 길이&lt;/li&gt;
      &lt;li&gt;첫 번째 세그먼트의 시퀀스 번호&lt;/li&gt;
      &lt;li&gt;실제 세그먼트의 길이, 다음 세그먼트 인덱스&lt;/li&gt;
      &lt;li&gt;종료 태그&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ts : 실제 비디오의 조각들을 담고 있는 컨테이너&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;왜-다른-프로토콜에-비해-지연시간이-길까&quot;&gt;왜 다른 프로토콜에 비해 지연시간이 길까?&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;지연시간이 긴 것에는 다양한 원인이 있었음&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;UDP 를 사용하는 다른 프로토콜들과 달리 HLS 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TCP&lt;/code&gt; 를 사용한다.&lt;/li&gt;
  &lt;li&gt;HLS 는 오히려 실시간에 집중하기 보다는 데이터의 신뢰성과 효율성에 집중한 프로토콜이다.&lt;/li&gt;
  &lt;li&gt;동작 방식으로 인한 지연
    &lt;ol&gt;
      &lt;li&gt;서버에서 스트리밍할 비디오 파일을 짧은 세그먼트(2~10초)로 분할 
 → 재생을 시작하기 위해선 &lt;strong&gt;적어도 몇 개의 세그먼트가 필요해 초기 버퍼링 시간이 길어짐&lt;/strong&gt; (세그먼트 길이가 길수록 지연이 커질 수 있음)
 ⇒ CDN으로 세그먼트 캐싱해서 데이터 전송 시간을 개선하려함&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP 기반 요청-응답 지연
    &lt;ol&gt;
      &lt;li&gt;HTTP 기반이므로 &lt;strong&gt;각 세그먼트 마다 서버에 요청을 보내고 응답을 기다리는 시간&lt;/strong&gt;이 필요. 네트워크의 상태나 응답 속도에 종속&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;가변 비트레이트 지연
    &lt;ol&gt;
      &lt;li&gt;네트워크 상태에 따라 &lt;strong&gt;최적의 비트레이트를 선택하기 위한 모니터링&lt;/strong&gt; 진행 
 → 이 과정에서 비트레이트를 전환하며 지연이 발생함 
 ⇒ 지연이 시청 환경을 개선하지만 실시간성에서는 불리함!&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;CDN 캐싱과 서버 최적화 이슈
    &lt;ol&gt;
      &lt;li&gt;세그먼트 파일이 여러 서버에 캐시되어도 여전히 HTTP 기반으로 동작해 추가적인 통신과정 필요&lt;/li&gt;
      &lt;li&gt;특히 사용자 많은 라이브방송에서는 CDN이 적절히 분배되지 않으면 지연 발생&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;⇒ 따라서 HLS는 라이브 스트리밍보다는 정적 비디오 플레이어에 더 적합&lt;/p&gt;

&lt;h3 id=&quot;치지직에서의-hls-사용법&quot;&gt;치지직에서의 HLS 사용법&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;⇒ 결국 클라이언트가 플레이리스트의 미디어 세그먼트들을 순차적으로 GET하고 마지막쯤에 새로운 세그먼트를 요청하는 흐름이기 때문에 &lt;strong&gt;단방향 통신으로 동작한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;+) 뒤로 돌려보기 안되는 이유..? 돌려보기 자체에 리소스 소모가 큰듯. 그냥 방송 종료 후 다시보기 기능을 넣는게 이득&lt;/p&gt;

&lt;h3 id=&quot;지연시간-어떻게-개선할-수-있을까&quot;&gt;지연시간 어떻게 개선할 수 있을까?&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cdnetworks.com/ko/blog/media-delivery/http-live-streaming/&quot;&gt;https://www.cdnetworks.com/ko/blog/media-delivery/http-live-streaming/&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;세그먼트 길이 단축
    &lt;ol&gt;
      &lt;li&gt;6초 이상의 기본적인 세그먼트 길이를 2~1초로 줄이기
        &lt;ol&gt;
          &lt;li&gt;짧아질수록 서버와 클라이언트 사이에 요청이 많아 부하가 생길 수 있으니 균형점을 찾아야함&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;LL-HLS 도입
    &lt;ol&gt;
      &lt;li&gt;애플이 개발한 HLS의 초저지연 버전&lt;/li&gt;
      &lt;li&gt;세그먼트 내에서 더 작은 단위인 파트로 나눠 전송하며, 세그먼트가 완전히 준비되지 않아도 일부를 먼저 전송함&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;세그먼트 프리페칭
    &lt;ol&gt;
      &lt;li&gt;클라이언트가 다음 세그먼트를 미리 예측하고 사전 다운로드&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;송출 환경 최적화
    &lt;ol&gt;
      &lt;li&gt;치지직 공지사항을 보니 송출 프로그램을 최적화하는 방법도..&lt;/li&gt;
      &lt;li&gt;스트리머가 키프레임 간격을 너무 짧게 설정 →세그먼트가 너무 짧아짐, 서버 부하 ⇒ 버퍼링 많아짐 이슈인듯
        &lt;ol&gt;
          &lt;li&gt;&lt;a href=&quot;https://help.naver.com/notice/noticeView.help?noticeNo=17188&amp;amp;serviceNo=23946&amp;amp;lang=ko&quot;&gt;https://help.naver.com/notice/noticeView.help?noticeNo=17188&amp;amp;serviceNo=23946&amp;amp;lang=ko&lt;/a&gt;&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;비트레이트와-세그먼트&quot;&gt;비트레이트와 세그먼트&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;비트레이트&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m3u8&lt;/code&gt; 플레이리스트 파일 수정
        &lt;ol&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EXT-X-STREAM-INF&lt;/code&gt; 태그를 사용하여 비트레이트를 설정&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
			#EXTM3U
			#EXT-X-VERSION:3
			
			#EXT-X-STREAM-INF:BANDWIDTH=1500000
			# 이 스트림에 대한 메타데이터를 정의
			# BANDWIDTH=1500000은 이 스트림의 대역폭 요구 사항이 1,500,000 비트(1.5 Mbps)임을 나타냄
			
			stream_1500.m3u8
			
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	2. 추가적인 태그 설명
		- **#EXT-X-DISCONTINUITY**: 이전 세그먼트와의 **연속성이 끊어짐**을 표시합니다. 이는 광고와 같은 **다른 유형의 미디어를 삽입**할 때 사용됩니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
				m3u8
				#EXT-X-DISCONTINUITY
				
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;			- **예시**: 이 태그 뒤에 오는 세그먼트는 이전 미디어와는 다르게 인코딩되었거나 다른 타입의 미디어임을 의미합니다.
		- **#EXT-X-STREAM-INF**: **다중 비트레이트 스트림** 또는 **적응형 스트리밍**을 위해 사용됩니다. 여러 비트레이트를 가진 대체 스트림이 있을 때, 클라이언트가 네트워크 상태에 따라 적절한 스트림을 선택할 수 있도록 합니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
				m3u8
				#EXT-X-STREAM-INF:BANDWIDTH=800000,RESOLUTION=640x360
				low.m3u8
				#EXT-X-STREAM-INF:BANDWIDTH=1500000,RESOLUTION=1280x720
				medium.m3u8
				
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;			- **예시**: 800kbps, 1500kbps로 각각 다른 해상도의 스트림을 제공합니다. 클라이언트는 네트워크 상황에 따라 적절한 `m3u8` 파일을 선택하게 됩니다.
		- **#EXT-X-KEY**: 세그먼트의 **암호화 키 정보**를 제공합니다. HLS에서는 콘텐츠 보호를 위해 **AES-128 암호화**를 사용하여 세그먼트를 암호화할 수 있습니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
				m3u8
				#EXT-X-KEY:METHOD=AES-128,URI=&quot;https://example.com/key&quot;
				
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;			- **예시**: 세그먼트를 AES-128로 암호화하며, 암호화 키를 가져올 위치는 `https://example.com/key`입니다. 2. **세그먼트**
1. FFmpeg로 비디오를 여러 해상도로 인코딩할 때 `-hls_time`을 사용하여 세그먼트의 길이를 설정 (기본 10초)
2. [https://frontdev.tistory.com/entry/ffmpeg%EB%A1%9C-hls-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EC%98%B5%EC%85%98%EC%A0%95%EB%A6%AC](https://frontdev.tistory.com/entry/ffmpeg%EB%A1%9C-hls-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EC%98%B5%EC%85%98%EC%A0%95%EB%A6%AC)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
		- ffmpeg -i hasashin.mp4 -b:v 1M -g 60 -hls_time 2 -hls_list_size 0 -hls_segment_size 500000 output.m3u8
		출처: https://frontdev.tistory.com/entry/ffmpeg로-hls-만들기-옵션정리 [Front End Develop:티스토리]
		
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;결론
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;높은 비트레이트와 긴 세그먼트&lt;/strong&gt;: 높은 비트레이트를 사용하면서 긴 세그먼트를 전송할 경우, 네트워크 대역폭을 효율적으로 사용할 수 있지만, 지연 시간이 증가. 특히 불안정한 네트워크에서는 재생 품질이 저하됨.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;낮은 비트레이트와 짧은 세그먼트&lt;/strong&gt;: 낮은 비트레이트와 짧은 세그먼트를 조합하면, 재생 안정성이 높아지고 지연 시간 감소, 비디오 품질은 저하. ⇒ 이게 우리서비스에 적합하지 않을까?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;ll-hls의-지연시간-개선-방법&quot;&gt;LL-HLS의 지연시간 개선 방법&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;하나당 10초 정도인 ts 가 아닌 1초 이하 정도의 CMAF 컨테이너에 담아서 생성 즉시 전송한다.&lt;/li&gt;
  &lt;li&gt;또한 m3u8 파일에 추가적인 메타데이터가 들어간다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ll-hls-관련-메타데이터&quot;&gt;LL-HLS 관련 메타데이터&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;#EXT-X-PART-INF&lt;/strong&gt;: &lt;strong&gt;저지연 HLS&lt;/strong&gt;에서 사용되는 태그로, 세그먼트가 &lt;strong&gt;파편(chunk)&lt;/strong&gt;으로 나뉘어 전송되는 경우 각 파편의 정보를 포함합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
	m3u8
	#EXT-X-PART-INF:PART-TARGET=1.0
	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- **예시**: 각 파편의 타겟 길이가 **1초**임을 의미합니다. - **#EXT-X-PRELOAD-HINT**: LL-HLS에서 아직 완료되지 않은 세그먼트나 파편에 대해 **미리 가져올 힌트**를 제공합니다. 이를 통해 클라이언트가 지연 시간을 줄이기 위해 미리 준비할 수 있습니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
	m3u8
	#EXT-X-PRELOAD-HINT:TYPE=PART,URI=&quot;segment3_part1.ts&quot;
	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- **예시**: `segment3_part1.ts` 파편을 미리 로드할 힌트입니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;응답-지연&quot;&gt;응답 지연&lt;/h2&gt;

&lt;p&gt;저번 금요일에 회고 시간에,  Short Polling, Long Polling 이 나왔던 적이 있었는데 이와 비슷한 방식으로 지연 시간을 줄였다고 보면 쉬울 것 같다.&lt;/p&gt;

&lt;p&gt;Short Polling 은 주기적으로 서버에 요청을 보내서 업데이트 된 사항이 있는지를 체크한다. 만약 업데이트된 사항이 없다면 서버는 304(Not Modified), 200 를 반환한다.&lt;/p&gt;

&lt;p&gt;이때 클라이언트는 업데이트된 사항이 있을 때 까지 또 요청을 보낸다.&lt;/p&gt;

&lt;p&gt;Long Polling (200) 은 클라이언트가 서버에 요청을 보냈을 때, 업데이트가 되기 전까지는 서버가 응답을 되돌려주지 않고 연결을 유지(지연)하다가, 업데이트가 된 순간 응답을 보낸다.&lt;/p&gt;

&lt;p&gt;기존 HLS는 메타데이터(플레이리스트) 인 .m3u8 파일을 지속적으로 서버에 요청해서 .m3u8 을 토대로 세그먼트를 재생하는 방식인데, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지속적으로 서버에 요청&lt;/code&gt; 이 과정이 지연시간의 주범이다. 이 시간 동안 클라이언트는 세그먼트를 받는게 아니라 대기를 해버리기 때문에, 실제 동영상 파일인 세그먼트를 업데이트가 되고 나서야 받을 수 있다.&lt;/p&gt;

&lt;p&gt;기존 HLS 는 HTTP 요청을 주기적으로 보내서 .m3u8 이 업데이트가 되었는지 확인을 한다. 만약 업데이트가 되지 않았다면 또 서버에 요청을 보내고, 업데이트가 되었다는 응답을 받고 나서야 실제 스트리밍 데이터인 세그먼트를 받아온다.&lt;/p&gt;

&lt;p&gt;LL-HLS 는&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;클라이언트의 플레이리스트 요청&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;클라이언트가 서버에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.m3u8&lt;/code&gt; &lt;strong&gt;플레이리스트&lt;/strong&gt;를 요청합니다. 이때 클라이언트는 &lt;strong&gt;최신 세그먼트&lt;/strong&gt;를 가져오기를 원합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;서버의 요청 지연(Blocking)&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;만약 서버에 &lt;strong&gt;새로운 세그먼트&lt;/strong&gt;가 아직 생성되지 않은 경우, 서버는 즉시 응답을 하지 않고 요청을 &lt;strong&gt;일정 시간 동안 대기(Blocking)&lt;/strong&gt; 시킵니다. 이 대기 시간 동안 서버는 새로운 세그먼트가 생성되기를 기다립니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;새로운 세그먼트 생성 시 응답&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;새로운 세그먼트가 생성되면 서버는 대기 중인 클라이언트의 요청에 응답하여 &lt;strong&gt;최신 플레이리스트&lt;/strong&gt;를 반환합니다. 클라이언트는 이를 통해 바로 다음 세그먼트를 가져가 재생을 시작할 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;업데이트 주기 단축&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;이러한 방식은 기존의 주기적인 폴링 방식보다 &lt;strong&gt;지연 시간&lt;/strong&gt;을 훨씬 줄일 수 있습니다. 즉, 클라이언트가 계속해서 플레이리스트를 요청하여 최신 정보를 받기 위해 대기하지 않도록 하여 지연 시간을 줄입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;서버의-부하&quot;&gt;서버의 부하&lt;/h2&gt;

&lt;p&gt;LL-HLS 는 세그먼트를 더 짧게 생성하기 때문에 당연히 세그먼트를 더 자주 생성하게 되고, m3u8 의 업데이트도 더 많이 일어난다. 따라서 서버의 부담이 증가하게 된다.&lt;/p&gt;

&lt;p&gt;서버의 부담을 줄이는 방법은 있을까?&lt;/p&gt;

&lt;h3 id=&quot;서버-부하를-줄이기-위한-방안&quot;&gt;서버 부하를 줄이기 위한 방안&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;CDN(Content Delivery Network) 사용&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;LL-HLS&lt;/strong&gt;에서 서버 부하를 줄이기 위해 가장 많이 사용되는 방법 중 하나는 &lt;strong&gt;CDN&lt;/strong&gt;을 사용하는 것입니다. CDN은 스트리밍 콘텐츠를 여러 지점에 &lt;strong&gt;캐시&lt;/strong&gt;하고, 지리적으로 가까운 사용자에게 콘텐츠를 제공함으로써 &lt;strong&gt;서버의 부하를 분산&lt;/strong&gt;시킵니다.&lt;/li&gt;
      &lt;li&gt;CDN을 사용하면 클라이언트가 직접 서버에 연결하는 대신 CDN에서 콘텐츠를 받아가므로, &lt;strong&gt;서버의 직접적인 요청 수&lt;/strong&gt;를 줄일 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;효율적인 세그먼트 생성 및 캐싱&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;서버는 세그먼트를 효율적으로 생성하고, &lt;strong&gt;재사용 가능한 세그먼트를 캐싱&lt;/strong&gt;함으로써 부하를 줄일 수 있습니다. 특히, 플레이리스트와 세그먼트가 자주 변경되기 때문에, 이를 적절히 캐싱하여 동일한 콘텐츠를 여러 클라이언트가 요청하는 경우 서버에서 재생성할 필요가 없도록 해야 합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;최적의 플레이리스트 및 세그먼트 길이 조정&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;LL-HLS에서는 지연 시간을 줄이기 위해 세그먼트를 작은 크기로 나누지만, &lt;strong&gt;너무 작은 단위의 세그먼트&lt;/strong&gt;는 서버 부하를 크게 증가시킬 수 있습니다. 따라서 &lt;strong&gt;적절한 세그먼트 길이&lt;/strong&gt;와 &lt;strong&gt;플레이리스트 갱신 주기&lt;/strong&gt;를 설정하여 서버 부하와 지연 시간을 균형 있게 맞추는 것이 중요합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;대신 safari 를 제외한 브라우저에서는 &lt;video&gt; 태그만으로는 재생이 불가능하다. HLS 스트림 변환이 필요하다.&lt;/video&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;hls.js → hls 스트림을 브라우저가 이해할 수 있는 포맷으로 변환하여 &lt;video&gt; 요소에 전달하는 라이브러리&lt;/video&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;3️⃣webrtc-web-real-time-communication&quot;&gt;3️⃣ WebRTC (Web Real-Time Communication)&lt;/h1&gt;

&lt;p&gt;웹 브라우저 간에 플러그인의 도움 없이 서로 통신할 수 있도록 설계된 &lt;strong&gt;Javascript API&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;→ 별다른 소프트웨어 없이 카메라, 마이크 등을 사용하여 실시간 커뮤니케이션을 제공&lt;/p&gt;

&lt;p&gt;음성 통화, 영상 통화, P2P 파일 공유 등으로 활용됨&lt;/p&gt;

&lt;h2 id=&quot;webrtc의-장점&quot;&gt;WebRTC의 장점&lt;/h2&gt;

&lt;h3 id=&quot;webrtc는-낮은-latency를-갖는다&quot;&gt;WebRTC는 낮은 Latency를 갖는다&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;WebRTC는 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P2P(peer-to-peer)방식&lt;/code&gt;&lt;/strong&gt;으로 데이터를 전송
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;P2P&lt;/strong&gt;는 &lt;strong&gt;중간 서버&lt;/strong&gt;를 거치지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;WebRTC는 &lt;strong&gt;UDP 기반&lt;/strong&gt;으로 작동하여 신속하게 패킷을 전송
    &lt;ul&gt;
      &lt;li&gt;HLS와 RTMP는 &lt;strong&gt;TCP 기반&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;webrtc는-호환성이-높다&quot;&gt;WebRTC는 호환성이 높다&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/5.png&quot; alt=&quot;5&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;webrtc의-단점&quot;&gt;WebRTC의 단점&lt;/h2&gt;

&lt;h3 id=&quot;많은-사용자가-사용할-수-없다-스케일링-문제&quot;&gt;많은 사용자가 사용할 수 없다 (스케일링 문제)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;WebRTC는 P2P(peer-to-peer) 구조로 작동하기 때문에 각 사용자 간의 직접적인 연결을 설정&lt;/li&gt;
  &lt;li&gt;사용자가 많아질수록 필요한 연결 수가 &lt;strong&gt;기하급수적으로 증가&lt;/strong&gt;함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/6.png&quot; alt=&quot;6&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;N명의 사용자가 있을 때 사용자 한명이 추가되면 N개의 연결이 필요
    &lt;ul&gt;
      &lt;li&gt;서버와 클라이언트 모두에 큰 부담&lt;/li&gt;
      &lt;li&gt;네트워크 대역폭과 성능 저하 초래&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;화질-문제-성능문제&quot;&gt;화질 문제 (성능문제)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;실시간 비디오와 오디오 스트리밍을 위해 상당한 대역폭을 소모&lt;/li&gt;
  &lt;li&gt;특히 고화질 비디오 스트림은 많은 대역폭을 요구&lt;/li&gt;
  &lt;li&gt;대역폭이 제한된 환경에서는 &lt;strong&gt;패킷 손실&lt;/strong&gt;이 발생할 수 있으며, 이는 전체 스트림의 품질 저하로 이어짐
    &lt;ul&gt;
      &lt;li&gt;WebRTC는 &lt;strong&gt;UDP 기반&lt;/strong&gt;이므로 패킷 손실이 일어날 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다수의 사용자가 동시에 스트리밍을 시도하면 &lt;strong&gt;대역폭이 고갈&lt;/strong&gt;될 위험&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;대규모-라이브-방송에-불완전함&quot;&gt;대규모 라이브 방송에 불완전함&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;예측 불가능한 대역폭 소모&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;HLS나 RTMP&lt;/strong&gt;의 예측 가능한 방식
        &lt;ul&gt;
          &lt;li&gt;HLS나 RTMP는 중앙 서버에서 스트리밍을 관리하고 일반적으로 미리 인코딩된 비디오 조각을 전송&lt;/li&gt;
          &lt;li&gt;스케일링 가능 : 수많은 사용자에게 콘텐츠를 효율적으로 배포할 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;WebRTC&lt;/strong&gt;는 미리 인코딩된 스트림을 사용하지 않기 때문에 대역폭이 비디오 품질과 사용자 수에 따라 즉각적으로 변동함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;webrtc보다-빠른-기술이-있을까&quot;&gt;WebRTC보다 빠른 기술이 있을까?&lt;/h2&gt;

&lt;h3 id=&quot;webtransport&quot;&gt;&lt;strong&gt;WebTransport&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;WebTransport는 UDP 기반으로 통신&lt;/li&gt;
  &lt;li&gt;WebRTC의 signaling 없이도 서버와의 실시간 데이터 교환 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러나 WebTransport는 아직 개발 단계이며, 안정적인 표준화가 이루어지지 않아 모든 브라우저에서의 지원이 불확실&lt;/p&gt;

&lt;p&gt;WebRTC처럼 실시간 오디오와 비디오 전송을 위한 최적화가 충분하지 않음&lt;/p&gt;

&lt;h3 id=&quot;hls-vs-webrtc-비교&quot;&gt;HLS vs WebRTC 비교&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;**HLS**(HTTP Live Streaming)와 **WebRTC**는 모두 실시간 스트리밍을 위한 기술이지만, **사용 목적**, **지연 시간**, **보안** 및 **호환성** 측면에서 큰 차이가 있습니다. 사용하려는 애플리케이션의 유형에 따라 각 기술의 장단점을 비교해보고 어떤 것이 더 적합한지 선택해야 합니다. 아래는 HLS와 WebRTC를 실시간 스트리밍 웹 서비스의 관점에서 비교한 것입니다.


### 1. 지연 시간

- **HLS**:
	- **지연 시간**: HLS는 HTTP 기반 프로토콜로 설계되어 있으며, **10~30초**의 지연 시간이 발생하는 것이 일반적입니다. 심지어 **저지연 HLS(LL-HLS)**를 사용하더라도 2~5초 정도의 지연 시간이 존재할 수 있습니다.
	- **용도**: 따라서 HLS는 실시간성이 요구되지 않는 스트리밍에 적합합니다. 예를 들어, 뉴스 방송, 스포츠 경기, 강의 등의 상황에서 몇 초 정도의 지연이 큰 문제가 되지 않는다면 HLS가 적합합니다.
- **WebRTC**:
	- **지연 시간**: WebRTC는 **1초 미만의 매우 낮은 지연 시간**을 목표로 설계되어, 실시간 인터랙티브한 통신에 적합합니다.
	- **용도**: 화상 회의, 게임 스트리밍, 실시간 원격 조작 등 **매우 빠른 반응**이 필요한 애플리케이션에 적합합니다. WebRTC의 P2P 연결 방식 덕분에 지연 시간을 최소화할 수 있습니다.

### 2. 사용 사례

- **HLS**:
	- **주로 대규모 시청자 대상의 스트리밍**: HLS는 대규모 스트리밍 서비스(예: YouTube, Twitch 등)에서 매우 효과적입니다. HTTP 기반이라 기존 **CDN(Content Delivery Network)** 인프라를 활용해 손쉽게 콘텐츠를 전송할 수 있으며, 수천에서 수백만 명의 시청자가 동시에 스트리밍을 보는 데 적합합니다.
	- **적응형 스트리밍**: 네트워크 상태에 따라 비디오 품질을 조정하는 **적응형 스트리밍**을 기본적으로 제공하므로, 시청자의 네트워크 환경에 맞춰 끊김 없이 서비스를 제공합니다.
- **WebRTC**:
	- **1:1 혹은 소규모 그룹 통신**: WebRTC는 **화상 통화**, **화상 회의**, **온라인 협업 툴** 등 소규모 실시간 커뮤니케이션에 최적화되어 있습니다. 또한, 게임 스트리밍과 같은 실시간 반응이 중요한 상황에도 적합합니다.
	- **P2P 연결**: WebRTC는 주로 **P2P 연결**을 통해 데이터를 직접 전송하므로 서버의 부하를 줄일 수 있지만, 대규모 시청자를 대상으로 하기에 효율적이지 않을 수 있습니다.

### 3. 확장성

- **HLS**:
	- **대규모 스트리밍에 최적**: HLS는 HTTP 기반이기 때문에 **CDN**을 사용하여 확장성을 쉽게 확보할 수 있습니다. 수천 명 이상의 사용자가 동시에 스트리밍을 소비할 수 있으며, 서버 부담을 덜 수 있습니다.
- **WebRTC**:
	- **제한된 확장성**: WebRTC는 브라우저 간 **P2P 연결**을 사용하므로, 직접 연결의 수가 증가할수록 확장성이 제한됩니다. 예를 들어, 많은 참가자 간의 연결이 필요하면 각 클라이언트의 네트워크 및 CPU 자원이 급격히 소모됩니다.
	- **SFU 사용**: 확장성을 늘리기 위해 **SFU(Selective Forwarding Unit)**를 도입하여 각 클라이언트가 모든 참가자와 직접 연결하지 않고 중앙 서버를 통해 연결을 관리할 수 있도록 할 수 있습니다. 이를 통해 약 100명 이상의 사용자까지 확장 가능합니다.

### 4. 네트워크 호환성 및 안정성

- **HLS**:
	- **HTTP 기반 전송**: HLS는 HTTP 기반이기 때문에, 대부분의 방화벽을 통과하고 네트워크 호환성이 매우 뛰어납니다.
	- **안정적**: HTTP와 TCP를 사용하여 데이터 전송이 신뢰적이며, 중간에 발생하는 패킷 손실을 재전송하는 메커니즘이 있어 안정적인 스트리밍을 제공합니다.
- **WebRTC**:
	- **NAT Traversal**: WebRTC는 P2P 연결을 위해 **STUN** 및 **TURN** 서버를 사용하여 NAT 뒤에 있는 클라이언트를 연결합니다. 하지만 네트워크 환경에 따라 연결 설정이 복잡해지거나 문제가 발생할 수 있습니다.
	- **UDP 기반 전송**: 주로 **UDP**를 사용하여 낮은 지연 시간을 제공하지만, 패킷 손실 시 재전송을 보장하지 않아 네트워크 상태가 좋지 않을 때 품질 저하가 발생할 수 있습니다.

### 5. 보안

- **HLS**:
	- **HTTPS와 함께 사용**: HLS는 HTTP 기반으로, **HTTPS**를 사용해 데이터를 암호화할 수 있습니다. 또한, **DRM(디지털 권리 관리)**과 함께 사용해 콘텐츠 보호를 구현할 수 있습니다.
- **WebRTC**:
	- **기본적으로 암호화된 통신**: WebRTC는 모든 오디오, 비디오, 데이터 스트림을 **DTLS**(Datagram Transport Layer Security)와 **SRTP**(Secure Real-Time Transport Protocol)를 사용해 암호화합니다. 기본적으로 강력한 보안이 내장되어 있습니다.

### 6. 브라우저 지원

- **HLS**:
	- **Safari와 iOS 네이티브 지원**: Apple 기기와 Safari 브라우저에서 기본적으로 지원하지만, Chrome, Firefox 등 다른 브라우저에서는 JavaScript 라이브러리(**hls.js**)가 필요합니다.
- **WebRTC**:
	- **모든 최신 브라우저 지원**: WebRTC는 **Chrome**, **Firefox**, **Safari**, **Edge** 등 대부분의 최신 브라우저에서 네이티브로 지원됩니다. 추가적인 플러그인이 필요 없이 실시간 통신 기능을 사용할 수 있습니다.

### 결론

- **HLS**는 **대규모 스트리밍**에 적합하며, 상대적으로 긴 지연 시간을 허용할 수 있는 **방송, 교육, 엔터테인먼트**와 같은 서비스에서 주로 사용됩니다. **HTTP 기반**이므로 네트워크 호환성이 높고, 기존 CDN 인프라를 활용할 수 있는 장점이 있습니다.
- **WebRTC**는 **즉각적인 반응이 필요한 실시간 인터랙티브 애플리케이션**에 적합합니다. **낮은 지연 시간**과 **보안성**을 갖추고 있어 **화상 회의, 실시간 통신, 온라인 협업 도구** 등에 적합하며, 브라우저에서 네이티브로 지원되는 장점이 있습니다. 다만, **확장성** 측면에서는 SFU와 같은 구조적 보완이 필요합니다.

따라서, **대규모 시청자와의 방송**에는 HLS가 적합하고, **소규모 실시간 상호작용**이나 **낮은 지연 시간이 필요한 서비스**에는 WebRTC가 더 나은 선택이 될 것입니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;3️⃣rtmp-real-time-messaging-protocol&quot;&gt;3️⃣ RTMP (Real-Time Messaging Protocol)&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;참고자료&lt;br /&gt;
&lt;a href=&quot;https://www.cdnetworks.com/ko/blog/media-delivery/what-is-rtmp-ingest/&quot;&gt;https://www.cdnetworks.com/ko/blog/media-delivery/what-is-rtmp-ingest/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://ossrs.net/lts/en-us/docs/v6/doc/flv&quot;&gt;https://ossrs.net/lts/en-us/docs/v6/doc/flv&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://growthvalue.tistory.com/178&quot;&gt;https://growthvalue.tistory.com/178&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://ossrs.net/lts/en-us/docs/v4/doc/delivery-http-flv&quot;&gt;https://ossrs.net/lts/en-us/docs/v4/doc/delivery-http-flv&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://medium.com/@delivalue100/rtmp-realtime-messaging-protocol-c4474e464ffd&quot;&gt;https://medium.com/@delivalue100/rtmp-realtime-messaging-protocol-c4474e464ffd&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://obsproject.com/forum/whats-new/posts/2763754/&quot;&gt;https://obsproject.com/forum/whats-new/posts/2763754/&lt;/a&gt; - OBS 포럼 &lt;br /&gt;
&lt;a href=&quot;https://devocean.sk.com/blog/techBoardDetail.do?ID=164296&quot;&gt;https://devocean.sk.com/blog/techBoardDetail.do?ID=164296&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.naver.com/mingyo01/222050438291&quot;&gt;https://blog.naver.com/mingyo01/222050438291&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://velog.io/@chosj1526/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8A%B8%EC%9C%84%EC%B9%98-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%94%94%EC%9E%90%EC%9D%B8&quot;&gt;https://velog.io/@chosj1526/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8A%B8%EC%9C%84%EC%B9%98-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%94%94%EC%9E%90%EC%9D%B8&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;개요&quot;&gt;&lt;strong&gt;개요&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/7.png&quot; alt=&quot;7&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/8.png&quot; alt=&quot;8&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;개발자:&lt;/strong&gt; Adobe Systems (원래 Macromedia가 개발)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;출시 시기:&lt;/strong&gt; 2003년&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;주요 용도:&lt;/strong&gt; 실시간 비디오 및 오디오 스트리밍, 특히 라이브 방송&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;특징:&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;어도브에서 규정한 만큼 기존에는 Flash Player을 지원하기 위해 작성된 기술이었다.&lt;/p&gt;

    &lt;p&gt;그러나 최근 어도브에서 Flash Player의 지원을 중단한 만큼 점차 사용률이 저조해지고 있다.&lt;/p&gt;

    &lt;p&gt;하지만 이는 클라이언트 단에서의 문제점이고, 영상 데이터를 서버로 옮기고 저장하는 데에 있어서는 높은 지연 시간과 효율을 가지고 있기에, HLS, MPEG-DASH, HTTP-FLV와 같은 기술과 함께 사용된다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;저지연 스트리밍:&lt;/strong&gt; 실시간 스트리밍에 적합한 낮은 지연 시간&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;양방향 통신:&lt;/strong&gt; 클라이언트와 서버 간의 실시간 데이터 전송 가능&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;유연성:&lt;/strong&gt; 비디오, 오디오, 데이터 스트림을 동시에 전송&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;지연시간이-빠른-이유&quot;&gt;지연시간이 빠른 이유&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;지속적인 연결 유지&lt;/strong&gt;: RTMP는 클라이언트와 서버 간에 &lt;strong&gt;지속적인 TCP 연결&lt;/strong&gt;을 유지합니다. 이는 데이터 전송 시마다 새로운 연결을 설정할 필요가 없기 때문에 &lt;strong&gt;연결 설정에 따른 오버헤드&lt;/strong&gt;를 줄여줍니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;작은 청크(chunk) 단위 전송&lt;/strong&gt;: 데이터를 &lt;strong&gt;작은 청크로 분할하여 전송&lt;/strong&gt;함으로써, 데이터가 준비되는 즉시 전송할 수 있습니다. 이는 &lt;strong&gt;버퍼링 시간을 최소화&lt;/strong&gt;하고, 실시간 성능을 향상시킵니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;트위치의 경우 스트리머 → Ingest → Transcode → Replication → Edge → 시청자를 거치며 스트리밍 데이터를 전송&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/9.png&quot; alt=&quot;9&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Ingest - 스트리머의 비디오 영상이 트위치 데이터 센터로 가는 것&lt;/li&gt;
  &lt;li&gt;Transcode - 비디오 형식을 바꾸는 것&lt;/li&gt;
  &lt;li&gt;Replication - 복사. 안정성을 위해&lt;/li&gt;
  &lt;li&gt;Edge - CDN이라고도 부름&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/10.png&quot; alt=&quot;10&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/11.png&quot; alt=&quot;11&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;한계점&quot;&gt;&lt;strong&gt;한계점&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;보안:&lt;/strong&gt; 기본적으로 보안 기능이 내장되어 있지 않아 데이터 암호화가 필요할 경우 추가 설정이 필요함&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;방화벽 문제:&lt;/strong&gt; 전용 포트(기본적으로 1935)를 사용하므로 일부 네트워크 환경에서는 차단될 수 있음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;모바일 지원 부족:&lt;/strong&gt; HTTP 기반 스트리밍 프로토콜(HLS, MPEG-DASH)에 비해 모바일 기기에서의 지원이 제한적&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;확장성:&lt;/strong&gt; 대규모&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;4️⃣srt-secure-reliable-transport&quot;&gt;&lt;strong&gt;4️⃣ SRT (Secure Reliable Transport)&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;OBS 사용&lt;/p&gt;

&lt;h2 id=&quot;개요-1&quot;&gt;&lt;strong&gt;개요&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;개발자:&lt;/strong&gt; Haivision&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;출시 시기:&lt;/strong&gt; 2017년&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;주요 용도:&lt;/strong&gt; 불안정한 네트워크 환경에서도 안정적이고 보안이 강화된 비디오 스트리밍&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;특징:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;보안 강화:&lt;/strong&gt; AES 암호화를 통해 데이터 전송 시 보안을 보장&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;신뢰성:&lt;/strong&gt; 패킷 손실, 지연, 네트워크 변동성에 강한 내성을 가짐&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;적응성:&lt;/strong&gt; 다양한 네트워크 조건에 맞춰 동적으로 조정&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;오픈 소스:&lt;/strong&gt; SRT는 오픈 소스 프로젝트로, 다양한 플랫폼과 쉽게 통합 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;srt의-주요-기능&quot;&gt;&lt;strong&gt;SRT의 주요 기능&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;암호화:&lt;/strong&gt; 전송 중인 데이터를 암호화하여 도청 및 데이터 변조를 방지&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;재전송 메커니즘:&lt;/strong&gt; 패킷 손실 시 재전송을 통해 데이터의 완전성을 유지&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;동적 비트레이트 조정:&lt;/strong&gt; 네트워크 상태에 따라 비트레이트를 자동으로 조정하여 스트리밍 품질을 최적화&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;방화벽 우회:&lt;/strong&gt; UDP 기반이지만, NAT 및 방화벽 환경에서도 안정적으로 동작&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;장점&quot;&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;보안:&lt;/strong&gt; RTMP와 달리 기본적으로 데이터 암호화를 지원하여 보안성이 뛰어남&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;신뢰성:&lt;/strong&gt; 불안정한 네트워크 환경에서도 안정적인 데이터 전송을 보장&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유연성:&lt;/strong&gt; 다양한 네트워크 조건에 적응하여 최적의 스트리밍 품질 제공&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;확장성:&lt;/strong&gt; 대규모 스트리밍 환경에서도 효율적으로 확장 가능&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;오픈 소스:&lt;/strong&gt; 무료로 사용 가능하며, 커뮤니티 지원을 통해 지속적으로 개선됨&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;단점&quot;&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;채택률:&lt;/strong&gt; RTMP에 비해 상대적으로 최근에 등장한 프로토콜로, 기존 인프라와의 호환성 문제 발생 가능&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;설정 복잡성:&lt;/strong&gt; 초기 설정과 최적화를 위해 기술적인 지식이 필요할 수 있음&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;rtmp와-srt의-비교&quot;&gt;&lt;strong&gt;RTMP와 SRT의 비교&lt;/strong&gt;&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;특징&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;RTMP&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;SRT&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;보안&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;기본적으로 보안 기능 없음 (RTMPS로 보안 강화 가능)&lt;/td&gt;
      &lt;td&gt;AES 암호화 내장, 기본적으로 보안 강화&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;전송 프로토콜&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;TCP 기반&lt;/td&gt;
      &lt;td&gt;UDP 기반&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;신뢰성&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;TCP의 신뢰성 제공, 그러나 네트워크 변동성에 취약&lt;/td&gt;
      &lt;td&gt;패킷 손실 복구, 네트워크 변동성에 강한 내성&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;지연 시간&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;낮음&lt;/td&gt;
      &lt;td&gt;낮음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;방화벽 우회&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;전용 포트 사용, 방화벽 문제 발생 가능&lt;/td&gt;
      &lt;td&gt;NAT 및 방화벽 환경에서도 안정적 동작&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;확장성&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;대규모 분산 환경에서 추가 설정 필요&lt;/td&gt;
      &lt;td&gt;대규모 스트리밍 환경에서 효율적으로 확장 가능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;오픈 소스&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;아니오&lt;/td&gt;
      &lt;td&gt;예 (오픈 소스 프로젝트)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;5️⃣mpeg-dash-dynamic-adaptive-streaming-over-http&quot;&gt;&lt;strong&gt;5️⃣ MPEG-DASH (Dynamic Adaptive Streaming over HTTP)&lt;/strong&gt;&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;설명:&lt;/strong&gt; ISO 표준의 HTTP 기반 스트리밍 프로토콜로, 적응형 비트레이트를 지원하며 다양한 미디어 형식을 지원합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;특징:&lt;/strong&gt; 개방형 표준, 다양한 플랫폼과 호환.&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;summary&gt;정리글 원본&lt;/summary&gt;

## 고민지

	- **HLS** **- 지연시간이 높지만 호환성이 좋음 (치지직)**
		- 왜 다른 프로토콜에 비해 지연시간이 길까?
		- 어떻게 지연시간을 낮출 수 있을까?

	### 왜 만들어졌을까? feat. RTSP

	- RTSP는 고정된 비트레이트로 콘텐츠 스트리밍에 최적화
		- 고정 비트레이트의 경우 한가지 속도로만 데이터를 전송하다 보니 네트워크 상태가 변할 때에도 동일한 비트레이트로 스트리밍을 유지해야한다는 문제가 있음

		⇒ 따라서 호환성이 높은 HTTP를 기반으로, **네트워크 상태에 따라 비디오 품질을 실시간으로 조정** 가능한 **가변 비트레이트** 기능까지 도입된 것이 **HLS**


	### HLS(Hypertext Live Streaming)

	- HTTP기반의 단방향 미디어 스트리밍 프로토콜
	- 일반 웹서버 + CDN을 활용해 콘텐츠 배포

	### 왜 다른 프로토콜에 비해 지연시간이 길까?


	![12](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/12.png)_image.png_


	지연시간이 긴 것에는 다양한 원인이 있었음

	1. 동작 방식으로 인한 지연
		1. 서버에서 스트리밍할 비디오 파일을 짧은 세그먼트(2~10초)로 분할 
		→ 재생을 시작하기 위해선 **적어도 몇 개의 세그먼트가 필요해 초기 버퍼링 시간이 길어짐** (세그먼트 길이가 길수록 지연이 커질 수 있음)
		⇒ CDN으로 세그먼트 캐싱해서 데이터 전송 시간을 개선하려함
	2. HTTP 기반 요청-응답 지연
		1. HTTP 기반이므로 **각 세그먼트 마다 서버에 요청을 보내고 응답을 기다리는 시간**이 필요. 네트워크의 상태나 응답 속도에 종속
	3. 가변 비트레이트 지연
		1. 네트워크 상태에 따라 **최적의 비트레이트를 선택하기 위한 모니터링** 진행 
		→ 이 과정에서 비트레이트를 전환하며 지연이 발생함 
		⇒ 지연이 시청 환경을 개선하지만 실시간성에서는 불리함!
	4. CDN 캐싱과 서버 최적화 이슈
		1. 세그먼트 파일이 여러 서버에 캐시되어도 여전히 HTTP 기반으로 동작해 추가적인 통신과정 필요
		2. 특히 사용자 많은 라이브방송에서는 CDN이 적절히 분배되지 않으면 지연 발생

	⇒ 따라서 HLS는 라이브 스트리밍보다는 정적 비디오 플레이어에 더 적합


	### 치지직에서의 HLS 사용법


	[https://medium.com/@delivalue100/hls-http-live-streaming-4fb1d2992d57](https://medium.com/@delivalue100/hls-http-live-streaming-4fb1d2992d57)


	![13](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/13.png)_image.png_


	⇒ 결국 클라이언트가 플레이리스트의 미디어 세그먼트들을 순차적으로 GET하고 마지막쯤에 새로운 세그먼트를 요청하는 흐름이기 때문에 **단방향 통신으로 동작한다.**


	+) 뒤로 돌려보기 안되는 이유..? 돌려보기 자체에 리소스 소모가 큰듯. 그냥 방송 종료 후 다시보기 기능을 넣는게 이득


	### 지연시간 어떻게 개선할 수 있을까?


	[https://www.cdnetworks.com/ko/blog/media-delivery/http-live-streaming/](https://www.cdnetworks.com/ko/blog/media-delivery/http-live-streaming/)

	1. 세그먼트 길이 단축
		1. 6초 이상의 기본적인 세그먼트 길이를 2~1초로 줄이기
			1. 짧아질수록 서버와 클라이언트 사이에 요청이 많아 부하가 생길 수 있으니 균형점을 찾아야함
	2. LL-HLS 도입
		1. 애플이 개발한 HLS의 초저지연 버전
		2. 세그먼트 내에서 더 작은 단위인 파트로 나눠 전송하며, 세그먼트가 완전히 준비되지 않아도 일부를 먼저 전송함
	3. 세그먼트 프리페칭
		1. 클라이언트가 다음 세그먼트를 미리 예측하고 사전 다운로드
	4. 송출 환경 최적화
		1. 치지직 공지사항을 보니 송출 프로그램을 최적화하는 방법도..
		2. 스트리머가 키프레임 간격을 너무 짧게 설정 →세그먼트가 너무 짧아짐, 서버 부하 ⇒ 버퍼링 많아짐 이슈인듯
			1. [https://help.naver.com/notice/noticeView.help?noticeNo=17188&amp;amp;serviceNo=23946&amp;amp;lang=ko](https://help.naver.com/notice/noticeView.help?noticeNo=17188&amp;amp;serviceNo=23946&amp;amp;lang=ko)

	### 치지직의 경우


	기존에 화질이 깨지는 문제 → 서버 부하 이슈로 움직임이 적은 장면에서는 낮은 비트레이트, 빠르게 변하는 장면에서는 높은 비트레이트를 사용해 빠르게 변하는 장면에서 품질이 저하되도록 함.


	⇒ 이후에 서버 장비 도입으로 화질 제한을 풀고 원본 화질에 가깝게 (OBS로 스트리머가 송출하는 화질) 비디오를 전송


	여기서 든 생각 → 어차피 우리의 타겟은 컨퍼런스 발표임, 정적인 장면이 많은 콘텐츠. 초기 치지직 방식대로 낮은 비트레이트를 유지해도 화질 문제는 없을 것 같음. 프레임율 낮추고..


	### 결론

	- **높은 비트레이트와 긴 세그먼트**: 높은 비트레이트를 사용하면서 긴 세그먼트를 전송할 경우, 네트워크 대역폭을 효율적으로 사용할 수 있지만, 지연 시간이 증가. 특히 불안정한 네트워크에서는 재생 품질이 저하됨.
	- **낮은 비트레이트와 짧은 세그먼트**: 낮은 비트레이트와 짧은 세그먼트를 조합하면, 재생 안정성이 높아지고 지연 시간 감소, 비디오 품질은 저하. ⇒ 이게 우리서비스에 적합하지 않을까?

	### 비트레이트랑 세그먼트 조정 어케함?

	1. 비트레이트
		1. `m3u8` 플레이리스트 파일 수정
			1. `EXT-X-STREAM-INF` 태그를 사용하여 비트레이트를 설정

			
```
text
			#EXTM3U
			#EXT-X-VERSION:3
			
			#EXT-X-STREAM-INF:BANDWIDTH=1500000
			# 이 스트림에 대한 메타데이터를 정의
			# BANDWIDTH=1500000은 이 스트림의 대역폭 요구 사항이 1,500,000 비트(1.5 Mbps)임을 나타냄
			
			stream_1500.m3u8
			
```


	2. 세그먼트
		1. FFmpeg로 비디오를 여러 해상도로 인코딩할 때 `-hls_time`을 사용하여 세그먼트의 길이를 설정 (기본 10초)
		2. [https://frontdev.tistory.com/entry/ffmpeg%EB%A1%9C-hls-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EC%98%B5%EC%85%98%EC%A0%95%EB%A6%AC](https://frontdev.tistory.com/entry/ffmpeg%EB%A1%9C-hls-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EC%98%B5%EC%85%98%EC%A0%95%EB%A6%AC)

			
```
text
			- ffmpeg -i hasashin.mp4 -b:v 1M -g 60 -hls_time 2 -hls_list_size 0 -hls_segment_size 500000 output.m3u8
			출처: https://frontdev.tistory.com/entry/ffmpeg로-hls-만들기-옵션정리 [Front End Develop:티스토리]
			
```



## 김영길


	[https://velog.io/@devstefancho/obs-RTMP-%EC%84%9C%EB%B2%84%EB%A1%9C-Live-Streaming](https://velog.io/@devstefancho/obs-RTMP-%EC%84%9C%EB%B2%84%EB%A1%9C-Live-Streaming)


	[https://www.cloudflare.com/ko-kr/learning/video/what-is-http-live-streaming/](https://www.cloudflare.com/ko-kr/learning/video/what-is-http-live-streaming/)


	HLS 는 apple 의 기술이라서 apple 기기에 전부 호환


	반대로 안드로이드나 윈도우에서는 추가적인 로직 필요


	[비디오 → HTTP 파일 조각으로 나눔 → 전송 →] 재생


	HTTP 파일로 나누기 때문에 별도의 전용 서버가 필요하지 않다.


	![14](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/14.png)_image.png_


	![15](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/15.png)_image.png_

	- m3u8 : 메타데이터
		- 시작 태그
		- hls 프로토콜 버전
		- 세그먼트의 최대 길이
		- 첫 번째 세그먼트의 시퀀스 번호
		- 실제 세그먼트의 길이, 다음 세그먼트 인덱스
		- 종료 태그
	- ts : 실제 비디오의 조각들을 담고 있는 컨테이너

	LL-HLS : 저지연


	어떻게 지연 속도를 줄였나


	###  `세그먼트를 또 나누기 -&amp;gt; chunk`


	![16](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/16.png)_image.png_

	- 하나당 10초 정도인 ts 가 아닌 1초 이하 정도의 CMAF 컨테이너에 담아서 생성 즉시 전송한다.

	ㅅ또한 m3u8 파일에 추가적인 메타데이터가 들어간다.


	### 2.1 미디어 변경 또는 광고

	- **#EXT-X-DISCONTINUITY**: 이전 세그먼트와의 **연속성이 끊어짐**을 표시합니다. 이는 광고와 같은 **다른 유형의 미디어를 삽입**할 때 사용됩니다.

		
```
text
		m3u8
		#EXT-X-DISCONTINUITY
		
```


		- **예시**: 이 태그 뒤에 오는 세그먼트는 이전 미디어와는 다르게 인코딩되었거나 다른 타입의 미디어임을 의미합니다.

	### 2.2 변수 비트레이트 및 다중 스트림

	- **#EXT-X-STREAM-INF**: **다중 비트레이트 스트림** 또는 **적응형 스트리밍**을 위해 사용됩니다. 여러 비트레이트를 가진 대체 스트림이 있을 때, 클라이언트가 네트워크 상태에 따라 적절한 스트림을 선택할 수 있도록 합니다.

		
```
text
		m3u8
		#EXT-X-STREAM-INF:BANDWIDTH=800000,RESOLUTION=640x360
		low.m3u8
		#EXT-X-STREAM-INF:BANDWIDTH=1500000,RESOLUTION=1280x720
		medium.m3u8
		
```


		- **예시**: 800kbps, 1500kbps로 각각 다른 해상도의 스트림을 제공합니다. 클라이언트는 네트워크 상황에 따라 적절한 `m3u8` 파일을 선택하게 됩니다.

	### 2.3 키 프레임 및 암호화

	- **#EXT-X-KEY**: 세그먼트의 **암호화 키 정보**를 제공합니다. HLS에서는 콘텐츠 보호를 위해 **AES-128 암호화**를 사용하여 세그먼트를 암호화할 수 있습니다.

		
```
text
		m3u8
		#EXT-X-KEY:METHOD=AES-128,URI=&quot;https://example.com/key&quot;
		
```


		- **예시**: 세그먼트를 AES-128로 암호화하며, 암호화 키를 가져올 위치는 `https://example.com/key`입니다.

	### 2.4 LL-HLS 관련 메타데이터

	- **#EXT-X-PART-INF**: **저지연 HLS**에서 사용되는 태그로, 세그먼트가 **파편(chunk)**으로 나뉘어 전송되는 경우 각 파편의 정보를 포함합니다.

		
```
text
		m3u8
		#EXT-X-PART-INF:PART-TARGET=1.0
		
```


		- **예시**: 각 파편의 타겟 길이가 **1초**임을 의미합니다.
	- **#EXT-X-PRELOAD-HINT**: LL-HLS에서 아직 완료되지 않은 세그먼트나 파편에 대해 **미리 가져올 힌트**를 제공합니다. 이를 통해 클라이언트가 지연 시간을 줄이기 위해 미리 준비할 수 있습니다.

		
```
text
		m3u8
		#EXT-X-PRELOAD-HINT:TYPE=PART,URI=&quot;segment3_part1.ts&quot;
		
```


		- **예시**: `segment3_part1.ts` 파편을 미리 로드할 힌트입니다.

	### `응답 지연`


	저번 금요일에 회고 시간에,  Short Polling, Long Polling 이 나왔던 적이 있었는데 이와 비슷한 방식으로 지연 시간을 줄였다고 보면 쉬울 것 같다.


	Short Polling 은 주기적으로 서버에 요청을 보내서 업데이트 된 사항이 있는지를 체크한다. 만약 업데이트된 사항이 없다면 서버는 304(Not Modified), 200 를 반환한다.


	이때 클라이언트는 업데이트된 사항이 있을 때 까지 또 요청을 보낸다.


	Long Polling (200) 은 클라이언트가 서버에 요청을 보냈을 때, 업데이트가 되기 전까지는 서버가 응답을 되돌려주지 않고 연결을 유지(지연)하다가, 업데이트가 된 순간 응답을 보낸다. 


	기존 HLS는 메타데이터(플레이리스트) 인 .m3u8 파일을 지속적으로 서버에 요청해서 .m3u8 을 토대로 세그먼트를 재생하는 방식인데, `지속적으로 서버에 요청` 이 과정이 지연시간의 주범이다. 이 시간 동안 클라이언트는 세그먼트를 받는게 아니라 대기를 해버리기 때문에, 실제 동영상 파일인 세그먼트를 업데이트가 되고 나서야 받을 수 있다.


	기존 HLS 는 HTTP 요청을 주기적으로 보내서 .m3u8 이 업데이트가 되었는지 확인을 한다. 만약 업데이트가 되지 않았다면 또 서버에 요청을 보내고, 업데이트가 되었다는 응답을 받고 나서야 실제 스트리밍 데이터인 세그먼트를 받아온다. 


	LL-HLS 는 

	- **클라이언트의 플레이리스트 요청**:
		- 클라이언트가 서버에 `.m3u8` **플레이리스트**를 요청합니다. 이때 클라이언트는 **최신 세그먼트**를 가져오기를 원합니다.
	- **서버의 요청 지연(Blocking)**:
		- 만약 서버에 **새로운 세그먼트**가 아직 생성되지 않은 경우, 서버는 즉시 응답을 하지 않고 요청을 **일정 시간 동안 대기(Blocking)** 시킵니다. 이 대기 시간 동안 서버는 새로운 세그먼트가 생성되기를 기다립니다.
	- **새로운 세그먼트 생성 시 응답**:
		- 새로운 세그먼트가 생성되면 서버는 대기 중인 클라이언트의 요청에 응답하여 **최신 플레이리스트**를 반환합니다. 클라이언트는 이를 통해 바로 다음 세그먼트를 가져가 재생을 시작할 수 있습니다.
	- **업데이트 주기 단축**:
		- 이러한 방식은 기존의 주기적인 폴링 방식보다 **지연 시간**을 훨씬 줄일 수 있습니다. 즉, 클라이언트가 계속해서 플레이리스트를 요청하여 최신 정보를 받기 위해 대기하지 않도록 하여 지연 시간을 줄입니다.

	### `서버의 부하`


	LL-HLS 는 세그먼트를 더 짧게 생성하기 때문에 당연히 세그먼트를 더 자주 생성하게 되고, m3u8 의 업데이트도 더 많이 일어난다. 따라서 서버의 부담이 증가하게 된다.


	서버의 부담을 줄이는 방법은 있을까?


	### 2. 서버 부하를 줄이기 위한 방안

	1. **CDN(Content Delivery Network) 사용**
		- **LL-HLS**에서 서버 부하를 줄이기 위해 가장 많이 사용되는 방법 중 하나는 **CDN**을 사용하는 것입니다. CDN은 스트리밍 콘텐츠를 여러 지점에 **캐시**하고, 지리적으로 가까운 사용자에게 콘텐츠를 제공함으로써 **서버의 부하를 분산**시킵니다.
		- CDN을 사용하면 클라이언트가 직접 서버에 연결하는 대신 CDN에서 콘텐츠를 받아가므로, **서버의 직접적인 요청 수**를 줄일 수 있습니다.
	2. **효율적인 세그먼트 생성 및 캐싱**
		- 서버는 세그먼트를 효율적으로 생성하고, **재사용 가능한 세그먼트를 캐싱**함으로써 부하를 줄일 수 있습니다. 특히, 플레이리스트와 세그먼트가 자주 변경되기 때문에, 이를 적절히 캐싱하여 동일한 콘텐츠를 여러 클라이언트가 요청하는 경우 서버에서 재생성할 필요가 없도록 해야 합니다.
	3. **최적의 플레이리스트 및 세그먼트 길이 조정**
		- LL-HLS에서는 지연 시간을 줄이기 위해 세그먼트를 작은 크기로 나누지만, **너무 작은 단위의 세그먼트**는 서버 부하를 크게 증가시킬 수 있습니다. 따라서 **적절한 세그먼트 길이**와 **플레이리스트 갱신 주기**를 설정하여 서버 부하와 지연 시간을 균형 있게 맞추는 것이 중요합니다.

	대신 safari 를 제외한 브라우저에서는 &lt;video&gt; 태그만으로는 재생이 불가능하다. HLS 스트림 변환이 필요하다.

	- hls.js → hls 스트림을 브라우저가 이해할 수 있는 포맷으로 변환하여 &lt;video&gt; 요소에 전달하는 라이브러리
	- 지연시간이 왜 많이 생기는가?
		- UDP 를 사용하는 다른 프로토콜들과 달리 HLS 는 `TCP` 를 사용한다.
		- HLS 는 오히려 실시간에 집중하기 보다는 데이터의 신뢰성과 효율성에 집중한 프로토콜이다.
	- **저지연 HLS(LL-HLS)**
	- [https://medium.com/@cwh./%EB%8F%99%EC%98%81%EC%83%81-%EC%95%88%EB%81%8A%EA%B8%B0%EA%B3%A0-%EB%B3%B4%EB%8A%94%EB%B2%95-feat-ll-hls-a6a0c453b21f](https://medium.com/@cwh./%EB%8F%99%EC%98%81%EC%83%81-%EC%95%88%EB%81%8A%EA%B8%B0%EA%B3%A0-%EB%B3%B4%EB%8A%94%EB%B2%95-feat-ll-hls-a6a0c453b21f)
&lt;details&gt;
&lt;summary&gt;HLS vs WebRTC&lt;/summary&gt;

**HLS**(HTTP Live Streaming)와 **WebRTC**는 모두 실시간 스트리밍을 위한 기술이지만, **사용 목적**, **지연 시간**, **보안** 및 **호환성** 측면에서 큰 차이가 있습니다. 사용하려는 애플리케이션의 유형에 따라 각 기술의 장단점을 비교해보고 어떤 것이 더 적합한지 선택해야 합니다. 아래는 HLS와 WebRTC를 실시간 스트리밍 웹 서비스의 관점에서 비교한 것입니다.


### 1. 지연 시간

- **HLS**:
	- **지연 시간**: HLS는 HTTP 기반 프로토콜로 설계되어 있으며, **10~30초**의 지연 시간이 발생하는 것이 일반적입니다. 심지어 **저지연 HLS(LL-HLS)**를 사용하더라도 2~5초 정도의 지연 시간이 존재할 수 있습니다.
	- **용도**: 따라서 HLS는 실시간성이 요구되지 않는 스트리밍에 적합합니다. 예를 들어, 뉴스 방송, 스포츠 경기, 강의 등의 상황에서 몇 초 정도의 지연이 큰 문제가 되지 않는다면 HLS가 적합합니다.
- **WebRTC**:
	- **지연 시간**: WebRTC는 **1초 미만의 매우 낮은 지연 시간**을 목표로 설계되어, 실시간 인터랙티브한 통신에 적합합니다.
	- **용도**: 화상 회의, 게임 스트리밍, 실시간 원격 조작 등 **매우 빠른 반응**이 필요한 애플리케이션에 적합합니다. WebRTC의 P2P 연결 방식 덕분에 지연 시간을 최소화할 수 있습니다.

### 2. 사용 사례

- **HLS**:
	- **주로 대규모 시청자 대상의 스트리밍**: HLS는 대규모 스트리밍 서비스(예: YouTube, Twitch 등)에서 매우 효과적입니다. HTTP 기반이라 기존 **CDN(Content Delivery Network)** 인프라를 활용해 손쉽게 콘텐츠를 전송할 수 있으며, 수천에서 수백만 명의 시청자가 동시에 스트리밍을 보는 데 적합합니다.
	- **적응형 스트리밍**: 네트워크 상태에 따라 비디오 품질을 조정하는 **적응형 스트리밍**을 기본적으로 제공하므로, 시청자의 네트워크 환경에 맞춰 끊김 없이 서비스를 제공합니다.
- **WebRTC**:
	- **1:1 혹은 소규모 그룹 통신**: WebRTC는 **화상 통화**, **화상 회의**, **온라인 협업 툴** 등 소규모 실시간 커뮤니케이션에 최적화되어 있습니다. 또한, 게임 스트리밍과 같은 실시간 반응이 중요한 상황에도 적합합니다.
	- **P2P 연결**: WebRTC는 주로 **P2P 연결**을 통해 데이터를 직접 전송하므로 서버의 부하를 줄일 수 있지만, 대규모 시청자를 대상으로 하기에 효율적이지 않을 수 있습니다.

### 3. 확장성

- **HLS**:
	- **대규모 스트리밍에 최적**: HLS는 HTTP 기반이기 때문에 **CDN**을 사용하여 확장성을 쉽게 확보할 수 있습니다. 수천 명 이상의 사용자가 동시에 스트리밍을 소비할 수 있으며, 서버 부담을 덜 수 있습니다.
- **WebRTC**:
	- **제한된 확장성**: WebRTC는 브라우저 간 **P2P 연결**을 사용하므로, 직접 연결의 수가 증가할수록 확장성이 제한됩니다. 예를 들어, 많은 참가자 간의 연결이 필요하면 각 클라이언트의 네트워크 및 CPU 자원이 급격히 소모됩니다.
	- **SFU 사용**: 확장성을 늘리기 위해 **SFU(Selective Forwarding Unit)**를 도입하여 각 클라이언트가 모든 참가자와 직접 연결하지 않고 중앙 서버를 통해 연결을 관리할 수 있도록 할 수 있습니다. 이를 통해 약 100명 이상의 사용자까지 확장 가능합니다.

### 4. 네트워크 호환성 및 안정성

- **HLS**:
	- **HTTP 기반 전송**: HLS는 HTTP 기반이기 때문에, 대부분의 방화벽을 통과하고 네트워크 호환성이 매우 뛰어납니다.
	- **안정적**: HTTP와 TCP를 사용하여 데이터 전송이 신뢰적이며, 중간에 발생하는 패킷 손실을 재전송하는 메커니즘이 있어 안정적인 스트리밍을 제공합니다.
- **WebRTC**:
	- **NAT Traversal**: WebRTC는 P2P 연결을 위해 **STUN** 및 **TURN** 서버를 사용하여 NAT 뒤에 있는 클라이언트를 연결합니다. 하지만 네트워크 환경에 따라 연결 설정이 복잡해지거나 문제가 발생할 수 있습니다.
	- **UDP 기반 전송**: 주로 **UDP**를 사용하여 낮은 지연 시간을 제공하지만, 패킷 손실 시 재전송을 보장하지 않아 네트워크 상태가 좋지 않을 때 품질 저하가 발생할 수 있습니다.

### 5. 보안

- **HLS**:
	- **HTTPS와 함께 사용**: HLS는 HTTP 기반으로, **HTTPS**를 사용해 데이터를 암호화할 수 있습니다. 또한, **DRM(디지털 권리 관리)**과 함께 사용해 콘텐츠 보호를 구현할 수 있습니다.
- **WebRTC**:
	- **기본적으로 암호화된 통신**: WebRTC는 모든 오디오, 비디오, 데이터 스트림을 **DTLS**(Datagram Transport Layer Security)와 **SRTP**(Secure Real-Time Transport Protocol)를 사용해 암호화합니다. 기본적으로 강력한 보안이 내장되어 있습니다.

### 6. 브라우저 지원

- **HLS**:
	- **Safari와 iOS 네이티브 지원**: Apple 기기와 Safari 브라우저에서 기본적으로 지원하지만, Chrome, Firefox 등 다른 브라우저에서는 JavaScript 라이브러리(**hls.js**)가 필요합니다.
- **WebRTC**:
	- **모든 최신 브라우저 지원**: WebRTC는 **Chrome**, **Firefox**, **Safari**, **Edge** 등 대부분의 최신 브라우저에서 네이티브로 지원됩니다. 추가적인 플러그인이 필요 없이 실시간 통신 기능을 사용할 수 있습니다.

### 결론

- **HLS**는 **대규모 스트리밍**에 적합하며, 상대적으로 긴 지연 시간을 허용할 수 있는 **방송, 교육, 엔터테인먼트**와 같은 서비스에서 주로 사용됩니다. **HTTP 기반**이므로 네트워크 호환성이 높고, 기존 CDN 인프라를 활용할 수 있는 장점이 있습니다.
- **WebRTC**는 **즉각적인 반응이 필요한 실시간 인터랙티브 애플리케이션**에 적합합니다. **낮은 지연 시간**과 **보안성**을 갖추고 있어 **화상 회의, 실시간 통신, 온라인 협업 도구** 등에 적합하며, 브라우저에서 네이티브로 지원되는 장점이 있습니다. 다만, **확장성** 측면에서는 SFU와 같은 구조적 보완이 필요합니다.

따라서, **대규모 시청자와의 방송**에는 HLS가 적합하고, **소규모 실시간 상호작용**이나 **낮은 지연 시간이 필요한 서비스**에는 WebRTC가 더 나은 선택이 될 것입니다.


&lt;/details&gt;


## 홍창현


	# WebRTC (Web Real-Time Communication)


	웹 브라우저 간에 플러그인의 도움 없이 서로 통신할 수 있도록 설계된 **Javascript API**


	→ 별다른 소프트웨어 없이 카메라, 마이크 등을 사용하여 실시간 커뮤니케이션을 제공


	음성 통화, 영상 통화, P2P 파일 공유 등으로 활용됨


	## WebRTC의 장점


	### WebRTC는 낮은 Latency를 갖는다

	- WebRTC는 **`P2P(peer-to-peer)방식`**으로 데이터를 전송
		- **P2P**는 **중간 서버**를 거치지 않음
	- WebRTC는 **UDP 기반**으로 작동하여 신속하게 패킷을 전송
		- HLS와 RTMP는 **TCP 기반**

	### WebRTC는 호환성이 높다


	![17](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/17.png)_image.png_


	## WebRTC의 단점


	### 많은 사용자가 사용할 수 없다 (스케일링 문제)

	- WebRTC는 P2P(peer-to-peer) 구조로 작동하기 때문에 각 사용자 간의 직접적인 연결을 설정
	- 사용자가 많아질수록 필요한 연결 수가 **기하급수적으로 증가**함

	![18](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/18.png)_image.png_

	- N명의 사용자가 있을 때 사용자 한명이 추가되면 N개의 연결이 필요
		- 서버와 클라이언트 모두에 큰 부담
		- 네트워크 대역폭과 성능 저하 초래

	### 화질 문제 (성능문제)

	- 실시간 비디오와 오디오 스트리밍을 위해 상당한 대역폭을 소모
	- 특히 고화질 비디오 스트림은 많은 대역폭을 요구
	- 대역폭이 제한된 환경에서는 **패킷 손실**이 발생할 수 있으며, 이는 전체 스트림의 품질 저하로 이어짐
		- WebRTC는 **UDP 기반**이므로 패킷 손실이 일어날 수 있음
	- 다수의 사용자가 동시에 스트리밍을 시도하면 **대역폭이 고갈**될 위험

	### 대규모 라이브 방송에 불완전함

	- **예측 불가능한 대역폭 소모**
		- **HLS나 RTMP**의 예측 가능한 방식
			- HLS나 RTMP는 중앙 서버에서 스트리밍을 관리하고 일반적으로 미리 인코딩된 비디오 조각을 전송
			- 스케일링 가능 : 수많은 사용자에게 콘텐츠를 효율적으로 배포할 수 있음
		- **WebRTC**는 미리 인코딩된 스트림을 사용하지 않기 때문에 대역폭이 비디오 품질과 사용자 수에 따라 즉각적으로 변동함

	## WebRTC보다 빠른 기술이 있을까?


	## **WebTransport**

	- WebTransport는 UDP 기반으로 통신
	- WebRTC의 signaling 없이도 서버와의 실시간 데이터 교환 가능

	그러나 WebTransport는 아직 개발 단계이며, 안정적인 표준화가 이루어지지 않아 모든 브라우저에서의 지원이 불확실


	WebRTC처럼 실시간 오디오와 비디오 전송을 위한 최적화가 충분하지 않음


## 김준서


	&amp;gt; 참고자료  
	&amp;gt; [https://www.cdnetworks.com/ko/blog/media-delivery/what-is-rtmp-ingest/](https://www.cdnetworks.com/ko/blog/media-delivery/what-is-rtmp-ingest/)  
	&amp;gt; [https://ossrs.net/lts/en-us/docs/v6/doc/flv](https://ossrs.net/lts/en-us/docs/v6/doc/flv)  
	&amp;gt; [https://growthvalue.tistory.com/178](https://growthvalue.tistory.com/178)  
	&amp;gt; [https://ossrs.net/lts/en-us/docs/v4/doc/delivery-http-flv](https://ossrs.net/lts/en-us/docs/v4/doc/delivery-http-flv)  
	&amp;gt; [https://medium.com/@delivalue100/rtmp-realtime-messaging-protocol-c4474e464ffd](https://medium.com/@delivalue100/rtmp-realtime-messaging-protocol-c4474e464ffd)  
	&amp;gt; [https://obsproject.com/forum/whats-new/posts/2763754/](https://obsproject.com/forum/whats-new/posts/2763754/) - OBS 포럼   
	&amp;gt; [https://devocean.sk.com/blog/techBoardDetail.do?ID=164296](https://devocean.sk.com/blog/techBoardDetail.do?ID=164296)  
	&amp;gt; [https://blog.naver.com/mingyo01/222050438291](https://blog.naver.com/mingyo01/222050438291)  
	&amp;gt; [https://velog.io/@chosj1526/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8A%B8%EC%9C%84%EC%B9%98-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%94%94%EC%9E%90%EC%9D%B8](https://velog.io/@chosj1526/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8A%B8%EC%9C%84%EC%B9%98-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%94%94%EC%9E%90%EC%9D%B8)


	### 용어 정리


	bitrate - 시간당 처리하는 비트의 수


	### RTMP


	어도브에서 규정한 오디오, 비디오 데이터 통신 기술을 의미한다.


	어도브에서 규정한 만큼 기존에는 Flash Player을 지원하기 위해 작성된 기술이었다.


	그러나 최근 어도브에서 Flash Player의 지원을 중단한 만큼 점차 사용률이 저조해지고 있다.


	하지만 이는 클라이언트 단에서의 문제점이고, 영상 데이터를 서버로 옮기고 저장하는 데에 있어서는 높은 지연 시간과 효율을 가지고 있기에, HLS, MPEG-DASH, HTTP-FLV와 같은 기술과 함께 사용된다.


	![19](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/19.png)_image.png_


	![20](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/20.png)_image.png_


	RTMP(Real-Time Messaging Protocol)의 지연 시간이 빠른 이유는 다음과 같습니다:

	1. **지속적인 연결 유지**: RTMP는 클라이언트와 서버 간에 **지속적인 TCP 연결**을 유지합니다. 이는 데이터 전송 시마다 새로운 연결을 설정할 필요가 없기 때문에 **연결 설정에 따른 오버헤드**를 줄여줍니다.
	2. **작은 청크(chunk) 단위 전송**: 데이터를 **작은 청크로 분할하여 전송**함으로써, 데이터가 준비되는 즉시 전송할 수 있습니다. 이는 **버퍼링 시간을 최소화**하고, 실시간 성능을 향상시킵니다.

	트위치의 경우 스트리머 → Ingest → Transcode → Replication → Edge → 시청자를 거치며 스트리밍 데이터를 전송


	![21](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/21.png)_image.png_

	- Ingest - 스트리머의 비디오 영상이 트위치 데이터 센터로 가는 것
	- Transcode - 비디오 형식을 바꾸는 것
	- Replication - 복사. 안정성을 위해
	- Edge - CDN이라고도 부름

	![22](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/22.png)_image.png_


	![23](/upload/2024-10-28-동영상_스트리밍_처리_프로토콜을_알아보자.md/23.png)_image.png_


## 김지수


## RTMP 프로토콜

[bookmark](https://bmobmo.tistory.com/16)


### **1. 영상 전송 프로토콜 종류**

- RTSP : 1996년 온라인 비디오 스트리밍용 프로토콜
- RTMP : 2009년 기술 일반인 공개
- SRT : 2017년 오픈 라이선스 전환
- NDI : 2016년 다양한 소프트웨어에 뉴텍은 무상 배포
- HLS : 애플에 의해 2009년 공개
- DASH : 2011년 공개
- WebRTC : 구글 2011년 공개

### RTSP **(Real Time Streaming Protocol)**


스트리밍의 시작이라고 말할 수 있다. 1996년 등장하였으며 RTSP가 등장 전 영상, 음악 등 멀티미디어 정보를 완전히 다운로드한 후 시청할 수 있었다.


CCTV에서 사용하고 있는 프로토콜


다만 오래된 기술이라 화질 저하, 미디어 서버 운영에 대한 높은 난이도 등으로 도태되고 있는 실정이다.


### RTMP **(Real Time Messaging Protocol)**


### **개요**

- **개발자:** Adobe Systems (원래 Macromedia가 개발)
- **출시 시기:** 2003년
- **주요 용도:** 실시간 비디오 및 오디오 스트리밍, 특히 라이브 방송
- **특징:**
	- **저지연 스트리밍:** 실시간 스트리밍에 적합한 낮은 지연 시간
	- **양방향 통신:** 클라이언트와 서버 간의 실시간 데이터 전송 가능
	- **유연성:** 비디오, 오디오, 데이터 스트림을 동시에 전송

### **한계점**

- **보안:** 기본적으로 보안 기능이 내장되어 있지 않아 데이터 암호화가 필요할 경우 추가 설정이 필요함
- **방화벽 문제:** 전용 포트(기본적으로 1935)를 사용하므로 일부 네트워크 환경에서는 차단될 수 있음
- **모바일 지원 부족:** HTTP 기반 스트리밍 프로토콜(HLS, MPEG-DASH)에 비해 모바일 기기에서의 지원이 제한적
- **확장성:** 대규모

### **SRT (Secure Reliable Transport)**


OBS 사용


### **개요**

- **개발자:** Haivision
- **출시 시기:** 2017년
- **주요 용도:** 불안정한 네트워크 환경에서도 안정적이고 보안이 강화된 비디오 스트리밍
- **특징:**
	- **보안 강화:** AES 암호화를 통해 데이터 전송 시 보안을 보장
	- **신뢰성:** 패킷 손실, 지연, 네트워크 변동성에 강한 내성을 가짐
	- **적응성:** 다양한 네트워크 조건에 맞춰 동적으로 조정
	- **오픈 소스:** SRT는 오픈 소스 프로젝트로, 다양한 플랫폼과 쉽게 통합 가능

### **SRT의 주요 기능**

- **암호화:** 전송 중인 데이터를 암호화하여 도청 및 데이터 변조를 방지
- **재전송 메커니즘:** 패킷 손실 시 재전송을 통해 데이터의 완전성을 유지
- **동적 비트레이트 조정:** 네트워크 상태에 따라 비트레이트를 자동으로 조정하여 스트리밍 품질을 최적화
- **방화벽 우회:** UDP 기반이지만, NAT 및 방화벽 환경에서도 안정적으로 동작

### **장점**

1. **보안:** RTMP와 달리 기본적으로 데이터 암호화를 지원하여 보안성이 뛰어남
2. **신뢰성:** 불안정한 네트워크 환경에서도 안정적인 데이터 전송을 보장
3. **유연성:** 다양한 네트워크 조건에 적응하여 최적의 스트리밍 품질 제공
4. **확장성:** 대규모 스트리밍 환경에서도 효율적으로 확장 가능
5. **오픈 소스:** 무료로 사용 가능하며, 커뮤니티 지원을 통해 지속적으로 개선됨

### **단점**

1. **채택률:** RTMP에 비해 상대적으로 최근에 등장한 프로토콜로, 기존 인프라와의 호환성 문제 발생 가능
2. **설정 복잡성:** 초기 설정과 최적화를 위해 기술적인 지식이 필요할 수 있음

---


## **RTMP와 SRT의 비교**


| **특징**      | **RTMP**                         | **SRT**                   |
| ----------- | -------------------------------- | ------------------------- |
| **보안**      | 기본적으로 보안 기능 없음 (RTMPS로 보안 강화 가능) | AES 암호화 내장, 기본적으로 보안 강화   |
| **전송 프로토콜** | TCP 기반                           | UDP 기반                    |
| **신뢰성**     | TCP의 신뢰성 제공, 그러나 네트워크 변동성에 취약    | 패킷 손실 복구, 네트워크 변동성에 강한 내성 |
| **지연 시간**   | 낮음                               | 낮음                        |
| **방화벽 우회**  | 전용 포트 사용, 방화벽 문제 발생 가능           | NAT 및 방화벽 환경에서도 안정적 동작    |
| **확장성**     | 대규모 분산 환경에서 추가 설정 필요             | 대규모 스트리밍 환경에서 효율적으로 확장 가능 |
| **오픈 소스**   | 아니오                              | 예 (오픈 소스 프로젝트)            |


[bookmark](https://blog.naver.com/n_cloudplatform/222493527661)


**카메라 ▶ Encoder(인코더) ▶ Media Server(+CDN Server) ▶  동영상 플레이어 ▶ 시청자(Client)**


압축되지 않은 동영상은 용량이 크기 때문에 압축하는 과정이 필요하다. 이 과정에서 코덱을 활용한다.


코덱이란?


### **카메라 ▶ Encoder(인코더)**


대표적인 코덱에서는 H.264, 음성은 AAC


웹 배포용으로 사용


원본 파일을 압축할 때, 손실압축, 무손실 압축이 존재함


JPEG - 손실 압축


PNG - 무손실 압축. 이미지 디테일 손실이 없음, 상대적으로 많은 메모리 사용


상황과 목적에 맞는 압축 방식이 필요함


### **Encoder(인코더) ▶ Media Server(+CDN Server)**


스트리밍이란, **멀티미디어 파일을 다운로드 하는 동시에 실행하는 방법이나 기술**을 말합니다. 예를 들면 넷플릭스에서 영화를 보는데 영화 전체를 다운로드 받고 난 뒤에 즉, 2GB 가량의 영상을 전부 다운 받은 후 영화가 재생된다면 사용자 불만이 폭주하겠죠?


​


실제 넷플릭스는 그렇지 않습니다. **다운로드와 동시에 바로 재생이 되며, 추가 다운로드가 계속 진행되는 방식**을 스트리밍이라고 하며, 이러한 스트리밍의 규칙을 ​**스트리밍 프로토콜**이라고 부릅니다.


**Encoder : RTMP,RTSP,webRTC,SRT**
**Player : HLS,DASH,LL-HLS,webRTC,SRT**


**Encoder**의 경우 주로 **RTMP(Real Time Messaging Protocol) 프로토콜**을 사용합니다.


​


과거에는 UDP기반의 RTSP(Real Time Streaming Protocol) 프로토콜을 많이 사용하였으나 최근에는 RTMP 프로토콜이 거의 표준이 되어가고 있습니다.


**Player**의 경우에는 **HLS(HTTP-Live Streaming), MPEG-DASH**가 대표적입니다.


​


스트리밍이란 &apos;다운로드와 동시에 미디어가 재생되는 기술&apos;이라고 설명 드렸는데, 스트리밍의 효율적인 동작을 위해서는 파일을 작은 단위로 분할해야 합니다.


​


이 과정은 대표적인 Player 프로토콜인 HLS, DASH을 통해 알아보도록 하겠습니다.


**Player 프로토콜 작동 과정 이해하기** feat. HLS &amp;amp; DASH


**✅ 우선 H.264 + AAC등 포맷의 동영상 파일을 작은 단위로 분할**​합니다.


(용량에 따라 2초 ~10초 단위)


**​**


**✅ 이와 더불어 분할된 파일의 재생순서가 작성된 manifest 파일을 생성**합니다.


manifest파일에는 분할된 동영상 파일을 어떤 순서로 몇 초간 재생할 것인지에 대한 내용들이 텍스트로 작성되어 있습니다. HLS의 경우에는 .m3u8 파일이, Dash의 경우 .mpd(xml)와 같은 manifest 파일이 생성됩니다.이러한 과정을 거쳐 작은 단위로 분할된 미디어 파일은 mp2ts와 mp4로 구성되어 있고 mp2ts의 확장자는 .ts입니다.


**​**


**✅** 마지막으로 HLS, DASH를 지원하는 브라우저나 Application에서 **Manifest 파일을 읽어서 재생**합니다. Manifest 파일에 작성되어 있는 분할된 동영상 파일을 순차적으로 읽어 들여 재생하게 됩니다. 따라서 첫번째 segment file을 다 불러오게 되면 재생을 시작할 수 있게 되고, 재생이 진행되면서 2번째 및 3번째 segment file을 뒤에서 계속 실행합니다.


​


만약 동영상을 중간부터 재생한다고 하면 manifest 파일(.m3u8, mpd)에 근거하여 해당 타임에 맞는 segment file을 먼저 다운로드를 하게 될 것입니다.


로컬 PC에 녹화하는 기능


### **Media Server(+CDN Server) ▶  동영상 플레이어**


안정적인 송출을 위해서는 충분한 인터넷 업로드, 대역폭이 확보되어야 합니다. 따라서 **Bitrate를 변환**하는 작업도 필수적으로 필요합니다.


**비트레이트(Bitrate)**는 **특정한 시간 단위(이를테면 초 단위)마다 처리하는 비트의 수**를 뜻합니다.


​


나아가 **멀티비트레이트(Multi Bitrate)**는 비디오 플레이어에서 보여지는 화질 선택 기능과 밀접하게 관련이 있습니다. 멀티비트레이트는 **비트레이트가 다른 여러 개의 영상을 준비하여 필요에 따라 영상을 전환하는 방식이나 기술**을 뜻합니다.


### **동영상 플레이어 ▶ 시청자(Client)**


이후 실시간으로 생성한 HLS 및DASH 영상 조각 파일을 사용자에게 전달하려면


**전송 서버**


가 있어야합니다.


**일반적인 미디어 서버는 전송 서버의 역할까지 수행**


하지만, 동시 시청자가 많은 방송일 경우에는


**대규모 트래픽을 안정적으로 처리하기 위해 CDN을 사용**


하는 것을 권장합니다.


[bookmark](https://medium.com/@delivalue100/rtmp-realtime-messaging-protocol-c4474e464ffd)


[bookmark](https://blog.twitch.tv/en/2023/09/28/twitch-state-of-engineering-2023/)


**트랜스코딩** 시스템은 제작자로부터 들어오는 실시간 메시징 프로토콜(RTMP) 스트림을 가져와 HLS 호환 스트림으로 변환합니다.


[bookmark](https://blog.twitch.tv/en/2022/04/26/ingesting-live-video-streams-at-global-scale/)


[bookmark](https://blog.twitch.tv/en/2021/10/25/low-latency-high-reach-creating-an-unparalleled-live-video-streaming-network-at-twitch/)


## **1. 기본 용어**


### **1.1. 스트리밍 (Streaming)**

- **설명:** 동영상이나 오디오 콘텐츠를 다운로드하지 않고 실시간으로 재생하는 기술입니다. 사용자는 데이터가 전송되는 동시에 콘텐츠를 시청할 수 있습니다.
- **예시:** 유튜브, 넷플릭스에서의 동영상 시청.

### **1.2. 버퍼링 (Buffering)**

- **설명:** 원활한 스트리밍을 위해 일시적으로 데이터를 미리 다운로드하여 저장하는 과정입니다. 네트워크 지연이나 변동성이 있을 때 재생 중단을 최소화합니다.
- **예시:** 동영상이 로딩되면서 일시정지 상태가 되는 현상.

### **1.3. 지연 시간 (Latency)**

- **설명:** 데이터가 송신지에서 수신지까지 도달하는 데 걸리는 시간입니다. 실시간 스트리밍에서는 지연 시간이 짧을수록 더 원활한 경험을 제공합니다.
- **예시:** 라이브 방송에서의 채팅 반응 속도.

---


## **2. 기술적 용어**


### **2.1. 코덱 (Codec)**

- **설명:** 비디오와 오디오 데이터를 압축하고 압축을 해제하는 소프트웨어 또는 하드웨어입니다. 효율적인 전송과 저장을 가능하게 합니다.
- **종류:**
	- **H.264 (AVC):** 널리 사용되는 비디오 코덱.
	- **H.265 (HEVC):** H.264보다 더 높은 압축 효율.
	- **VP9, AV1:** 오픈 소스 비디오 코덱.
	- **AAC, MP3:** 오디오 코덱.

### **2.2. 비트레이트 (Bitrate)**

- **설명:** 동영상이나 오디오 데이터의 전송 속도를 비트 단위로 나타낸 값입니다. 높은 비트레이트는 더 나은 품질을 제공하지만, 더 많은 대역폭을 필요로 합니다.
- **종류:**
	- **고정 비트레이트 (CBR):** 일정한 비트레이트로 전송.
	- **가변 비트레이트 (VBR):** 필요에 따라 비트레이트를 조정.

### **2.3. 해상도 (Resolution)**

- **설명:** 화면의 가로와 세로 픽셀 수를 나타내는 지표로, 동영상의 선명도와 품질을 결정합니다.
- **예시:** 1920x1080 (Full HD), 1280x720 (HD), 3840x2160 (4K).

### **2.4. 프레임 레이트 (Frame Rate)**

- **설명:** 초당 표시되는 프레임 수로, 동영상의 부드러움을 결정합니다.
- **예시:** 24fps, 30fps, 60fps.

### **2.5. 컨테이너 (Container)**

- **설명:** 비디오, 오디오, 자막 등의 다양한 미디어 데이터를 하나의 파일로 묶는 형식입니다.
- **종류:**
	- **MP4:** 가장 널리 사용되는 컨테이너.
	- **MKV:** 다양한 코덱과 기능을 지원.
	- **AVI, MOV:** 다른 일반적인 컨테이너 형식.

---


## **3. 스트리밍 프로토콜**


### **3.1. RTMP (Real-Time Messaging Protocol)**

- **설명:** Adobe에서 개발한 실시간 스트리밍 프로토콜로, 라이브 스트리밍에 주로 사용됩니다.
- **특징:** 낮은 지연 시간, 양방향 통신 지원.

### **3.2. HLS (HTTP Live Streaming)**

- **설명:** Apple에서 개발한 HTTP 기반의 스트리밍 프로토콜로, 적응형 비트레이트 스트리밍을 지원합니다.
- **특징:** HTTP 인프라 활용, 광범위한 디바이스 호환성.

### **3.3. MPEG-DASH (Dynamic Adaptive Streaming over HTTP)**

- **설명:** ISO 표준의 HTTP 기반 스트리밍 프로토콜로, 적응형 비트레이트를 지원하며 다양한 미디어 형식을 지원합니다.
- **특징:** 개방형 표준, 다양한 플랫폼과 호환.

### **3.4. WebRTC (Web Real-Time Communication)**

- **설명:** 브라우저 간 실시간 통신을 가능하게 하는 오픈 소스 프로젝트로, 주로 화상 회의 등에 사용됩니다.
- **특징:** 매우 낮은 지연 시간, P2P 연결 지원, 보안 통신.

### **3.5. SRT (Secure Reliable Transport)**

- **설명:** Haivision에서 개발한 프로토콜로, 불안정한 네트워크 환경에서도 안정적인 전송을 목표로 합니다.
- **특징:** 패킷 손실 복구, 보안 기능 강화, 네트워크 적응성.

---


## **4. 인프라 관련 용어**


### **4.1. CDN (Content Delivery Network)**

- **설명:** 전 세계에 분산된 서버 네트워크로, 사용자에게 콘텐츠를 빠르고 안정적으로 전달합니다.
- **기능:** 지리적 근접 서버 사용, 대역폭 분산, 부하 분산.

### **4.2. 인코딩 (Encoding)**

- **설명:** 원본 미디어 데이터를 특정 코덱과 설정을 사용하여 압축 및 변환하는 과정입니다.
- **목적:** 효율적인 저장과 전송을 위해 비트레이트와 해상도를 조정.

### **4.3. 트랜스코딩 (Transcoding)**

- **설명:** 이미 인코딩된 미디어 데이터를 다른 형식이나 코덱으로 변환하는 과정입니다.
- **용도:** 다양한 디바이스와 플랫폼에 맞춘 스트리밍.

### **4.4. 패키징 (Packaging)**

- **설명:** 인코딩된 미디어를 특정 스트리밍 프로토콜 형식으로 변환하는 과정입니다.
- **예시:** HLS, MPEG-DASH를 위한 세그먼트 생성.

### **4.5. 캐싱 (Caching)**

- **설명:** 자주 요청되는 데이터를 임시로 저장하여 접근 속도를 높이는 기술입니다.
- **용도:** CDN에서의 콘텐츠 빠른 전달, 버퍼링 감소.

---


## **5. 품질 및 성능 관련 용어**


### **5.1. 적응형 비트레이트 (Adaptive Bitrate)**

- **설명:** 사용자의 네트워크 조건에 따라 자동으로 비트레이트를 조정하여 최적의 재생 품질을 유지하는 기술입니다.
- **프로토콜:** HLS, MPEG-DASH.

### **5.2. 시작 지연 시간 (Start-up Latency)**

- **설명:** 스트리밍 시작부터 첫 프레임이 재생되기까지 걸리는 시간입니다.
- **중요성:** 사용자 경험에 큰 영향을 미침.

### **5.3. 캐시 히트/미스 (Cache Hit/Miss)**

- **설명:** 요청된 데이터가 캐시에 존재하는지 여부를 나타냅니다. 캐시 히트는 빠른 응답을, 미스는 원본 서버로부터 데이터를 가져와야 함을 의미합니다.

### **5.4. 지터 (Jitter)**

- **설명:** 패킷 전송 간의 시간 변동을 의미하며, 실시간 스트리밍의 품질에 영향을 미칠 수 있습니다.
- **영향:** 영상의 끊김이나 오디오의 왜곡을 유발할 수 있음.

### **5.5. 패킷 손실 (Packet Loss)**

- **설명:** 전송 중에 데이터 패킷이 손실되는 현상입니다.
- **영향:** 영상 및 오디오 품질 저하, 재생 중단.

---


## **6. 기타 관련 용어**


### **6.1. DRM (Digital Rights Management)**

- **설명:** 디지털 콘텐츠의 저작권 보호를 위한 기술 및 정책입니다.
- **용도:** 불법 복제 방지, 콘텐츠 접근 제어.

### **6.2. QoS (Quality of Service)**

- **설명:** 네트워크 성능을 관리하고 보장하기 위한 기술 및 정책입니다.
- **용도:** 스트리밍의 안정성과 품질을 유지.

### **6.3. GOP (Group of Pictures)**

- **설명:** 비디오 인코딩에서 I-프레임, P-프레임, B-프레임 등으로 구성된 프레임 그룹입니다.
- **영향:** 압축 효율과 재생 품질에 영향을 미침.

### **6.4. HDR (High Dynamic Range)**

- **설명:** 더 넓은 색역과 명암 대비를 제공하는 영상 기술입니다.
- **장점:** 더 생동감 있고 현실적인 영상 표현.

### **6.5. LUT (Look-Up Table)**

- **설명:** 색 보정과 그레이딩을 위해 사용되는 표로, 색상 변환을 빠르게 적용할 수 있습니다.
- **용도:** 비디오 후반 작업에서 색상 일관성 유지.

### **6.6. 비디오 월 (Video Wall)**

- **설명:** 여러 대의 디스플레이를 연결하여 하나의 큰 화면을 구성하는 시스템입니다.
- **용도:** 대형 이벤트, 컨트롤 룸, 광고 등에서 사용.

### **6.7. OTT (Over-The-Top)**

- **설명:** 인터넷을 통해 제공되는 미디어 서비스로, 전통적인 방송 플랫폼을 거치지 않습니다.
- **예시:** 넷플릭스, 디즈니+, 아마존 프라임 비디오.

### **6.8. VOD (Video on Demand)**

- **설명:** 사용자가 원하는 시간에 원하는 콘텐츠를 시청할 수 있는 서비스입니다.
- **예시:** 넷플릭스, 유튜브의 프리미엄 서비스.

### **6.9. CDN (Content Delivery Network)**

- **설명:** 전 세계에 분산된 서버 네트워크로, 콘텐츠를 사용자에게 빠르고 효율적으로 전달합니다.
- **예시:** Akamai, Cloudflare, Amazon CloudFront.

### **6.10. 클라우드 인코딩 (Cloud Encoding)**

- **설명:** 클라우드 기반 서비스에서 비디오를 인코딩하는 프로세스입니다.
- **장점:** 확장성, 유연성, 비용 효율성.

## **1. Codec의 어원 (Etymology)**


&quot;Codec&quot;은 두 단어의 합성어입니다:

- **CO**der (인코더): 데이터를 특정 형식으로 변환하거나 압축하는 장치 또는 소프트웨어.
- **DE**coder (디코더): 인코딩된 데이터를 원래 형식으로 복원하거나 해제하는 장치 또는 소프트웨어.

따라서, &quot;Codec&quot;은 &quot;Coder&quot;와 &quot;Decoder&quot;의 결합으로 이루어진 단어입니다. 이 합성어는 1980년대 초반에 처음 등장했으며, 디지털 오디오와 비디오 데이터를 효율적으로 전송하고 저장하기 위해 개발된 기술을 지칭하기 위해 사용되었습니다.


&amp;lt;/details&amp;gt;

&lt;/video&gt;&lt;/video&gt;&lt;/details&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;gominzip&quot;, &quot;hoeeeeeh&quot;, &quot;Jisukim&quot;, &quot;홍창현&quot;, &quot;김준서&quot;]</name>
        
        
      </author>

      

      

      
        <summary type="html">목차</summary>
      

      
      
    </entry>
  
</feed>
