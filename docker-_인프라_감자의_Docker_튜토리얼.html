<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>[docker] 인프라 감자의 Docker 튜토리얼</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />
    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="라이부 개발 블로그" />
<link rel="shortcut icon" href="https://blog.liboo.kr//assets/images/favicon.png" type="image/png" />
<link rel="canonical" href="https://blog.liboo.kr/docker-_%EC%9D%B8%ED%94%84%EB%9D%BC_%EA%B0%90%EC%9E%90%EC%9D%98_Docker_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="Liboo.blog" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="[docker] 인프라 감자의 Docker 튜토리얼" />
    <meta property="og:description" content="목차 🤔 학습 이유 모노레포로 프로젝트를 진행하면서 프론트/백의 통합 CICD 파이프라인을 구축하기 위한 도커 도입이 논의되었으나… 감자인 이슈로 해당 과정을 제대로 이해하지 못했음 ✔️ 들어가기 전 간단 개념 정리 https://www.youtube.com/watch?v=eRfHp16qJq8&amp;t=344s 컨테이너 = 서버 하나의 서버에서는 하나의 소프트웨어만 실행하는 것이 안정적 → but 리소스 낭비 따라서 가상화 기술을 사용해 하나의 컴퓨터에서 여러개의 소프트웨어를" />
    <meta property="og:url" content="https://blog.liboo.kr/docker-_%EC%9D%B8%ED%94%84%EB%9D%BC_%EA%B0%90%EC%9E%90%EC%9D%98_Docker_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC" />
    <meta property="og:image" content="https://blog.liboo.kr/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/0.png" />
    <meta property="article:publisher" content="https://www.facebook.com/ghost" />
    <meta property="article:author" content="https://www.facebook.com/ghost" />
    <meta property="article:published_time" content="2024-11-09T06:37:00+00:00" />
    <meta property="article:modified_time" content="2024-11-09T06:37:00+00:00" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="[docker] 인프라 감자의 Docker 튜토리얼" />
    <meta name="twitter:description" content="목차 🤔 학습 이유 모노레포로 프로젝트를 진행하면서 프론트/백의 통합 CICD 파이프라인을 구축하기 위한 도커 도입이 논의되었으나… 감자인 이슈로 해당 과정을 제대로 이해하지 못했음 ✔️ 들어가기 전 간단 개념 정리 https://www.youtube.com/watch?v=eRfHp16qJq8&amp;t=344s 컨테이너 = 서버 하나의 서버에서는 하나의 소프트웨어만 실행하는 것이 안정적 → but 리소스 낭비 따라서 가상화 기술을 사용해 하나의 컴퓨터에서 여러개의 소프트웨어를" />
    <meta name="twitter:url" content="https://blog.liboo.kr/" />
    <meta name="twitter:image" content="https://blog.liboo.kr/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/0.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Liboo.blog" />
    <meta name="twitter:site" content="@tryghost" />
    <meta name="twitter:creator" content="@tryghost" />
    <meta property="og:image:width" content="1400" />
    <meta property="og:image:height" content="933" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "Liboo.blog",
        "logo": "https://blog.liboo.kr/assets/images/blog-icon.png"
    },
    "url": "https://blog.liboo.kr/docker-_%EC%9D%B8%ED%94%84%EB%9D%BC_%EA%B0%90%EC%9E%90%EC%9D%98_Docker_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC",
    "image": {
        "@type": "ImageObject",
        "url": "https://blog.liboo.kr/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/0.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://blog.liboo.kr/docker-_%EC%9D%B8%ED%94%84%EB%9D%BC_%EA%B0%90%EC%9E%90%EC%9D%98_Docker_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC"
    },
    "description": "목차 🤔 학습 이유 모노레포로 프로젝트를 진행하면서 프론트/백의 통합 CICD 파이프라인을 구축하기 위한 도커 도입이 논의되었으나… 감자인 이슈로 해당 과정을 제대로 이해하지 못했음 ✔️ 들어가기 전 간단 개념 정리 https://www.youtube.com/watch?v=eRfHp16qJq8&amp;t=344s 컨테이너 = 서버 하나의 서버에서는 하나의 소프트웨어만 실행하는 것이 안정적 → but 리소스 낭비 따라서 가상화 기술을 사용해 하나의 컴퓨터에서 여러개의 소프트웨어를"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="[docker] 인프라 감자의 Docker 튜토리얼" href="/feed.xml" />


</head>
<body class="post-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://blog.liboo.kr/"><img src="/assets/images/blog-icon.png" alt="Liboo.blog" /></a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="https://github.com/boostcampwm-2024/web22-LiBoo/blob/dev/README.md">About</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/getting-started/">Getting Started</a></li>
    <li class="nav-try-ghost" role="menuitem"><a href="https://liboo.kr">LiBoo HomePage</a></li>
</ul>

        
    </div>
    <div class="site-nav-right">
        
            <a class="subscribe-button" href="#subscribe">Subscribe</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post ">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime=" 9 November 2024"> 9 November 2024</time>
                    
                </section>
                <h1 class="post-full-title">[docker] 인프라 감자의 Docker 튜토리얼</h1>
            </header>

            
            <figure class="post-full-image" style="background-image: url(/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/0.png)">
            </figure>
            

            <section class="post-full-content">
                <div class="kg-card-markdown">
                    <blockquote>
  <p><strong>목차</strong></p>
</blockquote>

<h2 id="학습-이유">🤔 학습 이유</h2>

<p>모노레포로 프로젝트를 진행하면서 프론트/백의 통합 CICD 파이프라인을 구축하기 위한 도커 도입이 논의되었으나… 감자인 이슈로 해당 과정을 제대로 이해하지 못했음</p>

<h2 id="️들어가기-전-간단-개념-정리">✔️ 들어가기 전 간단 개념 정리</h2>

<p><a href="https://www.youtube.com/watch?v=eRfHp16qJq8&amp;t=344s">https://www.youtube.com/watch?v=eRfHp16qJq8&amp;t=344s</a></p>

<p>컨테이너 = 서버</p>

<p>하나의 서버에서는 하나의 소프트웨어만 실행하는 것이 안정적 → but 리소스 낭비 따라서 <u>가상화 기술을 사용해</u> 하나의 컴퓨터에서 여러개의 소프트웨어를 실행시킴</p>

<p>ex) 하나의 서버에서 소프트웨어를 실행시키는 것은 건물 한층을 한명에게만 임대해주는것.
따라서 임시로 가벽을 세우고 여러명이 쓸 수 있도록. = 서버를 가상화기술로 분리하고 여러 소프트웨어가 실행되도록</p>

<ul>
  <li>가상화 방식
    <ul>
      <li>전통적으로 <strong>가상머신 Virtual Machine</strong>을 사용
  → 프로그램을 실행하고 업그레이드하는데 시간이 오래 걸림</li>
      <li>
        <p><strong>컨테이너 Container</strong> : 한대의 서버에서 여러개의 프로그램을 안정적으로 사용가능. 이전의 가상화 기술보다 가볍고 빠르다.</p>

        <p>⇒ Why? 가벽을 설치하고 임대인이 바뀔 때마다 공사를 다시하는 것이 아닌 임대인이 살 수 있는 컨테이너를 만들어놓고 입주 시에 컨테이너를 그대로 집어넣는 방식</p>
      </li>
    </ul>
  </li>
  <li>컨테이너를 직접 만드는 것은 비효율적. 도커는 컨테이너를 관리하는 프로그램. 도커에게 컨테이너를 만들라고 하면 됨.</li>
  <li>3개의 건물이 생김. 도커도 3개 → 연락이 너무 많이 옴 ⇒ 매니저로 <strong>쿠버네티스</strong> 고용. 컨테이너 오케스트레이션 도구. 오케스트라 지휘자처럼 도커에게 지휘.</li>
</ul>

<blockquote>
  <p>💡 <strong>요약</strong></p>
  <ul>
    <li>
      <p><strong>컨테이너</strong>를 사용하면 한 대의 서버에서 여러 개의 소프트웨어를 안전하고 효율적으로 운영할 수 있다.</p>
    </li>
    <li>
      <p><strong>도커</strong>는 컨테이너를 관리하기 위한 도구로 일종의 프로그램이다</p>
    </li>
    <li>
      <p><strong>쿠버네티스</strong>는 서버가 여러 대 있는 환경에서 각각의 서버의 도커에게 대신 지시해주는 오케스트레이션 도구이다.</p>
    </li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- **컨테이너**를 사용하면 한 대의 서버에서 여러 개의 소프트웨어를 안전하고 효율적으로 운영할 수 있다.
- **도커**는 컨테이너를 관리하기 위한 도구로 일종의 프로그램이다
- **쿠버네티스**는 서버가 여러 대 있는 환경에서 각각의 서버의 도커에게 대신 지시해주는 오케스트레이션 도구이다.
</code></pre></div></div>

<h1 id="가상화-기술-vm-vs-docker">💻 가상화 기술 VM vs Docker</h1>

<p><img src="/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/0.png" alt="0" /><em>image.png</em></p>

<p><a href="https://www.youtube.com/watch?v=LXJhA3VWXFA">https://www.youtube.com/watch?v=LXJhA3VWXFA</a></p>

<h3 id="1-vm가상-머신의-구조">1. <strong>VM(가상 머신)의 구조</strong></h3>

<ul>
  <li><strong>독립된 OS 포함</strong>: 각 VM은 자체적인 <strong>게스트 OS</strong>를 가지고 실행됩니다. VM은 하이퍼바이저(예: VMware, Hyper-V) 위에서 구동되며, 하이퍼바이저는 물리적 하드웨어를 가상화하여 각 VM에 할당합니다.</li>
  <li><strong>하드웨어 가상화</strong>: VM은 CPU, 메모리, 스토리지 등을 포함하여 하드웨어 리소스를 완전히 가상화합니다. 이를 통해 <strong>각 VM이 마치 독립적인 컴퓨터처럼 동작</strong>하게 됩니다.</li>
  <li><strong>왜 무거운가?</strong>: 각 VM은 자체 OS를 포함하고 부팅해야 하며, 하드웨어 수준에서의 격리로 인해 많은 리소스를 소모합니다.</li>
</ul>

<h3 id="2-컨테이너의-구조">2. <strong>컨테이너의 구조</strong></h3>

<ul>
  <li><strong>커널 공유</strong>: 컨테이너는 호스트 OS의 <strong>커널</strong>을 공유합니다. 즉, 컨테이너는 별도의 커널을 포함하지 않고, 실행에 필요한 사용자 공간만을 포함합니다. 예를 들어, 필요한 라이브러리나 애플리케이션 코드만 포함됩니다.</li>
  <li><strong>컨테이너 엔진</strong>: Docker와 같은 컨테이너 엔진은 컨테이너를 실행하고 관리하며, 각 컨테이너는 호스트 OS의 커널을 사용하는 가벼운 프로세스 집합으로 작동합니다.</li>
  <li><strong>왜 가벼운가?</strong>: 커널 수준에서의 격리만으로 애플리케이션의 독립성을 보장하기 때문에 추가 OS 부팅이 필요하지 않아 리소스 소모가 훨씬 적습니다.</li>
</ul>

<h3 id="3-커널의-역할">3. <strong>커널의 역할</strong></h3>

<ul>
  <li><strong>커널</strong>은 OS의 핵심 컴포넌트로, 하드웨어와 소프트웨어 간의 중재 역할을 합니다. VM은 각각 독립된 커널을 가상화된 OS에 포함하고 있어야 하지만, 컨테이너는 호스트 OS의 커널을 공유하여 사용합니다. 이는 커널이 하드웨어 리소스를 다루는 중요한 역할을 하기 때문입니다.</li>
</ul>

<p>⇒ 즉 컨테이너의 경량성과 성능 효율은 바로 이 <strong>커널 공유</strong> 메커니즘 덕분</p>

<h2 id="어떻게-호스트-os-커널-공유가-가능할까-안전할까">어떻게 호스트 OS 커널 공유가 가능할까? 안전할까?</h2>

<p><a href="https://www.inflearn.com/community/questions/1196236/%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%9D%98-%EC%BB%A4%EB%84%90-%EA%B3%B5%EC%9C%A0%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%98%EB%AC%B8%EC%A0%90?srsltid=AfmBOopmw2RLuT4EqO4XtKl0SuDGqEuKPRJFCZfkicqq4vdpkiUpKcDE">https://www.inflearn.com/community/questions/1196236/%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%9D%98-%EC%BB%A4%EB%84%90-%EA%B3%B5%EC%9C%A0%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%98%EB%AC%B8%EC%A0%90?srsltid=AfmBOopmw2RLuT4EqO4XtKl0SuDGqEuKPRJFCZfkicqq4vdpkiUpKcDE</a></p>

<p>리눅스 커널의 특성 덕분입니다. 리눅스 커널은 프로세스 간의 격리를 위해 <strong>네임스페이스(namespaces)</strong>와 <strong>컨트롤 그룹(cgroups)</strong> 같은 기술을 제공합니다.</p>

<ul>
  <li><strong>네임스페이스</strong>: 각 컨테이너는 네임스페이스를 통해 다른 컨테이너 및 호스트 시스템과 격리됩니다. 네임스페이스는 프로세스 ID, 네트워크, 마운트 포인트, 사용자 ID 등 시스템 리소스의 독립적인 뷰를 제공합니다. 예를 들어, 네트워크 네임스페이스는 컨테이너 간의 네트워크 트래픽을 분리해 줍니다.</li>
  <li><strong>컨트롤 그룹(cgroups)</strong>: cgroups는 컨테이너가 사용하는 CPU, 메모리, 디스크 I/O와 같은 리소스를 제한하고 관리합니다. 이를 통해 하나의 컨테이너가 리소스를 과도하게 사용해 호스트나 다른 컨테이너에 영향을 미치지 않도록 합니다.</li>
</ul>

<p>→ 커널 레벨에서 발생할 수 있는 문제가 다른 컨테이너에 영향을 줄 수 있는 단점도 있지만 컨테이너 자체의 보안 기능(seccomp, AppArmor 등)과 쿠버네티스와 같은 오케스트레이션 툴을 통해 멀티 텐트 환경에서도 충분한 격리와 관리가 가능하도록 설계 가능</p>

<p>아직 운영체제를 안 들어서 딥다이브하지 못해 아쉽..</p>

<h1 id="docker">🐳 Docker</h1>

<p>Go언어로 작성된 리눅스 컨테이너 기반으로 하는 어플리케이션을 <strong>패키징</strong> 할 수 있는 툴. 오픈소스 가상화 플랫폼</p>

<ul>
  <li>컨테이너라는 작은 소프트웨어 유닛 안에 어플리케이션, 시스템 툴, 디펜던시를 하나로 묶어서 다른 서버 등 쉽게 배포하고 구동 할 수 있게 함.</li>
</ul>

<h2 id="building-containers">Building Containers</h2>

<h3 id="dockerfile">Dockerfile</h3>

<p>컨테이너를 어떻게 만들어야 한다는 레시피</p>

<ul>
  <li>Copy file</li>
  <li>Install dependencies</li>
  <li>Set environment variables</li>
  <li>Run setup scripts</li>
</ul>

<h3 id="image">Image</h3>

<p>Dockerfile을 기반으로 생성.</p>

<p>어플리케이션 실행에 필요한 코드, 런타임 환경, 시스템 툴, 시스템 라이브러리 등의 세팅을 포함시킴 ⇒ 현재 어플리케이션의 상태를 스냅샷으로 저장한 형태.</p>

<p>만들어진 이미지는 <strong>불변함.</strong></p>

<h3 id="container">Container</h3>

<p>샌드박스처럼 우리가 캡처해둔 어플리케이션의 이미지를 고립된 환경에서 개별적인 파일 시스템 안에서 실행할 수 있는 것.</p>

<p>이미지를 이용해서 어플리케이션을 구동!</p>

<p>Image라는 클래스로 각 인스턴스(스냅샷)을 찍어내고 그 인스턴스를 가지는 각각의 컨테이너를 만들어낸다. → 컨테이너에서 각각 동작하는 어플리케이션은 개별적으로 수정이 가능함. 수정된 파일은 이미지에 영향을 끼치지 않음</p>

<h2 id="shipping-containers">Shipping Containers</h2>

<p><img src="/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/1.png" alt="1" /><em>image.png</em></p>

<h3 id="container-registry">Container Registry</h3>

<p>public과 private으로 나뉨. 회사에서는 대부분 private 이용</p>

<ul>
  <li>public
    <ul>
      <li>Docker Hub, Red Hat quay.io, Github Packages</li>
    </ul>
  </li>
  <li>private
    <ul>
      <li>AWS, Google Cloud, MS Azure</li>
    </ul>
  </li>
</ul>

<p><img src="/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/2.png" alt="2" /><em>image.png</em></p>

<h2 id="실습-1">실습 (1)</h2>

<h3 id="dockerfile-1">Dockerfile</h3>

<p><a href="https://docs.docker.com/build/building/best-practices/">https://docs.docker.com/build/building/best-practices/</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>css
FROM node:16-alpine

WORKDIR /app

COPY package.json package-lock.json ./

RUN npm ci

COPY index.js .

ENTRYPOINT [ "node", "index.js" ]

</code></pre></div></div>

<ol>
  <li>FROM: 베이스 이미지를 지정. alpine은 최소단위의 리눅스 버전.
[https://hub.docker.com/<em>/node/](https://hub.docker.com/</em>/node/)</li>
  <li>WORKDIR: 컨테이너 안에서 어떤 경로에 실행할건지를 명시
ex. /app ⇒ 루트 경로의 app이라는 디렉토리안에 프로젝트 관련 파일을 모두 copy하겠다</li>
  <li>COPY: 도커 파일에서 카피하고 명령어를 실행하는 것은 <u>**레이어 시스템**</u>으로 구성. 따라서 빈번히 변경되는 파일일수록 제일 마지막에 작성하는 것이 좋음 
ex. 소스코드를 담은 index.js가 package.json보다는 빈번히 변경될 가능성이 높음 → 따라서 package.json을 가장 먼저 복사해오도록 작성</li>
  <li>RUN: npm install보다 npm ci를 쓰는게 좋음. 
why? install은 프로젝트에서 사용된 것보다 높은 버전이 나오면 그 버전으로 설치가 되는 이슈 있음. ci를 쓰면 lock.json에 쓰인 버전으로 설치가 가능.
+) yarn install은 yarn.lock 파일이 존재하면 npm ci와 비슷한 방식으로 정확한 버전을 설치해서 일관성 유지 → 그런데 우리 플젝 yarn.lock 날렸는데… 괜찮은건가요?</li>
  <li>COPY: 소스코드 카피</li>
  <li>ENTRYPOINT: 배열에 담긴 커맨드를 합쳐서 실행</li>
</ol>

<h3 id="dockerfile의-레이어-시스템">Dockerfile의 레이어 시스템</h3>

<p><img src="/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/3.png" alt="3" /><em>image.png</em></p>

<p>빈번하게 변경되는 것을 하위 레이어에 두어서 이미지 생성 시간을 감축시킨다.</p>

<h3 id="이미지-만들기">이미지 만들기</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash
docker build -f Dockerfile -t fun-docket . 

</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.</code> : build context, 도커파일이 있는 경로를 지정</li>
  <li><code class="language-plaintext highlighter-rouge">-f Dockerfile</code> : 어떤 도커파일을 쓸건지 지정</li>
  <li><code class="language-plaintext highlighter-rouge">-t fun-docket</code> : 이미지에 이름 부여. 태그</li>
</ul>

<p><img src="/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/4.png" alt="4" /><em>image.png</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash
docker images

</code></pre></div></div>

<p><img src="/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/5.png" alt="5" /><em>오타 이슈..</em></p>

<ul>
  <li>로컬에서 만들어진 이미지 확인</li>
  <li>container registry에 올릴때 repository 이름이 사용됨</li>
  <li>tag는 이미지 버전을 뜻함</li>
</ul>

<h3 id="이미지-실행">이미지 실행</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash
docker run -d -p 8080:8080 fun-docker

</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">-d</code> : detached. 백그라운드에서 계속 동작하도록 함</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">-p</code> : 포트 지정. 호스트머신의 포트와 컨테이너의 포트를 연결</p>

    <p><img src="/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/6.png" alt="6" /><em>image.png</em></p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash
docker ps

</code></pre></div></div>

<p><img src="/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/7.png" alt="7" /><em>image.png</em></p>

<ul>
  <li>현재 실행 중인 컨테이너의 리스트</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash
docker logs {컨테이너 id}

</code></pre></div></div>

<p><img src="/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/8.png" alt="8" /><em>image.png</em></p>

<ul>
  <li>컨테이너 터미널에서 발생하는 로그 확인</li>
  <li>도커 데스크톱에서도 확인 가능</li>
</ul>

<p><img src="/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/9.png" alt="9" /><em>image.png</em></p>

<p>+) 로그인이 계속 Denied 되는 이슈가 있었는데 도커 브라우저의 캐시를 지우고 다시 시도하니 잘 됐음</p>

<h3 id="이미지-배포-with-dockerhub">이미지 배포 with DockerHub</h3>

<p><img src="/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/10.png" alt="10" /><em>image.png</em></p>

<ul>
  <li>docker push gominzip/docker-example:tagname로 만들었으면 로컬 이미지 이름도 레포지토리와 동일하게 docker-example로 일치시켜줘야함</li>
  <li>변경 방법</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash
	docker tag fun-docket:latest gominzip/docker-example:latest
	
</code></pre></div></div>

<p><img src="/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/11.png" alt="11" /><em>image.png</em></p>

<ul>
  <li>로그인하기</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash
	docker login
	
</code></pre></div></div>

<ul>
  <li>이미지 push</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash
	docker push gominzip/docker-example:latest
	
</code></pre></div></div>

<p><img src="/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/12.png" alt="12" /><em>image.png</em></p>

<p><img src="/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/13.png" alt="13" /><em>업로드 된 모습</em></p>

<h1 id="docker-compose">🙌 Docker Compose</h1>

<p><a href="https://www.youtube.com/watch?v=3FY-DzXYu7E">https://www.youtube.com/watch?v=3FY-DzXYu7E</a></p>

<p>compose 파일은 도커 어플리케이션의 서비스, 네트워크, 볼륨 등의 설정을 yaml 형식으로 작성하는 파일</p>

<p><a href="https://docs.docker.com/compose/intro/compose-application-model/">https://docs.docker.com/compose/intro/compose-application-model/</a></p>

<p><img src="/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/14.png" alt="14" /><em>image.png</em></p>

<h2 id="공식문서-코드로-이해하기">공식문서 코드로 이해하기</h2>

<p>프론트엔드와 백엔드로 나누어진 프로젝트의 예시</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yaml
services:
  frontend:
    image: example/webapp  # 프런트엔드 서비스는 'example/webapp' 이미지를 사용
    ports:
      - "443:8043"  # 호스트의 443 포트를 컨테이너의 8043 포트에 매핑 (외부 HTTPS 접근 가능)
    networks:
      - front-tier  # 외부와의 통신을 위한 네트워크
      - back-tier   # 백엔드와의 내부 통신을 위한 네트워크
    configs:
      - httpd-config  # 외부에서 제공되는 HTTP 설정 파일을 주입
    secrets:
      - server-certificate  # 외부에서 제공되는 HTTPS 인증서를 주입

  backend:
    image: example/database  # 백엔드 서비스는 'example/database' 이미지를 사용
    volumes:
      - db-data:/etc/data  # 'db-data'라는 볼륨을 컨테이너의 /etc/data 경로에 마운트 (데이터 저장)
    networks:
      - back-tier  # 프런트엔드와의 내부 통신을 위한 네트워크

volumes:
  db-data:
    driver: flocker  # 'flocker' 드라이버를 사용하여 볼륨을 관리
    driver_opts:
      size: "10GiB"  # 볼륨 크기를 10GiB로 설정

configs:
  httpd-config:
    external: true  # 이 설정 파일은 외부에서 제공됨 (Compose가 생성하지 않음)

secrets:
  server-certificate:
    external: true  # 이 비밀은 외부에서 제공됨 (Compose가 생성하지 않음)

networks:
  # 다음 네트워크는 객체만 정의하면 충분 (세부 설정은 생략)
  front-tier: {}  # 프런트엔드가 사용하는 네트워크
  back-tier: {}   # 프런트엔드와 백엔드 간의 내부 통신 네트워크

</code></pre></div></div>

<ul>
  <li>주 구성 요소
    <ul>
      <li>services</li>
      <li>volumes</li>
      <li>configs</li>
      <li>secrets</li>
      <li>networks</li>
    </ul>

    <p>⇒ service를 제외하고는 실무에서 잘 사용하지 않는 듯</p>
  </li>
</ul>

<h2 id="services">Services</h2>

<p>services는 여러 컨테이너를 정의하는데 사용됨</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yaml
services:
  frontend:
    image: example/webapp

  backend:
    image: example/database 

</code></pre></div></div>

<p>→ frontend와 backend는 각 컨테이너를 정의하게 되며 컨테이너의 이름이 됨</p>

<h3 id="설정-키워드">설정 키워드</h3>

<p><img src="/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/15.png" alt="15" /><em>image.png</em></p>

<h3 id="실행-명령어-및-상태-확인"><strong>실행 명령어 및 상태 확인</strong></h3>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">docker compose up</code></strong>: 프런트엔드와 백엔드 서비스를 시작하고, 필요한 네트워크와 볼륨을 생성하며, 설정 파일과 비밀을 프런트엔드 서비스에 주입.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">docker compose ps</code></strong>: 현재 실행 중인 컨테이너의 상태를 보여주어 어떤 컨테이너가 실행 중인지, 상태는 어떤지, 그리고 사용 중인 포트를 확인 가능.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">docker-compose -f docker-compose-custom.yml up</code></strong>: docker-compose는 기본적으로 ‘docker-compose.yml’ 또는 ‘docker-compose.yaml’의 이름을 사용. 만약 다른 이름으로 관리시 -f 옵션 사용</li>
  <li><strong><code class="language-plaintext highlighter-rouge">docker-compose -d</code></strong> : 백그라운드에서 docker-compose를 실행하기 위해 사용</li>
</ul>

<h2 id="실습-2">실습 (2)</h2>

<p>Dockerfile</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yaml
FROM node:18-alpine

WORKDIR /app

COPY package.json package-lock.json ./

RUN npm ci

COPY . .

EXPOSE 3000

CMD ["npm", "start"]

</code></pre></div></div>

<p>docker-compose.yml</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yaml
version: "3"
services:
  web:
    build: .
    ports:
      - "3000:8080"  # 3000은 호스트 포트, 8080은 컨테이너 포트
    depends_on:
      - database
  database:
    image: mongo:6
    ports:
      - "27017:27017"

</code></pre></div></div>

<p><img src="/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/16.png" alt="16" /><em>image.png</em></p>

<p><img src="/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/17.png" alt="17" /><em>image.png</em></p>

<p><img src="/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/18.png" alt="18" /><em>image.png</em></p>

<p>각 서비스 컨테이너가 실행</p>

<p><img src="/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/19.png" alt="19" /><em>image.png</em></p>

<p>호스트의 3000번 포트로 잘 열림</p>

<p>근데 DB는 이렇게 하는거 아닌거 같음 ㅇㅅㅇ..</p>

<p>아무튼 작동 방식 이해 완.</p>

<h1 id="학습-후기">💬 학습 후기</h1>

<p>늘 인프라에 대한 진입장벽이 있었는데 실습하면서 테스트해보니 그렇게 복잡한 느낌은 아니었다. 실제 프로젝트에 도입하는걸 보면서 쓰이는 이유를 직접 체감해보고 싶다.</p>


                </div>
            </section>

            <!-- Email subscribe form at the bottom of the page -->
            
                <section class="subscribe-form">
                    <h3 class="subscribe-form-title">Subscribe to Liboo.blog</h3>
                    <p>Get the latest posts delivered right to your inbox</p>
                    <form method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  /><input class="location" type="hidden" name="location"  /><input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" type="email" name="email"  placeholder="youremail@example.com" />
    </div>
    <button class="" type="submit" disabled><span>Subscribe</span></button>
    <script type="text/javascript">(function(g,h,o,s,t){h[o]('.location')[s]=h[o]('.location')[s] || g.location.href;h[o]('.referrer')[s]=h[o]('.referrer')[s] || h.referrer;})(window,document,'querySelector','value');</script>
</form>

                </section>
            

            <footer class="post-full-footer">
                <!-- Everything inside the #author tags pulls data from the author -->
                <!-- #author-->
                
                    
                
                    
                
                    
                
                    
                
                    
                
                <!-- /author  -->
            </footer>

            <!-- If you use Disqus comments, just uncomment this block.
            The only thing you need to change is "test-apkdzgmqhj" - which
            should be replaced with your own Disqus site-id. -->
            

        </article>

    </div>
</main>

<!-- Links to Previous/Next posts -->
<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            

            <!-- If there's a next post, display it using the same markup included from - partials/post-card.hbs -->
            
                

    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="/%EC%9B%B9_%EC%86%8C%EC%BC%93%EC%9D%98_%EC%8B%A4%EC%8B%9C%EA%B0%84_%EC%96%91%EB%B0%A9%ED%96%A5_%ED%86%B5%EC%8B%A0_-feat._WS_vs_Socket.io">
                <div class="post-card-image" style="background-image: url(/upload/2024-11-11-웹_소켓의_실시간_양방향_통신_[feat._WS_vs_Socket.io].md/0.png)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/%EC%9B%B9_%EC%86%8C%EC%BC%93%EC%9D%98_%EC%8B%A4%EC%8B%9C%EA%B0%84_%EC%96%91%EB%B0%A9%ED%96%A5_%ED%86%B5%EC%8B%A0_-feat._WS_vs_Socket.io">
                <header class="post-card-header">
                    

                    <h2 class="post-card-title">웹 소켓의 실시간 양방향 통신 [feat. WS vs Socket.io]</h2>
                </header>
                <section class="post-card-excerpt">
                    
                        <p>
  목차


</p>
                    
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                
                    
                
                    
                
                    
                
                    
                
                <span class="reading-time">
                    
                    
                      6 min read
                    
                </span>
            </footer>
        </div>
    </article>

            

            <!-- If there's a previous post, display it using the same markup included from - partials/post-card.hbs -->
            
                

    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="/%EC%99%B8%EB%B6%80%EC%9D%98_%EC%82%AC%EC%9A%A9%EC%9E%90%EA%B0%80_Object_Storage%EC%97%90_%EC%A0%91%EA%B7%BC%ED%95%98%EC%A7%80_%EB%AA%BB%ED%95%98%EB%8A%94_%EA%B6%8C%ED%95%9C_%EC%A0%9C%EC%96%B4">
                <div class="post-card-image" style="background-image: url(/upload/2024-11-08-외부의_사용자가_Object_Storage에_접근하지_못하는_권한_제어.md/0.png)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/%EC%99%B8%EB%B6%80%EC%9D%98_%EC%82%AC%EC%9A%A9%EC%9E%90%EA%B0%80_Object_Storage%EC%97%90_%EC%A0%91%EA%B7%BC%ED%95%98%EC%A7%80_%EB%AA%BB%ED%95%98%EB%8A%94_%EA%B6%8C%ED%95%9C_%EC%A0%9C%EC%96%B4">
                <header class="post-card-header">
                    

                    <h2 class="post-card-title">외부의 사용자가 Object Storage에 접근하지 못하는 권한 제어</h2>
                </header>
                <section class="post-card-excerpt">
                    
                        <p>문제 상황

</p>
                    
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                
                    
                
                    
                
                    
                
                    
                
                <span class="reading-time">
                    
                    
                      1 min read
                    
                </span>
            </footer>
        </div>
    </article>

            

        </div>
    </div>
</aside>

<!-- Floating header which appears on-scroll, included from includes/floating-header.hbs -->
<div class="floating-header">
    <div class="floating-header-logo">
        <a href="https://blog.liboo.kr/">
            
                <img src="/assets/images/favicon.png" alt="Liboo.blog icon" />
            
            <span>Liboo.blog</span>
        </a>
    </div>
    <span class="floating-header-divider">&mdash;</span>
    <div class="floating-header-title">[docker] 인프라 감자의 Docker 튜토리얼</div>
    <div class="floating-header-share">
        <div class="floating-header-share-label">Share this <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"/>
</svg>
</div>
        <a class="floating-header-share-tw" href="https://twitter.com/share?text=%5Bdocker%5D+%EC%9D%B8%ED%94%84%EB%9D%BC+%EA%B0%90%EC%9E%90%EC%9D%98+Docker+%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC&amp;url=https://jekyllt.github.io/jasper2/docker-_%EC%9D%B8%ED%94%84%EB%9D%BC_%EA%B0%90%EC%9E%90%EC%9D%98_Docker_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC"
            onclick="window.open(this.href, 'share-twitter', 'width=550,height=235');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>

        </a>
        <a class="floating-header-share-fb" href="https://www.facebook.com/sharer/sharer.php?u=https://jekyllt.github.io/jasper2/docker-_%EC%9D%B8%ED%94%84%EB%9D%BC_%EA%B0%90%EC%9E%90%EC%9D%98_Docker_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC"
            onclick="window.open(this.href, 'share-facebook','width=580,height=296');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>

        </a>
    </div>
    <progress class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>


<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->


        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://blog.liboo.kr/">Liboo.blog</a> &copy; 2025</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    <a href="https://facebook.com/ghost" target="_blank" rel="noopener">Facebook</a>
                    <a href="https://twitter.com/tryghost" target="_blank" rel="noopener">Twitter</a>
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
        <div id="subscribe" class="subscribe-overlay">
            <a class="subscribe-overlay-close" href="#"></a>
            <div class="subscribe-overlay-content">
                
                    <img class="subscribe-overlay-logo" src="/assets/images/blog-icon.png" alt="Liboo.blog" />
                
                <h1 class="subscribe-overlay-title">Subscribe to Liboo.blog</h1>
                <p class="subscribe-overlay-description">Stay up to date! Get all the latest &amp; greatest posts delivered straight to your inbox</p>
                <form method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  /><input class="location" type="hidden" name="location"  /><input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" type="email" name="email"  placeholder="youremail@example.com" />
    </div>
    <button class="" type="submit" disabled><span>Subscribe</span></button>
    <script type="text/javascript">(function(g,h,o,s,t){h[o]('.location')[s]=h[o]('.location')[s] || g.location.href;h[o]('.referrer')[s]=h[o]('.referrer')[s] || h.referrer;})(window,document,'querySelector','value');</script>
</form>

            </div>
        </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-69281367-1', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
