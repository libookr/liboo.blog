<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>[채팅 서버] 채팅 서버 개선기 기록</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />
    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="라이부 개발 블로그" />
<link rel="shortcut icon" href="https://blog.liboo.kr//assets/images/favicon.png" type="image/png" />
<link rel="canonical" href="https://blog.liboo.kr/%EC%B1%84%ED%8C%85_%EC%84%9C%EB%B2%84-_%EC%B1%84%ED%8C%85_%EC%84%9C%EB%B2%84_%EA%B0%9C%EC%84%A0%EA%B8%B0_%EA%B8%B0%EB%A1%9D" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="Liboo.blog" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="[채팅 서버] 채팅 서버 개선기 기록" />
    <meta property="og:description" content="Redis Adapter 가 모든 레디스 노드에 Broadcast 하는 문제 image.png 레디스 어댑터와 레디스를 활용하면 위와 같이 레디스 pub sub 을 통해서 이벤트를 전달하게 되는데, 문제는 여기서 redis-cluster 를 활용하게 되면 이벤트 전달을 어디에 해야할지 모르기 때문에 모든 레디스 노드에다가 전파하게 된다. Redis Node A, B, C, D …. Z 까지" />
    <meta property="og:url" content="https://blog.liboo.kr/%EC%B1%84%ED%8C%85_%EC%84%9C%EB%B2%84-_%EC%B1%84%ED%8C%85_%EC%84%9C%EB%B2%84_%EA%B0%9C%EC%84%A0%EA%B8%B0_%EA%B8%B0%EB%A1%9D" />
    <meta property="og:image" content="https://blog.liboo.kr/upload/2024-11-23-[채팅_서버]_채팅_서버_개선기_기록.md/0.png" />
    <meta property="article:publisher" content="https://www.facebook.com/ghost" />
    <meta property="article:author" content="https://www.facebook.com/ghost" />
    <meta property="article:published_time" content="2024-11-23T04:14:00+00:00" />
    <meta property="article:modified_time" content="2024-11-23T04:14:00+00:00" />
    <meta property="article:tag" content="Chatting" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="[채팅 서버] 채팅 서버 개선기 기록" />
    <meta name="twitter:description" content="Redis Adapter 가 모든 레디스 노드에 Broadcast 하는 문제 image.png 레디스 어댑터와 레디스를 활용하면 위와 같이 레디스 pub sub 을 통해서 이벤트를 전달하게 되는데, 문제는 여기서 redis-cluster 를 활용하게 되면 이벤트 전달을 어디에 해야할지 모르기 때문에 모든 레디스 노드에다가 전파하게 된다. Redis Node A, B, C, D …. Z 까지" />
    <meta name="twitter:url" content="https://blog.liboo.kr/" />
    <meta name="twitter:image" content="https://blog.liboo.kr/upload/2024-11-23-[채팅_서버]_채팅_서버_개선기_기록.md/0.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Liboo.blog" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="Chatting" />
    <meta name="twitter:site" content="@tryghost" />
    <meta name="twitter:creator" content="@tryghost" />
    <meta property="og:image:width" content="1400" />
    <meta property="og:image:height" content="933" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "Liboo.blog",
        "logo": "https://blog.liboo.kr/assets/images/blog-icon.png"
    },
    "url": "https://blog.liboo.kr/%EC%B1%84%ED%8C%85_%EC%84%9C%EB%B2%84-_%EC%B1%84%ED%8C%85_%EC%84%9C%EB%B2%84_%EA%B0%9C%EC%84%A0%EA%B8%B0_%EA%B8%B0%EB%A1%9D",
    "image": {
        "@type": "ImageObject",
        "url": "https://blog.liboo.kr/upload/2024-11-23-[채팅_서버]_채팅_서버_개선기_기록.md/0.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://blog.liboo.kr/%EC%B1%84%ED%8C%85_%EC%84%9C%EB%B2%84-_%EC%B1%84%ED%8C%85_%EC%84%9C%EB%B2%84_%EA%B0%9C%EC%84%A0%EA%B8%B0_%EA%B8%B0%EB%A1%9D"
    },
    "description": "Redis Adapter 가 모든 레디스 노드에 Broadcast 하는 문제 image.png 레디스 어댑터와 레디스를 활용하면 위와 같이 레디스 pub sub 을 통해서 이벤트를 전달하게 되는데, 문제는 여기서 redis-cluster 를 활용하게 되면 이벤트 전달을 어디에 해야할지 모르기 때문에 모든 레디스 노드에다가 전파하게 된다. Redis Node A, B, C, D …. Z 까지"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="[채팅 서버] 채팅 서버 개선기 기록" href="/feed.xml" />


</head>
<body class="post-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://blog.liboo.kr/"><img src="/assets/images/blog-icon.png" alt="Liboo.blog" /></a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="https://github.com/boostcampwm-2024/web22-LiBoo/blob/dev/README.md">About</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/getting-started/">Getting Started</a></li>
    <li class="nav-try-ghost" role="menuitem"><a href="https://liboo.kr">LiBoo HomePage</a></li>
</ul>

        
    </div>
    <div class="site-nav-right">
        
            <a class="subscribe-button" href="#subscribe">Subscribe</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  tag-chatting post ">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime="23 November 2024">23 November 2024</time>
                    
                        <span class="date-divider">/</span>
                        
                            
                               <a href='/tag/chatting/'>CHATTING</a>
                            
                        
                    
                </section>
                <h1 class="post-full-title">[채팅 서버] 채팅 서버 개선기 기록</h1>
            </header>

            
            <figure class="post-full-image" style="background-image: url(/upload/2024-11-23-[채팅_서버]_채팅_서버_개선기_기록.md/0.png)">
            </figure>
            

            <section class="post-full-content">
                <div class="kg-card-markdown">
                    <h1 id="redis-adapter-가-모든-레디스-노드에-broadcast-하는-문제">Redis Adapter 가 모든 레디스 노드에 Broadcast 하는 문제</h1>

<p><img src="/upload/2024-11-23-[채팅_서버]_채팅_서버_개선기_기록.md/0.png" alt="0" /><em>image.png</em></p>

<p>레디스 어댑터와 레디스를 활용하면 위와 같이 레디스 pub sub 을 통해서 이벤트를 전달하게 되는데, 문제는 여기서 redis-cluster 를 활용하게 되면 이벤트 전달을 어디에 해야할지 모르기 때문에 모든 레디스 노드에다가 전파하게 된다.</p>

<p>Redis Node A, B, C, D …. Z 까지 있을 때, A 에만 전달하면 되는 이벤트를 A~Z 까지 모두 전파하게 된다.</p>

<p>이를 해결하기 위해서는 ShardedAdapter<a href="https://redis.io/docs/latest/develop/interact/pubsub/#sharded-pubsub">https://redis.io/docs/latest/develop/interact/pubsub/#sharded-pubsub</a> 를 활용해야 하는데, SharedAdapter 는 해시함수를 활용해서 데이터를 어떤 노드에 저장해야할지 알고 있다. 따라서 ‘room123’ 으로 메세지가 들어온다면 room123 의 해시값을 계산해서 해당 레디스 샤드군에만 전파한다.</p>

<p>그래서 ioredis + sharded adapter 를 활용하려고 보니까….</p>

<p><img src="/upload/2024-11-23-[채팅_서버]_채팅_서버_개선기_기록.md/1.png" alt="1" /><em>image.png</em></p>

<p><a href="http://socket.io/">socket.io</a> 공식문서 (<a href="https://socket.io/docs/v4/redis-adapter/#with-redis-sharded-pubsub">https://socket.io/docs/v4/redis-adapter/#with-redis-sharded-pubsub</a>)</p>

<p>현재 ioredis 와 redis cluster 를 활용한 sharded adapter 는 사용이 불가능하다고 한다.</p>

<p>실제로 sharded adapter 를 억지로 사용해보려고 하니 <code class="language-plaintext highlighter-rouge">[**Too many cluster redirections during Redis cluster reshard**](https://stackoverflow.com/questions/46472130/too-many-cluster-redirections-during-redis-cluster-reshard)</code> 라는 오류가 난다.</p>

<p>shardedAdapter 는 기존의 subscribe 커맨드가 아닌, (SSUBSCRIBE, SPUBLISH, SUNSUBCRIBE) 같은 커맨드를 사용하는데 ioredis 에서 해당 커맨드를 지원하지 않기 때문.</p>

<p>해결책으로는</p>

<ol>
  <li>ioredis 를 node-redis 로 마이그레이션 + shardedAdapter 사용</li>
  <li>redis cluster 를 버리고 <a href="http://nats.io/">Nats.io</a> 로 마이그레이션</li>
  <li>파티셔닝을 통해서 모든 redis 를 redis cluster 로 묶는 것이 아니라, 실제로 필요한 redis 에만 publish 되도록 하기</li>
</ol>

<h2 id="ioredis-를-node-redis-로-마이그레이션--shardedadapter-사용">ioredis 를 node-redis 로 마이그레이션 + shardedAdapter 사용</h2>

<p>우선 1번의 경우 ioredis 를 사용하던 부분을 전부 node-redis 로 바꾸어야한다는 단점이 있다. 하지만 현재 ioredis 라이브러리 상태를 봤을 때 추가적인 업데이트도 없고 node-redis 의 경우에는 sharded adapter 도 업데이트를 해놓은걸 보면 바꾸는 것도 좋을 것 같다라는 생각이 들었다.</p>

<h2 id="redis-cluster-를-버리고-natsio-로-마이그레이션">redis cluster 를 버리고 <a href="http://nats.io/">Nats.io</a> 로 마이그레이션</h2>

<p>2번의 경우에는</p>

<p><a href="https://channel.io/ko/blog/articles/228efe0c">https://channel.io/ko/blog/articles/228efe0c</a></p>

<p>채널톡의 블로그에서 아주 잘 설명해주고 있다. <a href="http://nats.io/">Nats.io</a> 은 완전 메시 형태로, 처리량은 redis 에 비해 월등히 좋은 수준을 보이지만 subject 가 생길 때 모든 <a href="http://nats.io/">nats.io</a> 의 인스턴스에 pubsub 을 전파해주어야하는데 이 부분에서 오버헤드가 상당히 크게 작용한다.</p>

<h2 id="파티셔닝을-통해서-모든-redis-를-redis-cluster-로-묶는-것이-아니라-실제로-필요한-redis-에만-publish-되도록-하기">파티셔닝을 통해서 모든 redis 를 redis cluster 로 묶는 것이 아니라, 실제로 필요한 redis 에만 publish 되도록 하기</h2>

<p>3번의 경우도 채널톡에서 이미 진행했던 방식인데,</p>

<p><a href="https://channel.io/ko/blog/articles/4ab1f0c2">https://channel.io/ko/blog/articles/4ab1f0c2</a></p>

<p>레디스 클러스터의 문제점이 연관없는(굳이 publish 안보내도 되는) 노드에 publish 를 보낸다는 것이다. 그렇기 때문에 레디스와 채팅서버를 하나의 cluster 로 묶고, 이 클러스터 단위로 여러 개를 수평 확장해서 생성한다. 하나의 거대한 집합이었던 채팅서버 + Redis Cluster 를 조금 더 작은 여러개의 논리적 구조로 쪼개보는 것이다. 그리고 room ID 를 기반으로 이 서비스에 로드밸런싱 되도록 하는 구조이다.</p>

<p>하지만 채널톡 서비스와는 다르게 LiBoo 서비스에서는 SharedWorker 를 활용해서 클라이언트는 1개의 소켓만 생성하게 된다. 하나의 소켓으로 여러 개의 room 에 join 할 수 있다는 뜻인데, 3번처럼 파티셔닝을 하게 될 경우 소켓을 1개로 만든 이유가 사라지게 된다.</p>

<p>A 라는 채팅서버에 WebSocket 연결을 맺었는데 , 채팅 서버 B 에 있는 room 에 접근하려면 새로운 소켓을 생성해서 채팅 서버 B 에 연결해야하기 때문이다.</p>

<h2 id="번외">번외</h2>

<p>채널톡 서비스처럼 만약 우리 서비스도 1개의 소켓이 1개의 room 에만 join 되는 것 처럼, 완벽하게 논리적으로 구조를 나눌 수 있었다면 어땠을지 테스트를 해보았다.</p>

<p>테스트 환경은 macos 에서 도커 컨테이너를 활용했다.</p>

<h3 id="기존-환경">기존 환경</h3>

<p>기존의 환경은 채팅서버 3대를 컨테이너로, 6대의 레디스 노드를 하나의 클러스터로 만든 레디스 클러스터를 컨테이너로 만들었다. 모두 각각의 docker bridge 네트워크를 공유하고 있다.</p>

<p>아래는 pubsub cluster 를 만들기 위해 사용한 docker-compose.yaml 과 config 파일이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yaml
version: "3"
services:
  redis-pubsub-master-1:
    platform: linux/x86_64 # m1 MacOS의 경우
    image: redis:6.2
    container_name: redis-pubsub-m1
    networks:
      redis-pubsub-network:
        ipv4_address: 192.168.101.2
    volumes: # 작성한 설정 파일을 볼륨을 통해 컨테이너에 공유
      - ./redis-pubsub-master-7001.conf:/usr/local/etc/redis/redis.conf
    command: redis-server /usr/local/etc/redis/redis.conf
    ports:
      - 7001:7001
  redis-pubsub-master-2:
    networks:
      redis-pubsub-network:
        ipv4_address: 192.168.101.3
    platform: linux/x86_64
    image: redis:6.2
    container_name: redis-pubsub-m2
    volumes:
      - ./redis-pubsub-master-7002.conf:/usr/local/etc/redis/redis.conf
    command: redis-server /usr/local/etc/redis/redis.conf
    ports:
      - 7002:7002

  redis-pubsub-master-3:
    networks:
      redis-pubsub-network:
        ipv4_address: 192.168.101.4
    platform: linux/x86_64
    image: redis:6.2
    container_name: redis-pubsub-m3
    volumes:
      - ./redis-pubsub-master-7003.conf:/usr/local/etc/redis/redis.conf
    command: redis-server /usr/local/etc/redis/redis.conf
    ports:
      - 7003:7003

  redis-pubsub-master-4:
    platform: linux/x86_64 # m1 MacOS의 경우
    image: redis:6.2
    container_name: redis-pubsub-m4
    networks:
      redis-pubsub-network:
        ipv4_address: 192.168.101.5
    volumes: # 작성한 설정 파일을 볼륨을 통해 컨테이너에 공유
      - ./redis-pubsub-master-7004.conf:/usr/local/etc/redis/redis.conf
    command: redis-server /usr/local/etc/redis/redis.conf
    ports:
      - 7004:7004
  redis-pubsub-master-5:
    networks:
      redis-pubsub-network:
        ipv4_address: 192.168.101.6
    platform: linux/x86_64
    image: redis:6.2
    container_name: redis-pubsub-m5
    volumes:
      - ./redis-pubsub-master-7005.conf:/usr/local/etc/redis/redis.conf
    command: redis-server /usr/local/etc/redis/redis.conf
    ports:
      - 7005:7005

  redis-pubsub-master-6:
    networks:
      redis-pubsub-network:
        ipv4_address: 192.168.101.7
    platform: linux/x86_64
    image: redis:6.2
    container_name: redis-pubsub-m6
    volumes:
      - ./redis-pubsub-master-7006.conf:/usr/local/etc/redis/redis.conf
    command: redis-server /usr/local/etc/redis/redis.conf
    ports:
      - 7006:7006

networks:
  redis-pubsub-network:
    driver: bridge
    ipam:
      config:
        - subnet: 192.168.101.0/24 # 사용자 정의 서브넷


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yaml
port 7001 
# port : 7001 ~ 7006
maxmemory 256mb
maxmemory-policy volatile-lru
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
appendonly yes
bind 0.0.0.0


</code></pre></div></div>

<h3 id="파티셔닝-환경">파티셔닝 환경</h3>

<p>파티셔닝 환경은 채팅 서버 3대, 레디스 노드 1대를 묶어서 docker stack 으로 만들었고 docker overlay 네트워크를 공유하고 있다.</p>

<p>아래는 파티셔닝 환경을 만들기 위해 작성한 docker-compose.yaml 이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yaml
version: '3.8'

services:
  redis-master:
    image: redis:6.2
    command: ["redis-server", "/etc/redis/redis.conf"]
    networks:
      - shared-network
    volumes:
      - ./redis/master.conf:/etc/redis/redis.conf
    deploy:
      replicas: 1

  chat-server:
    image: chattest:latest
    environment:
      LOCAL_REDIS_CONFIG: '[{"host":"host.docker.internal","port":9001},{"host":"host.docker.internal","port":9002},{"host":"host.docker.internal","port":9003}]'
      REDIS_PUBSUB_CONFIG: '{"host":"redis-master","port":6379}'
    networks:
      - shared-network
    deploy:
      replicas: 3  # 3개의 복제본을 생성합니다.
      update_config:
        parallelism: 1  # 한 번에 하나의 컨테이너만 업데이트하도록 설정

networks:
  shared-network:
    external: true
    driver: overlay


</code></pre></div></div>

<p>LOCAL_REDIS_CONFIG 는 캐시용 레디스이므로 지금 진행중인 테스트랑은 무관하다.</p>

<h3 id="결과">결과</h3>

<ul>
  <li>기존 환경(채팅서버 3대와 redis cluster), 파티셔닝 X</li>
</ul>

<p><img src="/upload/2024-11-23-[채팅_서버]_채팅_서버_개선기_기록.md/2.png" alt="2" /><em>image.png</em></p>

<p><img src="/upload/2024-11-23-[채팅_서버]_채팅_서버_개선기_기록.md/3.png" alt="3" /><em>image.png</em></p>

<p>(그래프의 20:38 ~ 20:41)</p>

<p>채팅 서버에 150명의 유저가 3번의 채팅(일반채팅 2번 + 질문채팅 1번, ‘hello’ 라는 내용으로)을 보냈을 때, 각각의 PubSub 컨테이너는 송수신에 5MB 정도씩의 네트워크 사용률을 보였다. (총 30MB 정도)</p>

<ul>
  <li>채팅서버 1대 + 레디스 1대로 파티셔닝하여 여러 개의 서비스로 분리</li>
</ul>

<p><img src="/upload/2024-11-23-[채팅_서버]_채팅_서버_개선기_기록.md/4.png" alt="4" /><em>image.png</em></p>

<p>아무래도 이벤트 자체를 다른 레디스 노드에 publish 하지 않다보니 네트워크 사용량이 많이 줄었다.</p>

<p>보내는 데이터가 1.6MB, 받는 데이터는 0.6MB 정도 되는 것 같다.</p>

<p>다만 파티셔닝 환경은 파티셔닝된 구조에 ‘골고루’ 데이터가 들어온다는 전제로 진행했다보니 당연히 안정적으로 보인다.</p>

<p>아무래도 하나의 (채팅서버 + 레디스) 에 트래픽이 몰린다면 이 구조도 추가 확장이 필요해보인다.</p>

<h1 id="default-room-을-나가면-socketio-의-broadcast-로직이-바뀌는-문제">Default Room 을 나가면 <a href="http://socket.io/">socket.io</a> 의 Broadcast 로직이 바뀌는 문제</h1>

<p><a href="http://socket.io/">socket.io</a> 의 Default Room 을 나가면 Sender 를 포함해서 Broadcast 되는 현상</p>

<ul>
  <li><a href="http://socket.io/">socket.io</a> 는 채팅을 하기 위해 <code class="language-plaintext highlighter-rouge">room</code> 에 join 하게 됩니다. 같은 room 에 있는 클라이언트는 같은 채팅방에 있는 시스템입니다.</li>
  <li><a href="http://socket.io/">socket.io</a> 는 유저의 소켓 연결을 할 때, <a href="http://socket.id/">socket.id</a> 와 동일한 이름의 room (Default Room) 에 자동으로 join 하게 됩니다. 이는 1:1 채팅이나 서버에서 개인에게 공지를 보내는 등의 용도로 사용하게 됩니다.</li>
  <li>그러나 저희 서비스는 위와 같은 1:1 채팅이 없는 실시간 라이브 방송의 채팅이므로 이러한 Default Room 은 사용되지 않은 채 서버의 메모리를 낭비할 여지가 있습니다.</li>
  <li>따라서 소켓 연결을 할 때 Default Room 에 join 하지 않도록 로직을 수정했는데 연관이 없다고 생각했던 broadcast 로직이 바뀌는 현상이 발생했습니다.</li>
  <li>broadcast 는 기본적으로 sender 를 <code class="language-plaintext highlighter-rouge">제외</code> 하고 다른 사람들에게 이벤트를 보내는 로직인데, Default Room 에서 나간 채로 broadcast 를 하게 되면 Sender 를 <code class="language-plaintext highlighter-rouge">포함</code>해서 이벤트를 보내는 로직으로 바뀌는 문제가 발생했습니다. (<a href="https://github.com/socketio/socket.io/issues/4524">관련 이슈 🔗</a>)</li>
</ul>

<p>문제를 해결하기 위해 3가지 정도의 방법을 생각해보았습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- [socket.io](http://socket.io/) 대신 WebSocket 을 사용하면서 room + broadcast 개념을 직접 구현
- [socket.io](http://socket.io/) 의 room 개념을 그대로 유지한 채로 broadcast 로직을 새롭게 구현
- [socket.io](http://socket.io/) 의 broadcast 로직을 직접 수정

이 중에서 broadcast 로직을 직접 수정하는 것이 근본적인 문제를 해결할 수 있는 가장 좋은 방법이라 생각했습니다. 그래서 첫 번째로 프로젝트에서 Default Room 을 수정했을 때 Broadcast 로직이 수정되었으므로 room 에서 나가는 로직과 broadcast 간의 관계에 대해 학습했습니다. broadcast 의 로직을 직접 보기 전까지는 sender 를 제외시키는 과정이 sender 의 [socket.id](http://socket.id/) 를 제외하는 방식일거라 생각했는데 실제로 확인해본 결과 [socket.id](http://socket.id/) 와 같은 room (default room)을 제외시키는 방식이었습니다. default room 을 나가게 되면 해당 room 자체가 사라져버리므로 sender 를 제외시킬 수 없는 문제였습니다.


따라서 만약 room 이 존재하지 않는다면 연결되어 있는 [socket.id](http://socket.id/) 에서 default room 과 같은 [socket.id](http://socket.id/) 가 존재하는지의 여부에 따라 제외할 수 있도록 로직을 추가했습니다.
</code></pre></div></div>

<ul>
  <li>사용하지 않는 Default Room 을 메모리에서 제거 함으로써, 클라이언트 한 명이 연결될때마다 생기던 메모리 낭비를 해결</li>
  <li>sender 를 포함하여 broadcast 되던 로직을 수정하면서 직접 sender 를 제외시켜야 하는 코드를 없애면서 코드 가독성 증가</li>
  <li><a href="http://socket.io/">socket.io</a> 의 이슈에 코멘트 등록 및 컨트리뷰션 가이드라인에 맞게 <a href="https://github.com/socketio/socket.io/pull/5266">PR 🔗</a>을 작성했습니다.</li>
</ul>

                </div>
            </section>

            <!-- Email subscribe form at the bottom of the page -->
            
                <section class="subscribe-form">
                    <h3 class="subscribe-form-title">Subscribe to Liboo.blog</h3>
                    <p>Get the latest posts delivered right to your inbox</p>
                    <form method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  /><input class="location" type="hidden" name="location"  /><input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" type="email" name="email"  placeholder="youremail@example.com" />
    </div>
    <button class="" type="submit" disabled><span>Subscribe</span></button>
    <script type="text/javascript">(function(g,h,o,s,t){h[o]('.location')[s]=h[o]('.location')[s] || g.location.href;h[o]('.referrer')[s]=h[o]('.referrer')[s] || h.referrer;})(window,document,'querySelector','value');</script>
</form>

                </section>
            

            <footer class="post-full-footer">
                <!-- Everything inside the #author tags pulls data from the author -->
                <!-- #author-->
                
                    
                
                    
                
                    
                
                    
                
                    
                
                <!-- /author  -->
            </footer>

            <!-- If you use Disqus comments, just uncomment this block.
            The only thing you need to change is "test-apkdzgmqhj" - which
            should be replaced with your own Disqus site-id. -->
            

        </article>

    </div>
</main>

<!-- Links to Previous/Next posts -->
<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
                
                
                
                
            

            <!-- If there's a next post, display it using the same markup included from - partials/post-card.hbs -->
            
                

    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="/%EB%8B%A4%EC%A4%91_%ED%83%AD%EC%97%90%EC%84%9C_%ED%95%98%EB%82%98%EC%9D%98_%EC%86%8C%EC%BC%93%EC%9D%84_%EA%B3%B5%EC%9C%A0%ED%95%A0_%EC%88%98_%EC%9E%88%EC%9D%84%EA%B9%8C">
                <div class="post-card-image" style="background-image: url(/upload/2024-11-23-다중_탭에서_하나의_소켓을_공유할_수_있을까.md/0.png)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/%EB%8B%A4%EC%A4%91_%ED%83%AD%EC%97%90%EC%84%9C_%ED%95%98%EB%82%98%EC%9D%98_%EC%86%8C%EC%BC%93%EC%9D%84_%EA%B3%B5%EC%9C%A0%ED%95%A0_%EC%88%98_%EC%9E%88%EC%9D%84%EA%B9%8C">
                <header class="post-card-header">
                    

                    <h2 class="post-card-title">다중 탭에서 하나의 소켓을 공유할 수 있을까</h2>
                </header>
                <section class="post-card-excerpt">
                    
                        <p>Why?

</p>
                    
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                
                    
                
                    
                
                    
                
                    
                
                <span class="reading-time">
                    
                    
                      5 min read
                    
                </span>
            </footer>
        </div>
    </article>

            

            <!-- If there's a previous post, display it using the same markup included from - partials/post-card.hbs -->
            
                

    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="/NestJS%EB%A5%BC_%ED%86%B5%ED%95%9C_%EC%9D%BC%EA%B4%80%EC%A0%81%EC%9D%B8_%EC%8B%9C%EC%8A%A4%ED%85%9C_%EC%84%A4%EA%B3%84">
                <div class="post-card-image" style="background-image: url(/upload/2024-11-23-NestJS를_통한_일관적인_시스템_설계.md/0.png)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/NestJS%EB%A5%BC_%ED%86%B5%ED%95%9C_%EC%9D%BC%EA%B4%80%EC%A0%81%EC%9D%B8_%EC%8B%9C%EC%8A%A4%ED%85%9C_%EC%84%A4%EA%B3%84">
                <header class="post-card-header">
                    

                    <h2 class="post-card-title">NestJS를 통한 일관적인 시스템 설계</h2>
                </header>
                <section class="post-card-excerpt">
                    
                        <p>서론

</p>
                    
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                
                    
                
                    
                
                    
                
                    
                
                <span class="reading-time">
                    
                    
                      1 min read
                    
                </span>
            </footer>
        </div>
    </article>

            

        </div>
    </div>
</aside>

<!-- Floating header which appears on-scroll, included from includes/floating-header.hbs -->
<div class="floating-header">
    <div class="floating-header-logo">
        <a href="https://blog.liboo.kr/">
            
                <img src="/assets/images/favicon.png" alt="Liboo.blog icon" />
            
            <span>Liboo.blog</span>
        </a>
    </div>
    <span class="floating-header-divider">&mdash;</span>
    <div class="floating-header-title">[채팅 서버] 채팅 서버 개선기 기록</div>
    <div class="floating-header-share">
        <div class="floating-header-share-label">Share this <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"/>
</svg>
</div>
        <a class="floating-header-share-tw" href="https://twitter.com/share?text=%5B%EC%B1%84%ED%8C%85+%EC%84%9C%EB%B2%84%5D+%EC%B1%84%ED%8C%85+%EC%84%9C%EB%B2%84+%EA%B0%9C%EC%84%A0%EA%B8%B0+%EA%B8%B0%EB%A1%9D&amp;url=https://jekyllt.github.io/jasper2/%EC%B1%84%ED%8C%85_%EC%84%9C%EB%B2%84-_%EC%B1%84%ED%8C%85_%EC%84%9C%EB%B2%84_%EA%B0%9C%EC%84%A0%EA%B8%B0_%EA%B8%B0%EB%A1%9D"
            onclick="window.open(this.href, 'share-twitter', 'width=550,height=235');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>

        </a>
        <a class="floating-header-share-fb" href="https://www.facebook.com/sharer/sharer.php?u=https://jekyllt.github.io/jasper2/%EC%B1%84%ED%8C%85_%EC%84%9C%EB%B2%84-_%EC%B1%84%ED%8C%85_%EC%84%9C%EB%B2%84_%EA%B0%9C%EC%84%A0%EA%B8%B0_%EA%B8%B0%EB%A1%9D"
            onclick="window.open(this.href, 'share-facebook','width=580,height=296');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>

        </a>
    </div>
    <progress class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>


<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->


        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://blog.liboo.kr/">Liboo.blog</a> &copy; 2025</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    <a href="https://facebook.com/ghost" target="_blank" rel="noopener">Facebook</a>
                    <a href="https://twitter.com/tryghost" target="_blank" rel="noopener">Twitter</a>
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
        <div id="subscribe" class="subscribe-overlay">
            <a class="subscribe-overlay-close" href="#"></a>
            <div class="subscribe-overlay-content">
                
                    <img class="subscribe-overlay-logo" src="/assets/images/blog-icon.png" alt="Liboo.blog" />
                
                <h1 class="subscribe-overlay-title">Subscribe to Liboo.blog</h1>
                <p class="subscribe-overlay-description">Stay up to date! Get all the latest &amp; greatest posts delivered straight to your inbox</p>
                <form method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  /><input class="location" type="hidden" name="location"  /><input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" type="email" name="email"  placeholder="youremail@example.com" />
    </div>
    <button class="" type="submit" disabled><span>Subscribe</span></button>
    <script type="text/javascript">(function(g,h,o,s,t){h[o]('.location')[s]=h[o]('.location')[s] || g.location.href;h[o]('.referrer')[s]=h[o]('.referrer')[s] || h.referrer;})(window,document,'querySelector','value');</script>
</form>

            </div>
        </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-69281367-1', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
