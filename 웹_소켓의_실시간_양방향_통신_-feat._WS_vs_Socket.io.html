<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>웹 소켓의 실시간 양방향 통신 [feat. WS vs Socket.io]</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />
    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="The professional publishing platform" />
<link rel="shortcut icon" href="https://blog.liboo.kr//assets/images/favicon.png" type="image/png" />
<link rel="canonical" href="https://blog.liboo.kr/%EC%9B%B9_%EC%86%8C%EC%BC%93%EC%9D%98_%EC%8B%A4%EC%8B%9C%EA%B0%84_%EC%96%91%EB%B0%A9%ED%96%A5_%ED%86%B5%EC%8B%A0_-feat._WS_vs_Socket.io" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="Liboo.blog" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="웹 소켓의 실시간 양방향 통신 [feat. WS vs Socket.io]" />
    <meta property="og:description" content="목차 📌 과거 발표자료를 토대로 정리했습니다 🤔 학습 이유 과거 웹소켓 관련 컨퍼런스 발표까지 해보았지만 실제 프로젝트에서 써보지 않아 휘발되었다…ㅜㅜ 이번 기회에 실시간 &amp; 양방향 통신을 위한 기술들을 조사해보고 어떤 방식으로 우리 서비스의 실시간 채팅 기능을 구현해 볼 지 고민해보고자 한다. HTTP 통신은 클라이언트의 요청이 있을 때 서버가 응답하는 단방향 통신" />
    <meta property="og:url" content="https://blog.liboo.kr/%EC%9B%B9_%EC%86%8C%EC%BC%93%EC%9D%98_%EC%8B%A4%EC%8B%9C%EA%B0%84_%EC%96%91%EB%B0%A9%ED%96%A5_%ED%86%B5%EC%8B%A0_-feat._WS_vs_Socket.io" />
    <meta property="og:image" content="https://blog.liboo.kr/upload/2024-11-11-웹_소켓의_실시간_양방향_통신_[feat._WS_vs_Socket.io].md/0.png" />
    <meta property="article:publisher" content="https://www.facebook.com/ghost" />
    <meta property="article:author" content="https://www.facebook.com/ghost" />
    <meta property="article:published_time" content="2024-11-11T01:25:00+00:00" />
    <meta property="article:modified_time" content="2024-11-11T01:25:00+00:00" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="웹 소켓의 실시간 양방향 통신 [feat. WS vs Socket.io]" />
    <meta name="twitter:description" content="목차 📌 과거 발표자료를 토대로 정리했습니다 🤔 학습 이유 과거 웹소켓 관련 컨퍼런스 발표까지 해보았지만 실제 프로젝트에서 써보지 않아 휘발되었다…ㅜㅜ 이번 기회에 실시간 &amp; 양방향 통신을 위한 기술들을 조사해보고 어떤 방식으로 우리 서비스의 실시간 채팅 기능을 구현해 볼 지 고민해보고자 한다. HTTP 통신은 클라이언트의 요청이 있을 때 서버가 응답하는 단방향 통신" />
    <meta name="twitter:url" content="https://blog.liboo.kr/" />
    <meta name="twitter:image" content="https://blog.liboo.kr/upload/2024-11-11-웹_소켓의_실시간_양방향_통신_[feat._WS_vs_Socket.io].md/0.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Liboo.blog" />
    <meta name="twitter:site" content="@tryghost" />
    <meta name="twitter:creator" content="@tryghost" />
    <meta property="og:image:width" content="1400" />
    <meta property="og:image:height" content="933" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "Liboo.blog",
        "logo": "https://blog.liboo.kr/assets/images/blog-icon.png"
    },
    "url": "https://blog.liboo.kr/%EC%9B%B9_%EC%86%8C%EC%BC%93%EC%9D%98_%EC%8B%A4%EC%8B%9C%EA%B0%84_%EC%96%91%EB%B0%A9%ED%96%A5_%ED%86%B5%EC%8B%A0_-feat._WS_vs_Socket.io",
    "image": {
        "@type": "ImageObject",
        "url": "https://blog.liboo.kr/upload/2024-11-11-웹_소켓의_실시간_양방향_통신_[feat._WS_vs_Socket.io].md/0.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://blog.liboo.kr/%EC%9B%B9_%EC%86%8C%EC%BC%93%EC%9D%98_%EC%8B%A4%EC%8B%9C%EA%B0%84_%EC%96%91%EB%B0%A9%ED%96%A5_%ED%86%B5%EC%8B%A0_-feat._WS_vs_Socket.io"
    },
    "description": "목차 📌 과거 발표자료를 토대로 정리했습니다 🤔 학습 이유 과거 웹소켓 관련 컨퍼런스 발표까지 해보았지만 실제 프로젝트에서 써보지 않아 휘발되었다…ㅜㅜ 이번 기회에 실시간 &amp; 양방향 통신을 위한 기술들을 조사해보고 어떤 방식으로 우리 서비스의 실시간 채팅 기능을 구현해 볼 지 고민해보고자 한다. HTTP 통신은 클라이언트의 요청이 있을 때 서버가 응답하는 단방향 통신"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="웹 소켓의 실시간 양방향 통신 [feat. WS vs Socket.io]" href="/feed.xml" />


</head>
<body class="post-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://blog.liboo.kr/"><img src="/assets/images/blog-icon.png" alt="Liboo.blog" /></a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/getting-started/">Getting Started</a></li>
    <li class="nav-try-ghost" role="menuitem"><a href="https://ghost.org">Try Ghost</a></li>
</ul>

        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
                <a class="social-link social-link-fb" href="https://facebook.com/ghost" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>
</a>
            
            
                <a class="social-link social-link-tw" href="https://twitter.com/tryghost" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>
</a>
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Subscribe</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post ">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime="11 November 2024">11 November 2024</time>
                    
                </section>
                <h1 class="post-full-title">웹 소켓의 실시간 양방향 통신 [feat. WS vs Socket.io]</h1>
            </header>

            
            <figure class="post-full-image" style="background-image: url(/upload/2024-11-11-웹_소켓의_실시간_양방향_통신_[feat._WS_vs_Socket.io].md/0.png)">
            </figure>
            

            <section class="post-full-content">
                <div class="kg-card-markdown">
                    <blockquote>
  <p>목차</p>
</blockquote>

<blockquote>
  <p>📌 과거 발표자료를 토대로 정리했습니다</p>
</blockquote>

<h2 id="학습-이유">🤔 학습 이유</h2>

<p>과거 웹소켓 관련 컨퍼런스 발표까지 해보았지만 실제 프로젝트에서 써보지 않아 휘발되었다…ㅜㅜ</p>

<p>이번 기회에 실시간 &amp; 양방향 통신을 위한 기술들을 조사해보고 어떤 방식으로 우리 서비스의 실시간 채팅 기능을 구현해 볼 지 고민해보고자 한다.</p>

<hr />

<p>HTTP 통신은 클라이언트의 요청이 있을 때 서버가 응답하는 <strong>단방향 통신</strong></p>

<p><img src="/upload/2024-11-11-웹_소켓의_실시간_양방향_통신_(feat._WS_vs_Socket.io).md/0.png" alt="0" /><em>HTTP 통신</em></p>

<p>그럼 실시간 채팅처럼 양방향이면서 실시간 통신이 필요한 기능 구현은 어떻게 할까? 우선 실시간 통신을 위한 몇가지 통신 방식을 알아보자</p>

<h1 id="실시간-통신을-위한-노력">🚀 실시간 통신을 위한 노력</h1>

<h2 id="ajax-polling">AJAX Polling</h2>

<p><img src="/upload/2024-11-11-웹_소켓의_실시간_양방향_통신_(feat._WS_vs_Socket.io).md/1.png" alt="1" /><em>image.png</em></p>

<ul>
  <li>클라이언트가 일정한 주기로 서버에 새로운 업데이트가 없는지 확인하는 HTTP 요청을 보내는 방법</li>
  <li>장점
    <ul>
      <li>구현이 간단하며 대부분의 브라우저에서 지원</li>
      <li>기존 HTTP 인프라를 그대로 사용 가능</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>불필요한 요청과 커넥션을 생성하여 서버의 부담이 커짐</li>
      <li>Real-time 통신이라고 부르기 애매할 정도의 실시간성</li>
      <li>데이터 업데이트 지연 발생</li>
    </ul>
  </li>
  <li>사용 사례
    <ul>
      <li>응답을 실시간으로 받지 않아도 되는 경우</li>
      <li>다수의 사용자가 동시에 사용하는 경우에 적합</li>
      <li>ex. 뉴스 피드, 공지사항 업데이트</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javascript
setInterval(() =&gt; {
  fetch('/api/data')
    .then(response =&gt; response.json())
    .then(data =&gt; {
      console.log('받은 데이터:', data);
    })
    .catch(error =&gt; console.error('오류:', error));
}, 5000); 

</code></pre></div></div>

<h2 id="long-polling">Long Polling</h2>

<p><img src="/upload/2024-11-11-웹_소켓의_실시간_양방향_통신_(feat._WS_vs_Socket.io).md/2.png" alt="2" /><em>image.png</em></p>

<ul>
  <li>클라이언트가 서버에 요청을 보내고 서버에서 변경이 일어날 때까지 응답을 지연시키는 방식
⇒ 데이터가 준비되면 서버가 응답을 보내고, 클라이언트는 즉시 새로운 요청을 보내는 방식으로 지속적인 데이터 수신 구현</li>
  <li>장점
    <ul>
      <li>불필요한 요청 감소, 지속적으로 요청을 보내는 폴링보다 부담이 덜 한 방식</li>
      <li>실시간성 향상, 클라이언트가 새로운 데이터 즉시 받음</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>커넥션의 유지시간을 짧게 갖는다면 폴링과 차이점 x</li>
      <li>지속적으로 연결되어 있기 때문에 다수의 클라이언트에게 동시에
  이벤트가 발생하면 순간적 부담이 급증</li>
    </ul>
  </li>
  <li>사용 사례
    <ul>
      <li>실시간 전달이 중요한데 상태가 빈번하게 갱신되진 않을 때 적합</li>
      <li>채팅, 실시간 알림시스템, 실시간 업데이트가 필요한 협업 도구</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javascript
// 클라이언트 측 Long Polling 예시
function longPoll() {
  fetch('/api/long-poll')
    .then(response =&gt; response.json())
    .then(data =&gt; {
      console.log('받은 데이터:', data);
      // 데이터 처리 로직
      longPoll(); // 재귀 호출로 지속적인 폴링
    })
    .catch(error =&gt; {
      console.error('오류:', error);
      setTimeout(longPoll, 5000); // 오류 발생 시 재시도
    });
}

longPoll(); // 초기 호출

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javascript
//클라이언트 요청 저장
let clients = [];
let messages = [];

app.get('/api/long-poll', (req, res) =&gt; {
  // 클라이언트가 요청을 보낼 때 콜백을 저장
  clients.push(res);

  // 클라이언트 연결이 끊어지면 콜백 제거
  req.on('close', () =&gt; {
    clients = clients.filter(client =&gt; client !== res);
  });
});

// 새로운 메시지가 도착했을 때 모든 클라이언트에게 전송
function broadcastMessage(message) {
  messages.push(message); // 메시지를 저장할 수도 있음.
  clients.forEach(client =&gt; client.json(message));
  clients = []; // 모든 클라이언트 응답을 보낸 후 클라이언트 리스트 초기화
}

</code></pre></div></div>

<h2 id="http-streaming">HTTP Streaming</h2>

<p><img src="/upload/2024-11-11-웹_소켓의_실시간_양방향_통신_(feat._WS_vs_Socket.io).md/3.png" alt="3" /><em>%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-11-11</em>%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.37.58.png_</p>

<ul>
  <li>이벤트가 발생했을 때 응답을 내려주되, 응답을 완료시키지 않고 계속 연결을 유지하는 방식</li>
  <li>장점
    <ul>
      <li>롱폴링에 비해 응답마다 다시 요청을 하지 않아도 되므로 효율적</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>연결시간이 길어질수록 연결 유효성 관리 부담 증가</li>
      <li>클라이언트에서 서버로의 데이터 송신이 어려움</li>
    </ul>
  </li>
</ul>

<h2 id="server-sent-events-sse">Server-Sent Events (SSE)</h2>

<p><img src="/upload/2024-11-11-웹_소켓의_실시간_양방향_통신_(feat._WS_vs_Socket.io).md/4.png" alt="4" /><em>image.png</em></p>

<ul>
  <li>서버와 클라이언트가 첫 연결에 성공하면, 서버는 이벤트 발생 주기별로 클라이언트에게 필요한 데이터를 자동전송</li>
  <li>클라이언트에서 서버로 데이터를 보내는 것은 불가능 (단방향)</li>
  <li>장점
    <ul>
      <li>구현이 비교적 간단하고 효율적임</li>
      <li>자동 재연결 기능 제공</li>
      <li>텍스트 기반 데이터 전송에 최적화됨</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>단방향 통신만 가능함</li>
      <li>과거 브라우저에서 지원되지 않을 수 있음</li>
    </ul>
  </li>
  <li>사용 사례
    <ul>
      <li>클라이언트 요청 필요 없이 서버가 독자적으로 응답을 날리는 연결 형태</li>
      <li>실시간 뉴스 피드, 실시간 주식 시세 업데이트, 실시간 스포츠 경기 점수 업데이트</li>
    </ul>
  </li>
</ul>

<h3 id="sse-처리-흐름-루카스-참고">SSE 처리 흐름 (루카스 참고)</h3>

<ul>
  <li><strong>클라이언트에서 서버로 연결 요청</strong>
    <ul>
      <li><strong>클라이언트는</strong> <strong><code class="language-plaintext highlighter-rouge">EventSource</code></strong> <strong>객체를 생성해</strong> <strong><code class="language-plaintext highlighter-rouge">/sse</code></strong> <strong>경로로</strong> <strong><code class="language-plaintext highlighter-rouge">GET</code></strong> <strong>요청을 보냄.</strong></li>
      <li><strong>이 요청을 통해 데이터를 지속적으로 수신할 준비를 함.</strong></li>
    </ul>
  </li>
  <li>클라이언트는 <strong><code class="language-plaintext highlighter-rouge">EventSource</code></strong> 객체를 생성해 <strong><code class="language-plaintext highlighter-rouge">/sse</code></strong> 경로로 <strong><code class="language-plaintext highlighter-rouge">GET</code></strong> 요청을 보냄.</li>
  <li>이 요청을 통해 데이터를 지속적으로 수신할 준비를 함.</li>
  <li><strong>서버에서 연결을 유지하고 스트리밍 응답 시작</strong>
    <ul>
      <li><strong>서버는 클라이언트의 요청에 대해</strong> <strong><code class="language-plaintext highlighter-rouge">Content-Type: text/event-stream</code></strong> <strong>헤더를 설정하고 응답을 유지함.</strong></li>
      <li><strong>이 상태에서 서버는 데이터를 계속해서 클라이언트로 푸시할 수 있음.</strong></li>
    </ul>
  </li>
  <li>서버는 클라이언트의 요청에 대해 <strong><code class="language-plaintext highlighter-rouge">Content-Type: text/event-stream</code></strong> 헤더를 설정하고 응답을 유지함.</li>
  <li>이 상태에서 서버는 데이터를 계속해서 클라이언트로 푸시할 수 있음.</li>
  <li><strong>서버가 주기적으로 데이터를 전송</strong>
    <ul>
      <li><strong>서버는 특정 이벤트나 일정 시간 간격에 따라 데이터를</strong> <strong><code class="language-plaintext highlighter-rouge">res.write()</code></strong> <strong>메서드를 사용해 클라이언트로 전송함.</strong></li>
      <li><strong>각 메시지는</strong> <strong><code class="language-plaintext highlighter-rouge">data:</code></strong><strong>로 시작하고 두 개의 개행 문자(</strong><strong><code class="language-plaintext highlighter-rouge">\n\n</code></strong><strong>)로 끝내야 하며, 이를 통해 클라이언트는 메시지의 끝을 구분할 수 있음.</strong></li>
    </ul>
  </li>
  <li>서버는 특정 이벤트나 일정 시간 간격에 따라 데이터를 <strong><code class="language-plaintext highlighter-rouge">res.write()</code></strong> 메서드를 사용해 클라이언트로 전송함.</li>
  <li>각 메시지는 <strong><code class="language-plaintext highlighter-rouge">data:</code></strong>로 시작하고 두 개의 개행 문자(<strong><code class="language-plaintext highlighter-rouge">\n\n</code></strong>)로 끝내야 하며, 이를 통해 클라이언트는 메시지의 끝을 구분할 수 있음.</li>
  <li><strong>클라이언트에서 실시간으로 데이터 수신</strong>
    <ul>
      <li><strong>클라이언트는</strong> <strong><code class="language-plaintext highlighter-rouge">onmessage</code></strong> <strong>이벤트 핸들러를 통해 서버에서 전송된 데이터를 실시간으로 수신하고 처리할 수 있음.</strong></li>
    </ul>
  </li>
  <li>클라이언트는 <strong><code class="language-plaintext highlighter-rouge">onmessage</code></strong> 이벤트 핸들러를 통해 서버에서 전송된 데이터를 실시간으로 수신하고 처리할 수 있음.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javascript
// 클라이언트 측 SSE 연결 시작
const eventSource = new EventSource('/sse');

eventSource.onmessage = (event) =&gt; {
  console.log('받은 데이터:', event.data); //서버에서 전송된 데이터 수신 및 처리
};

eventSource.onerror = (error) =&gt; {
  console.error('SSE 오류:', error); // 오류 발생 시 처리
};

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javascript
const express = require('express');
const app = express();

app.get('/sse', (req, res) =&gt; {
  // SSE 응답 헤더 설정
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');

  // 클라에게 응답
  const sendMessage = () =&gt; {
    const data = `서버 시간: ${new Date().toLocaleTimeString()}`;
    res.write(`data: ${data}\n\n`); // 클라이언트로 데이터 전송
  };

  // 5초마다 메시지 전송
  const intervalId = setInterval(sendMessage, 5000);

  // 클라이언트가 연결을 닫으면 interval 중단
  req.on('close', () =&gt; {
    clearInterval(intervalId);
  });
});


</code></pre></div></div>

<p>⇒ 결과적으로 위 모든 방법이 HTTP를 통해 통신하기 때문에 Request, Response 둘 다 Header가 불필요하게 큼</p>

<h1 id="websocket-웹-소켓">🌐 WebSocket 웹 소켓</h1>

<ul>
  <li>W3C와 IETF에 의해 자리잡은 표준 프로토콜 중 하나</li>
  <li>HTML5 표준 기술로, 사용자의 브라우저와 서버 사이의 동적인 양방향 연결 채널을 구성</li>
  <li>Websocket API를 통해 서버로 메세지를 보내고, 요청 없이 응답을 받아오는 것이 가능!
    <ul>
      <li>TCP프로토콜을 기반으로 작동하며, 데이터가 순서대로 전송되도록 하고 오류가 발생할 경우 자동으로 복구.</li>
      <li>HTTP 핸드셰이크로 연결을 시작한 후 TCP 소켓을 통해 양방향 데이터 전송을 지속함.</li>
    </ul>
  </li>
  <li>양방향 통신 &amp; 실시간 네트워킹</li>
</ul>

<h2 id="웹-소켓의-동작-과정">웹 소켓의 동작 과정</h2>

<p>Request와 Response의 구체적인 내용에 대해서는 첨부하지 않았다..</p>

<p><a href="https://www.youtube.com/watch?v=MPQHvwPxDUw">https://www.youtube.com/watch?v=MPQHvwPxDUw</a></p>

<p>위 영상을 토대로 공부했다!</p>

<p><img src="/upload/2024-11-11-웹_소켓의_실시간_양방향_통신_(feat._WS_vs_Socket.io).md/5.png" alt="5" /><em>image.png</em></p>

<p><img src="/upload/2024-11-11-웹_소켓의_실시간_양방향_통신_(feat._WS_vs_Socket.io).md/6.png" alt="6" /><em>image.png</em></p>

<p><img src="/upload/2024-11-11-웹_소켓의_실시간_양방향_통신_(feat._WS_vs_Socket.io).md/7.png" alt="7" /><em>image.png</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javascript
// 클라이언트 측 WebSocket 예시
const socket = new WebSocket('ws://localhost:8080');

socket.onopen = () =&gt; {
  console.log('WebSocket 연결 성공');
  socket.send('서버야 이거 받아볼래?');
};

socket.onmessage = (event) =&gt; {
  console.log('서버로부터 메시지:', event.data);
  // 메시지 처리 로직
};

socket.onerror = (error) =&gt; {
  console.error('WebSocket 오류:', error);
};

socket.onclose = () =&gt; {
  console.log('WebSocket 연결 종료');
};

</code></pre></div></div>

<h1 id="ws-모듈-vs-socketio">👀 WS 모듈 vs Socket.io</h1>

<p><a href="https://www.peterkimzz.com/websocket-vs-socket-io">https://www.peterkimzz.com/websocket-vs-socket-io</a></p>

<p><code class="language-plaintext highlighter-rouge">ws</code> 모듈과 <code class="language-plaintext highlighter-rouge">Socket.io</code>는 둘 다 실시간 양방향 통신을 가능하게 하는 Node.js 기반의 라이브러리이지만, 기능과 사용 편의성 측면에서 차이가 있음</p>

<h2 id="ws-모듈">WS 모듈</h2>

<ul>
  <li>특징
    <ul>
      <li><strong>웹소켓 표준 구현</strong>: <code class="language-plaintext highlighter-rouge">ws</code>는 기본적인 웹소켓 프로토콜에 대한 가벼운 구현입니다.</li>
      <li><strong>최소한의 종속성</strong>: 다른 라이브러리에 비해 종속성이 적고, 성능에 초점을 맞춘 경량 라이브러리입니다.</li>
      <li><strong>자유도</strong>: 개발자가 더 세부적인 부분을 제어할 수 있습니다.</li>
    </ul>
  </li>
  <li>장점
    <ul>
      <li><strong>성능</strong>: 단순하고 가벼운 구조로 인해 성능이 좋습니다.</li>
      <li><strong>유연성</strong>: 개발자가 직접 다양한 기능을 구현할 수 있어 커스터마이징에 유리합니다.</li>
      <li><strong>표준 준수</strong>: 웹소켓 표준 프로토콜을 직접 구현하므로, 다른 웹소켓 클라이언트와 호환이 잘 됩니다.</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li><strong>저수준 인터페이스</strong>: 사용이 비교적 복잡하며, 연결 관리, 재시도, 브로드캐스팅 같은 기능을 직접 구현해야 합니다.</li>
      <li><strong>부가 기능 부족</strong>: 자동 재연결, 룸 기능, 이벤트 기반 구조 같은 고급 기능이 없습니다.</li>
    </ul>
  </li>
</ul>

<h2 id="socketio">Socket.io</h2>

<ul>
  <li>특징
    <ul>
      <li><strong>웹소켓 + 폴백</strong>: 기본적으로 웹소켓을 사용하지만, 웹소켓을 지원하지 않는 환경에서는 폴링(polling)으로 폴백(fallback)합니다.</li>
      <li><strong>추가 기능 제공</strong>: 이벤트 기반 통신, 자동 재연결, 브로드캐스트, 네임스페이스 및 룸 기능을 제공합니다.</li>
      <li><strong>클라이언트 라이브러리 필요</strong>: 클라이언트에서도 <code class="language-plaintext highlighter-rouge">Socket.io</code> 라이브러리가 필요합니다.</li>
    </ul>
  </li>
  <li>장점
    <ul>
      <li><strong>편리성</strong>: 복잡한 설정 없이 간단하게 사용할 수 있습니다.</li>
      <li><strong>풍부한 기능</strong>: 자동 재연결, 브로드캐스트, 룸 기능 등 실시간 애플리케이션 구축에 필요한 다양한 기능을 내장하고 있습니다.</li>
      <li><strong>다양한 폴백 지원</strong>: 웹소켓을 사용할 수 없는 환경에서도 폴백을 통해 통신이 가능합니다.</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li><strong>추가적인 오버헤드</strong>: 여러 기능이 내장되어 있어 <code class="language-plaintext highlighter-rouge">ws</code> 모듈보다 무겁습니다.</li>
      <li><strong>표준과 다름</strong>: 표준 웹소켓과 100% 호환되지 않을 수 있어 특정 상황에서는 제한이 있을 수 있습니다.</li>
      <li><strong>클라이언트 라이브러리 의존성</strong>: 서버와 클라이언트가 모두 <code class="language-plaintext highlighter-rouge">Socket.io</code>를 사용해야 하므로, 웹소켓 클라이언트와의 호환성 문제가 생길 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="주요-차이점-정리"><strong>주요 차이점 정리</strong></h3>

<ul>
  <li><strong>단순함 vs. 편리함</strong>: <code class="language-plaintext highlighter-rouge">ws</code>는 경량으로 단순한 웹소켓 구현에 유리하고, <code class="language-plaintext highlighter-rouge">Socket.io</code>는 다양한 기능과 편리성을 제공합니다.</li>
  <li><strong>표준 준수 vs. 기능 확장성</strong>: <code class="language-plaintext highlighter-rouge">ws</code>는 웹소켓 표준을 따르고, <code class="language-plaintext highlighter-rouge">Socket.io</code>는 추가 기능을 위해 표준을 약간 벗어날 수 있습니다.</li>
  <li><strong>커스터마이징</strong>: <code class="language-plaintext highlighter-rouge">ws</code>는 모든 것을 개발자가 직접 구성할 수 있으며, <code class="language-plaintext highlighter-rouge">Socket.io</code>는 다양한 기능이 이미 구현되어 있어 개발 시간을 단축할 수 있습니다.</li>
</ul>

<h3 id="추천-시나리오"><strong>추천 시나리오</strong></h3>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">ws</code></strong> <strong>사용</strong>: 최대 성능이 필요하거나, 단순한 실시간 통신 기능만 필요한 경우.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Socket.io</code></strong> <strong>사용</strong>: 빠르게 개발해야 하거나, 자동 재연결 및 룸 기능 같은 고급 기능이 필요한 경우.</li>
</ul>

<p>이러한 차이를 이해하면 프로젝트 요구 사항에 맞는 적절한 라이브러리를 선택할 수 있습니다.</p>

<p><strong>⇒ 생산성을 고려해서 브로드캐스트, 네임스페이스, 자동 재연결이 구현되어있는 socket.io가 우리 서비스에 더 적절할 것이라고 생각됨</strong></p>


                </div>
            </section>

            <!-- Email subscribe form at the bottom of the page -->
            
                <section class="subscribe-form">
                    <h3 class="subscribe-form-title">Subscribe to Liboo.blog</h3>
                    <p>Get the latest posts delivered right to your inbox</p>
                    <form method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  /><input class="location" type="hidden" name="location"  /><input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" type="email" name="email"  placeholder="youremail@example.com" />
    </div>
    <button class="" type="submit" disabled><span>Subscribe</span></button>
    <script type="text/javascript">(function(g,h,o,s,t){h[o]('.location')[s]=h[o]('.location')[s] || g.location.href;h[o]('.referrer')[s]=h[o]('.referrer')[s] || h.referrer;})(window,document,'querySelector','value');</script>
</form>

                </section>
            

            <footer class="post-full-footer">
                <!-- Everything inside the #author tags pulls data from the author -->
                <!-- #author-->
                
                    
                
                    
                
                    
                
                    
                
                    
                
                <!-- /author  -->
            </footer>

            <!-- If you use Disqus comments, just uncomment this block.
            The only thing you need to change is "test-apkdzgmqhj" - which
            should be replaced with your own Disqus site-id. -->
            

        </article>

    </div>
</main>

<!-- Links to Previous/Next posts -->
<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            

            <!-- If there's a next post, display it using the same markup included from - partials/post-card.hbs -->
            
                

    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="/Github_Package_%EB%A1%9C_%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC_%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0">
                <div class="post-card-image" style="background-image: url(/upload/2024-11-11-Github_Package_로_라이브러리_배포하기.md/0.png)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/Github_Package_%EB%A1%9C_%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC_%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0">
                <header class="post-card-header">
                    
                        
                            
                               <span class="post-card-tags">Github-package</span>
                            
                        
                            
                                <span class="post-card-tags">Yarn</span>
                            
                        
                    

                    <h2 class="post-card-title">Github Package 로 라이브러리 배포하기</h2>
                </header>
                <section class="post-card-excerpt">
                    
                        <p>프로젝트를 진행하면서 node-media-server 라이브러리를 사용하기로 결정해서 소스 코드를 천천히 뜯어보니 우리 서비스에 맞게끔 코드를 조금 수정할 필요가 있었다.

</p>
                    
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                
                    
                
                    
                
                    
                
                    
                
                <span class="reading-time">
                    
                    
                      3 min read
                    
                </span>
            </footer>
        </div>
    </article>

            

            <!-- If there's a previous post, display it using the same markup included from - partials/post-card.hbs -->
            
                

    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="/docker-_%EC%9D%B8%ED%94%84%EB%9D%BC_%EA%B0%90%EC%9E%90%EC%9D%98_Docker_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC">
                <div class="post-card-image" style="background-image: url(/upload/2024-11-09-[docker]_인프라_감자의_Docker_튜토리얼.md/0.png)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/docker-_%EC%9D%B8%ED%94%84%EB%9D%BC_%EA%B0%90%EC%9E%90%EC%9D%98_Docker_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC">
                <header class="post-card-header">
                    

                    <h2 class="post-card-title">[docker] 인프라 감자의 Docker 튜토리얼</h2>
                </header>
                <section class="post-card-excerpt">
                    
                        <p>
  목차


</p>
                    
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                
                    
                
                    
                
                    
                
                    
                
                <span class="reading-time">
                    
                    
                      7 min read
                    
                </span>
            </footer>
        </div>
    </article>

            

        </div>
    </div>
</aside>

<!-- Floating header which appears on-scroll, included from includes/floating-header.hbs -->
<div class="floating-header">
    <div class="floating-header-logo">
        <a href="https://blog.liboo.kr/">
            
                <img src="/assets/images/favicon.png" alt="Liboo.blog icon" />
            
            <span>Liboo.blog</span>
        </a>
    </div>
    <span class="floating-header-divider">&mdash;</span>
    <div class="floating-header-title">웹 소켓의 실시간 양방향 통신 [feat. WS vs Socket.io]</div>
    <div class="floating-header-share">
        <div class="floating-header-share-label">Share this <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"/>
</svg>
</div>
        <a class="floating-header-share-tw" href="https://twitter.com/share?text=%EC%9B%B9+%EC%86%8C%EC%BC%93%EC%9D%98+%EC%8B%A4%EC%8B%9C%EA%B0%84+%EC%96%91%EB%B0%A9%ED%96%A5+%ED%86%B5%EC%8B%A0+%5Bfeat.+WS+vs+Socket.io%5D&amp;url=https://jekyllt.github.io/jasper2/%EC%9B%B9_%EC%86%8C%EC%BC%93%EC%9D%98_%EC%8B%A4%EC%8B%9C%EA%B0%84_%EC%96%91%EB%B0%A9%ED%96%A5_%ED%86%B5%EC%8B%A0_-feat._WS_vs_Socket.io"
            onclick="window.open(this.href, 'share-twitter', 'width=550,height=235');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>

        </a>
        <a class="floating-header-share-fb" href="https://www.facebook.com/sharer/sharer.php?u=https://jekyllt.github.io/jasper2/%EC%9B%B9_%EC%86%8C%EC%BC%93%EC%9D%98_%EC%8B%A4%EC%8B%9C%EA%B0%84_%EC%96%91%EB%B0%A9%ED%96%A5_%ED%86%B5%EC%8B%A0_-feat._WS_vs_Socket.io"
            onclick="window.open(this.href, 'share-facebook','width=580,height=296');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>

        </a>
    </div>
    <progress class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>


<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->


        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://blog.liboo.kr/">Liboo.blog</a> &copy; 2024</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    <a href="https://facebook.com/ghost" target="_blank" rel="noopener">Facebook</a>
                    <a href="https://twitter.com/tryghost" target="_blank" rel="noopener">Twitter</a>
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
        <div id="subscribe" class="subscribe-overlay">
            <a class="subscribe-overlay-close" href="#"></a>
            <div class="subscribe-overlay-content">
                
                    <img class="subscribe-overlay-logo" src="/assets/images/blog-icon.png" alt="Liboo.blog" />
                
                <h1 class="subscribe-overlay-title">Subscribe to Liboo.blog</h1>
                <p class="subscribe-overlay-description">Stay up to date! Get all the latest &amp; greatest posts delivered straight to your inbox</p>
                <form method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  /><input class="location" type="hidden" name="location"  /><input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" type="email" name="email"  placeholder="youremail@example.com" />
    </div>
    <button class="" type="submit" disabled><span>Subscribe</span></button>
    <script type="text/javascript">(function(g,h,o,s,t){h[o]('.location')[s]=h[o]('.location')[s] || g.location.href;h[o]('.referrer')[s]=h[o]('.referrer')[s] || h.referrer;})(window,document,'querySelector','value');</script>
</form>

            </div>
        </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-69281367-1', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
